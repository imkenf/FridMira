From 1bcc9f13f0b608026b5a880a996c44e0ebefa55c Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 17:02:38 +0800
Subject: [PATCH 003/006] Integrate FridMira server functionality

---
 server/server.vala | 486 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 459 insertions(+), 27 deletions(-)

diff --git a/server/server.vala b/server/server.vala
index 67bf4b38..fd627bd4 100644
--- a/server/server.vala
+++ b/server/server.vala
@@ -18,6 +18,23 @@ namespace Frida.Server {
 	private static bool report_crashes = true;
 	private static bool verbose = false;
 
+	// FridMira anti-detection framework control variables
+	// FridMira反检测框架控制变量
+	private static bool fridmira_enabled = false;
+	private static bool fridmira_no_symbol = false;
+	private static bool fridmira_no_thread = false;
+	private static bool fridmira_no_rpc = false;
+	private static bool fridmira_no_file = false;
+	private static bool fridmira_no_gum = false;
+	private static bool fridmira_no_preload = false;
+
+	// FridMira diagnostic options
+	// FridMira诊断选项
+	private static bool fridmira_show_config = false;
+	private static bool fridmira_show_status = false;
+	private static bool fridmira_export_json = false;
+	private static bool fridmira_show_examples = false;
+
 	private enum PolicySoftenerFlavor {
 		SYSTEM,
 		INTERNAL;
@@ -29,6 +46,113 @@ namespace Frida.Server {
 
 	private delegate void ReadyHandler (bool success);
 
+	/**
+	 * Setup FridMira environment for diagnostic operations only
+	 * 仅为诊断操作设置FridMira环境
+	 *
+	 * CRITICAL: This must use the EXACT SAME configuration as the actual server
+	 * to ensure diagnostic information matches what clients will encounter.
+	 * 关键：这必须使用与实际服务器完全相同的配置，以确保诊断信息
+	 * 与客户端遇到的情况匹配。
+	 */
+	private static void setup_fridmira_environment_for_diagnostics() {
+		// Use the same FridMira mode logic as the actual server startup
+		// 使用与实际服务器启动相同的FridMira模式逻辑
+		bool effective_fridmira_enabled = fridmira_enabled;
+
+		// Check environment variables if not explicitly enabled via CLI
+		// 如果没有通过CLI显式启用，检查环境变量
+		if (!effective_fridmira_enabled) {
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			effective_fridmira_enabled = (global_mode == "1");
+		}
+
+		if (effective_fridmira_enabled) {
+			// Set FridMira environment variables using the same logic as server startup
+			// 使用与服务器启动相同的逻辑设置FridMira环境变量
+			GLib.Environment.set_variable ("FRIDMIRA_MODE", "1", true);
+			GLib.Environment.set_variable ("FRIDMIRA_SYMBOL_MODE", fridmira_no_symbol ? "0" : "1", true);
+			GLib.Environment.set_variable ("FRIDMIRA_THREAD_MODE", fridmira_no_thread ? "0" : "1", true);
+			GLib.Environment.set_variable ("FRIDMIRA_RPC_MODE", fridmira_no_rpc ? "0" : "1", true);
+			GLib.Environment.set_variable ("FRIDMIRA_FILE_MODE", fridmira_no_file ? "0" : "1", true);
+			GLib.Environment.set_variable ("FRIDMIRA_GUM_MODE", fridmira_no_gum ? "0" : "1", true);
+
+			// Initialize FridMira framework for diagnostic access
+			// 初始化FridMira框架以供诊断访问
+			try {
+				Frida.FridMira.bootstrap_initialization (false);
+				Frida.FridMira.initialize_fridmira_framework (false);
+			} catch (Error e) {
+				stderr.printf ("Warning: FridMira initialization failed for diagnostics: %s\n", e.message);
+			}
+		} else {
+			// Ensure FridMira is disabled for diagnostics if not enabled
+			// 如果未启用，确保诊断中禁用FridMira
+			GLib.Environment.set_variable ("FRIDMIRA_MODE", "0", true);
+		}
+	}
+
+	/**
+	 * Process FridMira environment variables with hierarchical priority
+	 * 处理FridMira环境变量，采用分层优先级机制
+	 *
+	 * Priority order (highest to lowest):
+	 * 优先级顺序（从高到低）：
+	 * 1. Command line arguments / 命令行参数
+	 * 2. Environment variables / 环境变量
+	 * 3. Default values / 默认值
+	 */
+	private static void process_fridmira_environment_variables () {
+		// Process environment variables as default values
+		// 处理环境变量作为默认值
+		// CLI arguments will override these settings
+		// CLI参数将覆盖这些设置
+
+		// Check global FridMira mode environment variable
+		// 检查全局FridMira模式环境变量
+		string? fridmira_mode = GLib.Environment.get_variable ("FRIDMIRA_MODE");
+		if (fridmira_mode != null && fridmira_mode == "1") {
+			fridmira_enabled = true;
+		}
+
+		// Process individual feature environment variables
+		// 处理各个功能的环境变量
+		string? symbol_mode = GLib.Environment.get_variable ("FRIDMIRA_SYMBOL_MODE");
+		if (symbol_mode != null && symbol_mode == "0") {
+			// Disable symbol obfuscation
+			// 禁用符号混淆
+			fridmira_no_symbol = true;
+		}
+
+		string? thread_mode = GLib.Environment.get_variable ("FRIDMIRA_THREAD_MODE");
+		if (thread_mode != null && thread_mode == "0") {
+			// Disable thread obfuscation
+			// 禁用线程混淆
+			fridmira_no_thread = true;
+		}
+
+		string? rpc_mode = GLib.Environment.get_variable ("FRIDMIRA_RPC_MODE");
+		if (rpc_mode != null && rpc_mode == "0") {
+			// Disable RPC obfuscation
+			// 禁用RPC混淆
+			fridmira_no_rpc = true;
+		}
+
+		string? file_mode = GLib.Environment.get_variable ("FRIDMIRA_FILE_MODE");
+		if (file_mode != null && file_mode == "0") {
+			// Disable file obfuscation
+			// 禁用文件混淆
+			fridmira_no_file = true;
+		}
+
+		string? gum_mode = GLib.Environment.get_variable ("FRIDMIRA_GUM_MODE");
+		if (gum_mode != null && gum_mode == "0") {
+			// Disable GUM memory obfuscation
+			// 禁用GUM内存混淆
+			fridmira_no_gum = true;
+		}
+	}
+
 	const OptionEntry[] option_entries = {
 		{ "version", 0, 0, OptionArg.NONE, ref output_version, "Output version information and exit", null },
 		{ "device", 0, 0, OptionArg.STRING, ref device_id, "Serve device with the given ID", "ID" },
@@ -48,6 +172,31 @@ namespace Frida.Server {
 		{ "ignore-crashes", 'C', OptionFlags.REVERSE, OptionArg.NONE, ref report_crashes,
 			"Disable native crash reporter integration", null },
 		{ "verbose", 'v', 0, OptionArg.NONE, ref verbose, "Be verbose", null },
+
+		// FridMira anti-detection framework command line options
+		// FridMira反检测框架命令行选项
+		{ "fridmira", 0, 0, OptionArg.NONE, ref fridmira_enabled,
+			"Enable FridMira anti-detection framework", null },
+		{ "no-symbol", 0, 0, OptionArg.NONE, ref fridmira_no_symbol,
+			"Disable symbol obfuscation (requires --fridmira)", null },
+		{ "no-thread", 0, 0, OptionArg.NONE, ref fridmira_no_thread,
+			"Disable thread obfuscation (requires --fridmira)", null },
+		{ "no-rpc", 0, 0, OptionArg.NONE, ref fridmira_no_rpc,
+			"Disable RPC obfuscation (requires --fridmira)", null },
+		{ "no-file", 0, 0, OptionArg.NONE, ref fridmira_no_file,
+			"Disable file obfuscation (requires --fridmira)", null },
+		{ "no-gum", 0, 0, OptionArg.NONE, ref fridmira_no_gum,
+			"Disable GUM memory obfuscation (requires --fridmira)", null },
+		{ "no-preload", 0, 0, OptionArg.NONE, ref fridmira_no_preload,
+			"Disable preload optimization with FridMira (for debugging)", null },
+		{ "show-config", 0, 0, OptionArg.NONE, ref fridmira_show_config,
+			"Show FridMira client protocol configuration and exit", null },
+		{ "show-status", 0, 0, OptionArg.NONE, ref fridmira_show_status,
+			"Show FridMira server status report and exit", null },
+		{ "export-json", 0, 0, OptionArg.NONE, ref fridmira_export_json,
+			"Export FridMira protocol configuration as JSON and exit", null },
+		{ "show-examples", 0, 0, OptionArg.NONE, ref fridmira_show_examples,
+			"Show FridMira usage examples and exit", null },
 		{ null }
 	};
 
@@ -60,6 +209,10 @@ namespace Frida.Server {
 		}
 #endif
 
+		// Process FridMira environment variables as default values
+		// 处理FridMira环境变量作为默认值
+		process_fridmira_environment_variables ();
+
 		try {
 			var ctx = new OptionContext ();
 			ctx.set_help_enabled (true);
@@ -71,13 +224,64 @@ namespace Frida.Server {
 			return 1;
 		}
 
+		if (fridmira_enabled) {
+			// Validate FridMira sub-options
+			// 验证FridMira子选项
+			if (fridmira_no_symbol || fridmira_no_thread || fridmira_no_rpc ||
+				fridmira_no_file || fridmira_no_gum) {
+				// This is a simple check. More complex validation could be added.
+			}
+		} else if (fridmira_no_symbol || fridmira_no_thread || fridmira_no_rpc ||
+			   fridmira_no_file || fridmira_no_gum || fridmira_no_preload) {
+			printerr ("Error: FridMira sub-options (--no-symbol, --no-thread, --no-rpc, --no-file, --no-gum, --no-preload) require --fridmira to be enabled.\n");
+			printerr ("Run '%s --help' to see usage information.\n", args[0]);
+			return 1;
+		}
+
 		if (output_version) {
 			stdout.printf ("%s\n", version_string ());
 			return 0;
 		}
 
+		// Handle diagnostic options (independent of FridMira mode)
+		// 处理诊断选项（独立于FridMira模式）
+		if (fridmira_show_examples) {
+			stdout.printf ("%s\n", Frida.FridMiraDiagnostics.RpcProtocolDiagnostic.get_usage_examples());
+			return 0;
+		}
+
+		if (fridmira_show_config || fridmira_show_status || fridmira_export_json) {
+			// Initialize with current configuration (works with or without --fridmira)
+			// 使用当前配置初始化（无论是否使用--fridmira都能工作）
+			setup_fridmira_environment_for_diagnostics();
+
+			if (fridmira_show_config) {
+				stdout.printf ("%s\n", Frida.FridMiraDiagnostics.RpcProtocolDiagnostic.get_client_protocol_config());
+				return 0;
+			}
+
+			if (fridmira_show_status) {
+				stdout.printf ("%s\n", Frida.FridMiraDiagnostics.RpcProtocolDiagnostic.get_server_status());
+				return 0;
+			}
+
+			if (fridmira_export_json) {
+				stdout.printf ("%s\n", Frida.FridMiraDiagnostics.RpcProtocolDiagnostic.export_protocol_config_json());
+				return 0;
+			}
+		}
+
 		Environment.set_verbose_logging_enabled (verbose);
 
+		// FIXED: 同时设置FRIDA_VERBOSE环境变量，确保FridMira能够检测到verbose模式
+		// 这样FridMira的Environment.get_variable("FRIDA_VERBOSE")检查就能正常工作
+		if (verbose) {
+			GLib.Environment.set_variable ("FRIDA_VERBOSE", "1", true);
+			if (fridmira_enabled) {
+				stdout.printf ("FridMira: Verbose mode enabled via -v parameter\n");
+			}
+		}
+
 		EndpointParameters endpoint_params;
 		try {
 			endpoint_params = new EndpointParameters (listen_address, 0, parse_certificate (certpath), origin,
@@ -89,9 +293,17 @@ namespace Frida.Server {
 		}
 
 		var options = new ControlServiceOptions ();
-		options.enable_preload = enable_preload;
+		options.enable_preload = enable_preload && !fridmira_no_preload;
 		options.report_crashes = report_crashes;
 
+		// Pass FridMira settings through the options object
+		options.fridmira_enabled = fridmira_enabled;
+		options.fridmira_no_symbol = fridmira_no_symbol;
+		options.fridmira_no_thread = fridmira_no_thread;
+		options.fridmira_no_rpc = fridmira_no_rpc;
+		options.fridmira_no_file = fridmira_no_file;
+		options.fridmira_no_gum = fridmira_no_gum;
+
 #if (IOS || TVOS) && !HAVE_EMBEDDED_ASSETS
 		string? program_path = null;
 		Gum.Process.enumerate_modules (m => {
@@ -179,12 +391,32 @@ namespace Frida.Server {
 		Environment.configure ();
 
 #if DARWIN
-		var worker = new Thread<int> ("frida-server-main-loop", () => {
-			var exit_code = run_application (device_id, endpoint_params, options, on_ready);
-
-			_stop_run_loop ();
+		// Apply FridMira thread name obfuscation for anti-detection
+		// 应用FridMira线程名混淆以实现反检测
+		string thread_name = "frida-server-main-loop";
+		if (fridmira_enabled) {
+			thread_name = Frida.FridMiraThreadObfuscator.obfuscate_thread_name("frida-server-main-loop");
+			if (verbose) {
+				stdout.printf ("FridMira: Thread name obfuscation applied\n");
+				stdout.printf ("FridMira:   Original: 'frida-server-main-loop'\n");
+				stdout.printf ("FridMira:   Obfuscated: '%s'\n", thread_name);
+			}
+		} else {
+			if (verbose) {
+				stdout.printf ("FridMira: Using standard thread name: '%s'\n", thread_name);
+			}
+		}
 
-			return exit_code;
+		var worker = new Thread<int> (thread_name, () => {
+			try {
+				var exit_code = run_application (device_id, endpoint_params, options, on_ready);
+				_stop_run_loop ();
+				return exit_code;
+			} catch (Error e) {
+				stderr.printf ("FridMira: Fatal error in main thread: %s\n", e.message);
+				_stop_run_loop ();
+				return 1;
+			}
 		});
 		_start_run_loop ();
 
@@ -192,23 +424,119 @@ namespace Frida.Server {
 
 		return exit_code;
 #else
-		return run_application (device_id, endpoint_params, options, on_ready);
+		// Early initialization is now handled in run_application() for consistency
+		// 早期初始化现在在run_application()中处理以保持一致性
+		try {
+			return run_application (device_id, endpoint_params, options, on_ready);
+		} catch (Error e) {
+			stderr.printf ("FridMira: Fatal error: %s\n", e.message);
+			return 1;
+		}
 #endif
 	}
 
 	private static int run_application (string? device_id, EndpointParameters endpoint_params, ControlServiceOptions options,
-			ReadyHandler on_ready) {
-		TemporaryDirectory.always_use ((directory != null) ? directory : DEFAULT_DIRECTORY);
-		TemporaryDirectory.use_sysroot (options.sysroot);
+			ReadyHandler on_ready) throws Error {
+		if (verbose) {
+			stdout.printf ("FridMira: Initializing server...\n");
+		}
 
-		application = new Application (device_id, endpoint_params, options);
+		// CRITICAL: Initialize FridMira BEFORE any system initialization (like v1.00)
+		// 关键：在任何系统初始化之前初始化FridMira
+		if (options.fridmira_enabled) {
+			if (verbose) {
+				stdout.printf ("FridMira: ==========================================\n");
+				stdout.printf ("FridMira: Anti-Detection Framework Bootstrap\n");
+				stdout.printf ("FridMira: ==========================================\n");
+			}
 
-		Posix.signal (Posix.Signal.INT, (sig) => {
-			application.stop ();
-		});
-		Posix.signal (Posix.Signal.TERM, (sig) => {
-			application.stop ();
-		});
+			try {
+				// STEP 1: Bootstrap initialization FIRST (lightweight early protection)
+				// 步骤1：首先进行Bootstrap初始化（轻量级早期混淆）
+				Frida.FridMira.bootstrap_initialization (verbose);
+
+				// STEP 2: Set environment variables for individual modules
+				// 步骤2：为各个模块设置环境变量
+				GLib.Environment.set_variable ("FRIDMIRA_MODE", "1", true);
+
+				// Set verbose mode if requested by -v parameter
+				// 如果通过-v参数请求，设置详细模式
+				if (verbose) {
+					GLib.Environment.set_variable ("FRIDMIRA_VERBOSE", "1", true);
+					GLib.Environment.set_variable ("FRIDA_VERBOSE", "1", true);
+				}
+
+				GLib.Environment.set_variable ("FRIDMIRA_SYMBOL_MODE", options.fridmira_no_symbol ? "0" : "1", true);
+				GLib.Environment.set_variable ("FRIDMIRA_THREAD_MODE", options.fridmira_no_thread ? "0" : "1", true);
+				GLib.Environment.set_variable ("FRIDMIRA_RPC_MODE", options.fridmira_no_rpc ? "0" : "1", true);
+				GLib.Environment.set_variable ("FRIDMIRA_FILE_MODE", options.fridmira_no_file ? "0" : "1", true);
+				GLib.Environment.set_variable ("FRIDMIRA_GUM_MODE", options.fridmira_no_gum ? "0" : "1", true);
+
+				// STEP 3: Initialize main FridMira framework (full protection)
+				// 步骤3：初始化主FridMira框架（完整加载混淆）
+				Frida.FridMira.initialize_fridmira_framework (verbose);
+
+				if (verbose) {
+					stdout.printf ("FridMira: Bootstrap completed - preload protection active\n");
+					stdout.printf ("FridMira: ==========================================\n");
+				}
+			} catch (Error e) {
+				stderr.printf ("FridMira: CRITICAL ERROR during bootstrap: %s\n", e.message);
+				stderr.printf ("FridMira: Disabling framework and continuing with standard mode\n");
+				// Disable FridMira and continue with standard mode
+				// 禁用FridMira并继续使用标准模式
+				options.fridmira_enabled = false;
+				GLib.Environment.set_variable ("FRIDMIRA_MODE", "0", true);
+			}
+		}
+
+		// NOW it's safe to initialize TemporaryDirectory and trigger preload
+		// 现在可以安全地初始化TemporaryDirectory并触发preload
+		if (verbose) {
+			stdout.printf ("FridMira: Initializing TemporaryDirectory...\n");
+		}
+
+		try {
+			// 使用混淆的临时目录名（如果FridMira已bootstrap）
+			// Use obfuscated temporary directory name (if FridMira bootstrapped)
+			string temp_dir_name;
+			string? obfuscated_name = GLib.Environment.get_variable ("FRIDMIRA_TEMP_DIR_NAME");
+			if (obfuscated_name != null && options.fridmira_enabled) {
+				temp_dir_name = obfuscated_name;
+				if (verbose) {
+					stdout.printf ("FridMira: Using obfuscated directory: %s\n", temp_dir_name);
+				}
+			} else {
+				temp_dir_name = (directory != null) ? directory : DEFAULT_DIRECTORY;
+				if (verbose) {
+					stdout.printf ("FridMira: Using standard directory: %s\n", temp_dir_name);
+				}
+			}
+
+			TemporaryDirectory.always_use (temp_dir_name);
+			TemporaryDirectory.use_sysroot (options.sysroot);
+			if (verbose) {
+				stdout.printf ("FridMira: TemporaryDirectory initialized successfully\n");
+			}
+		} catch (Error e) {
+			stderr.printf ("FridMira: ERROR during TemporaryDirectory initialization: %s\n", e.message);
+			throw e;
+		}
+
+		if (verbose) {
+			stdout.printf ("FridMira: Creating Application instance...\n");
+		}
+
+		try {
+			application = new Application (device_id, endpoint_params, options);
+		} catch (Error e) {
+			stderr.printf ("FridMira: ERROR during Application creation: %s\n", e.message);
+			throw e;
+		}
+
+		// Setup improved signal handlers for graceful shutdown
+		// 设置改进的信号处理器以实现优雅关闭
+		setup_signal_handlers ();
 
 		if (on_ready != null) {
 			application.ready.connect (success => {
@@ -220,6 +548,54 @@ namespace Frida.Server {
 		return application.run ();
 	}
 
+	/**
+	 * Setup improved signal handlers for graceful shutdown
+	 * 设置改进的信号处理器以实现优雅关闭
+	 */
+	private static void setup_signal_handlers () {
+		// Configure main-loop friendly signal handlers using GLib.unix_signal_add
+		// 使用 GLib.unix_signal_add 配置与主循环兼容的信号处理器，避免在异步信号环境中调用非安全函数
+#if !WINDOWS
+		GLib.Unix.signal_add (Posix.Signal.INT, () => {
+			if (verbose) {
+				stdout.printf ("FridMira: Received SIGINT, shutting down...\n");
+			}
+
+			// Schedule stop on idle to ensure we are on the main context
+			GLib.Idle.add (() => {
+				if (application != null) {
+					application.stop ();
+				} else {
+					Posix.exit (0);
+				}
+				return GLib.Source.REMOVE;
+			});
+
+			// Keep source, no further notifications needed
+			return GLib.Source.REMOVE;
+		});
+
+		GLib.Unix.signal_add (Posix.Signal.TERM, () => {
+			if (verbose) {
+				stdout.printf ("FridMira: Received SIGTERM, shutting down...\n");
+			}
+
+			GLib.Idle.add (() => {
+				if (application != null) {
+					application.stop ();
+				} else {
+					Posix.exit (0);
+				}
+				return GLib.Source.REMOVE;
+			});
+
+			return GLib.Source.REMOVE;
+		});
+#else
+		// On Windows signals are limited; rely on default handler
+#endif
+	}
+
 	namespace Environment {
 		public extern void init ();
 		public extern void set_verbose_logging_enabled (bool enabled);
@@ -284,22 +660,53 @@ namespace Frida.Server {
 		}
 
 		private async void start () {
+			if (verbose) {
+				stdout.printf ("FridMira: Starting services...\n");
+			}
+
 			try {
 				if (device_id != null && device_id != "local") {
-					manager = new DeviceManager.with_nonlocal_backends_only ();
-
-					var device = yield manager.get_device_by_id (device_id, 0, io_cancellable);
-					device.lost.connect (on_device_lost);
-
-					service = yield new ControlService.with_device (device, endpoint_params, options);
+					if (verbose) {
+						stdout.printf ("FridMira: Connecting to remote device: %s\n", device_id);
+					}
+
+					try {
+						manager = new DeviceManager.with_nonlocal_backends_only ();
+						var device = yield manager.get_device_by_id (device_id, 0, io_cancellable);
+						device.lost.connect (on_device_lost);
+						service = yield new ControlService.with_device (device, endpoint_params, options);
+					} catch (GLib.Error e) {
+						stderr.printf ("FridMira: ERROR during remote device setup: %s\n", e.message);
+						throw e;
+					}
 				} else {
-					service = new ControlService (endpoint_params, options);
+					if (verbose) {
+						stdout.printf ("FridMira: Starting local control service...\n");
+					}
+
+					try {
+						service = new ControlService (endpoint_params, options);
+					} catch (GLib.Error e) {
+						stderr.printf ("FridMira: ERROR during local ControlService creation: %s\n", e.message);
+						throw e;
+					}
+				}
+
+				try {
+					yield service.start (io_cancellable);
+				} catch (GLib.Error e) {
+					stderr.printf ("FridMira: ERROR during service start: %s\n", e.message);
+					throw e;
 				}
 
-				yield service.start (io_cancellable);
 			} catch (GLib.Error e) {
-				if (e is IOError.CANCELLED)
+				if (e is IOError.CANCELLED) {
+					if (verbose) {
+						stdout.printf ("FridMira: Operation cancelled\n");
+					}
 					return;
+				}
+				stderr.printf ("FridMira: CRITICAL ERROR during startup: %s\n", e.message);
 				printerr ("Unable to start: %s\n", e.message);
 				exit_code = 5;
 				loop.quit ();
@@ -308,12 +715,19 @@ namespace Frida.Server {
 			}
 
 			Idle.add (() => {
+				if (verbose) {
+					stdout.printf ("FridMira: Server ready and listening\n");
+				}
 				ready (true);
 				return false;
 			});
 		}
 
 		public void stop () {
+			if (verbose) {
+				stdout.printf ("FridMira: Stopping server...\n");
+			}
+
 			Idle.add (() => {
 				perform_stop.begin ();
 				return false;
@@ -321,32 +735,48 @@ namespace Frida.Server {
 		}
 
 		private async void perform_stop () {
-			if (stopping)
+			if (stopping) {
 				return;
+			}
 			stopping = true;
 
 			io_cancellable.cancel ();
 
 			try {
 				if (service != null) {
+					if (verbose) {
+						stdout.printf ("FridMira: Stopping services...\n");
+					}
 					yield service.stop ();
 					service = null;
 				}
 
 				if (manager != null) {
+					if (verbose) {
+						stdout.printf ("FridMira: Closing device manager...\n");
+					}
 					yield manager.close ();
 					manager = null;
 				}
 			} catch (GLib.Error e) {
+				if (verbose) {
+					stdout.printf ("FridMira: Error during shutdown: %s\n", e.message);
+				}
 			}
 
 			Idle.add (() => {
+				if (verbose) {
+					stdout.printf ("FridMira: Shutdown complete\n");
+				}
 				loop.quit ();
 				return false;
 			});
 		}
 
 		private void on_device_lost () {
+			if (verbose) {
+				stdout.printf ("FridMira: Device lost, initiating shutdown...\n");
+			}
 			stop ();
 		}
 	}
@@ -357,4 +787,6 @@ namespace Frida.Server {
 
 		return new TlsCertificate.from_file (path);
 	}
+
+
 }
-- 
2.45.1.windows.1


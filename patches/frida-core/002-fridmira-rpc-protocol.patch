From a18d75e9818fbdddb4396e063051fce23628b902 Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Tue, 17 Jun 2025 15:37:05 +0800
Subject: [PATCH 002/006] Add FridMira RPC Protocol Module

---
 lib/base/rpc.vala          | 240 +++++++++++++++++++++++++++++++++++-
 lib/mira/fridmira-rpc.vala | 245 +++++++++++++++++++++++++++++++++++++
 2 files changed, 480 insertions(+), 5 deletions(-)
 create mode 100644 lib/mira/fridmira-rpc.vala

diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index c465452..dc8dfc8 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -1,25 +1,190 @@
+/*
+ * FRIDMIRA ENHANCED RPC MODULE / FRIDMIRA增强RPC模块
+ *
+ * This module provides enhanced RPC communication capabilities with FridMira
+ * anti-detection support. Key features include:
+ *
+ * 此模块提供增强的RPC通信能力，支持FridMira反检测功能。主要特性包括：
+ *
+ * - Dynamic Protocol Support / 动态协议支持:
+ *   Supports both standard "frida:rpc" and FridMira dynamic protocols
+ *   支持标准"frida:rpc"和FridMira动态协议
+ *
+ * - Protocol Discovery / 协议发现:
+ *   Automatic discovery of server's dynamic protocol parameters
+ *   自动发现服务器的动态协议参数
+ *
+ * - Session Management / 会话管理:
+ *   Per-session protocol tracking and memory management
+ *   按会话协议跟踪和内存管理
+ *
+ * - Anti-Detection / 反检测:
+ *   Breaks static protocol fingerprints for enhanced stealth
+ *   破坏静态协议指纹以增强隐蔽性
+ */
+
 namespace Frida {
+	/**
+	 * RPC Protocol Enhancer Interface / RPC协议增强器接口
+	 *
+	 * Defines the contract for modules that can enhance the RPC protocol,
+	 * for example by providing dynamic identifiers for anti-detection.
+	 *
+	 * 定义了可以增强RPC协议的模块的契约，例如通过提供动态标识符以实现反检测。
+	 */
+	public interface RpcProtocolEnhancer : Object {
+		public abstract string get_protocol_id (string? session_id);
+		public abstract string get_call_command (string? session_id);
+		public abstract string get_ok_response (string? session_id);
+		public abstract string get_dynamic_protocol_id ();
+		public abstract bool is_valid_protocol (string protocol);
+		public abstract bool is_valid_ok_response (string status);
+		public abstract void forget_session (string session_id);
+		public abstract bool try_handle_message (string json, RpcPeer peer);
+		public abstract async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError;
+	}
+
+	/**
+	 * Enhanced RPC Client with FridMira Anti-Detection Support
+	 * 支持FridMira反检测的增强RPC客户端
+	 *
+	 * This enhanced RPC client extends the standard Frida RPC capabilities with:
+	 * - Dynamic protocol support for stealth operations
+	 * - Protocol discovery capabilities for automatic configuration
+	 * - Session-specific protocol tracking
+	 * - Pluggable enhancer architecture
+	 *
+	 * 此增强RPC客户端扩展了标准Frida RPC功能，包括：
+	 * - 用于隐蔽操作的动态协议支持
+	 * - 用于自动配置的协议发现功能
+	 * - 特定于会话的协议跟踪
+	 * - 可插拔增强器架构
+	 *
+	 * Usage example / 使用示例:
+	 * ```
+	 * var client = new RpcClient(peer);
+	 * RpcClient.enhancer = new FridMiraRpcEnhancerAdapter();
+	 * var protocol_info = yield client.discover_protocol(cancellable);
+	 * var result = yield client.call("method_name", args, data, cancellable);
+	 * ```
+	 *
+	 * The client automatically handles session cleanup and protocol memory management
+	 * via the enhancer when the session ends.
+	 *
+	 * 客户端在会话结束时通过增强器自动处理会话清理和协议内存管理。
+	 */
 	public sealed class RpcClient : Object {
+		/**
+		 * Pluggable RPC protocol enhancer / 可插拔的RPC协议增强器
+		 *
+		 * This "slot" allows an external module (like FridMira) to provide
+		 * enhanced RPC capabilities at runtime. If null, standard RPC behavior
+		 * is used.
+		 *
+		 * 这个"插槽"允许外部模块（如FridMira）在运行时提供增强的RPC能力。
+		 * 如果为null，则使用标准RPC行为。
+		 */
+		public static RpcProtocolEnhancer? enhancer = null;
+
 		public weak RpcPeer peer {
 			get;
 			construct;
 		}
 
+		/**
+		 * Session identifier for protocol tracking / 用于协议跟踪的会话标识符
+		 *
+		 * Each RPC client instance maintains its own session ID for protocol
+		 * tracking and memory management in the enhancer.
+		 *
+		 * 每个RPC客户端实例在增强器中维护自己的会话ID以进行协议跟踪和内存管理。
+		 */
+		private string _session_id;
+
 		private Gee.HashMap<string, PendingResponse> pending_responses = new Gee.HashMap<string, PendingResponse> ();
 
 		public RpcClient (RpcPeer peer) {
 			Object (peer: peer);
+			_session_id = Uuid.string_random ();
+		}
+
+		/**
+		 * Destructor: Clean up FridMira session resources / 析构函数：清理FridMira会话资源
+		 *
+		 * Automatically cleans up session-specific protocol memory in the
+		 * enhancer when this RPC client instance is destroyed.
+		 *
+		 * 当此RPC客户端实例被销毁时，自动清理增强器中特定于会话的协议内存。
+		 *
+		 * This ensures no memory leaks from dynamic protocol tracking.
+		 * 这确保动态协议跟踪不会产生内存泄漏。
+		 */
+		~RpcClient() {
+			// Clean up session protocol memory in the enhancer, if one is plugged in
+			// 如果有增强器插件，则在增强器中清理会话协议内存
+			if (enhancer != null) {
+				enhancer.forget_session (_session_id);
+			}
+		}
+
+		/**
+		 * FridMira Protocol Discovery API / FridMira协议发现API
+		 *
+		 * Discovers the server's dynamic protocol parameters for enhanced stealth.
+		 * This allows the client to automatically adapt to the server's current
+		 * anti-detection configuration.
+		 *
+		 * 发现服务器的动态协议参数以增强隐蔽性。这允许客户端自动适应服务器当前的反检测配置。
+		 *
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON object containing protocol configuration / 包含协议配置的JSON对象
+		 * @throws Error Communication or protocol errors / 通信或协议错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
+		public async Json.Node discover_protocol(Cancellable? cancellable) throws Error, IOError {
+			// Delegate protocol discovery to the enhancer
+			// 将协议发现委托给增强器
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery is not available without a protocol enhancer");
+			}
+			return yield enhancer.discover_protocol (peer, cancellable);
 		}
 
+		/**
+		 * Enhanced RPC Call with FridMira Protocol Support / 支持FridMira协议的增强RPC调用
+		 *
+		 * Performs an RPC call using either standard or enhanced protocols depending
+		 * on the configured enhancer. When an enhancer is present, dynamic protocol
+		 * identifiers are used for anti-detection purposes.
+		 *
+		 * 根据配置的增强器使用标准或增强协议执行RPC调用。当存在增强器时，动态协议标识符用于反检测目的。
+		 *
+		 * @param method The RPC method name to call / 要调用的RPC方法名
+		 * @param args Array of arguments for the method / 方法的参数数组
+		 * @param data Optional binary data to send / 要发送的可选二进制数据
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON response from the server / 来自服务器的JSON响应
+		 * @throws Error RPC execution errors / RPC执行错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
 		public async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
 			string request_id = Uuid.string_random ();
 
+			// Build RPC request using dynamic or standard protocol identifiers
+			// 使用动态或标准协议标识符构建RPC请求
+			string protocol_id = (enhancer != null) ? enhancer.get_protocol_id (_session_id) : "frida:rpc";
+			string call_command = (enhancer != null) ? enhancer.get_call_command (_session_id) : "call";
+
 			var request = new Json.Builder ();
 			request
 				.begin_array ()
-				.add_string_value ("frida:rpc")
+				// Use dynamic protocol ID if available, otherwise static "frida:rpc"
+				// 如果可用，使用动态协议ID，否则使用静态"frida:rpc"
+				.add_string_value (protocol_id)
 				.add_string_value (request_id)
-				.add_string_value ("call")
+				// Use dynamic call command if available, otherwise static "call"
+				// 如果可用，使用动态调用命令，否则使用静态"call"
+				.add_string_value (call_command)
 				.add_string_value (method)
 				.begin_array ();
 			foreach (var arg in args)
@@ -69,8 +234,41 @@ namespace Frida {
 			return pending.result;
 		}
 
+		/**
+		 * Enhanced Message Handler with FridMira Discovery Support / 支持FridMira发现的增强消息处理器
+		 *
+		 * Handles incoming JSON messages with support for both standard RPC responses
+		 * and FridMira protocol discovery messages.
+		 *
+		 * 处理传入的JSON消息，支持标准RPC响应和FridMira协议发现消息。
+		 *
+		 * @param json The JSON message string to process / 要处理的JSON消息字符串
+		 * @return true if message was handled, false otherwise / 如果消息被处理返回true，否则false
+		 */
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			// Give the enhancer a chance to handle the message first (e.g., for discovery)
+			// 首先给增强器一个处理消息的机会（例如，用于发现）
+			if (enhancer != null && enhancer.try_handle_message (json, peer)) {
+				return true;
+			}
+
+			// Dual protocol support check
+			// 双协议支持检查
+			bool has_standard = json.index_of ("\"frida:rpc\"") != -1;
+			bool has_dynamic = false;
+
+			// Check if message contains dynamic protocol identifier, if enhancer is present
+			// 如果存在增强器，检查消息是否包含动态协议标识符
+			if (enhancer != null) {
+				string dynamic_protocol = enhancer.get_dynamic_protocol_id ();
+				if (dynamic_protocol != "" && dynamic_protocol != "frida:rpc") {
+					has_dynamic = json.index_of ("\"" + dynamic_protocol + "\"") != -1;
+				}
+			}
+
+			// Reject messages that don't match any supported protocol
+			// 拒绝不匹配任何支持协议的消息
+			if (!has_standard && !has_dynamic)
 				return false;
 
 			var parser = new Json.Parser ();
@@ -90,6 +288,14 @@ namespace Frida {
 			return handled;
 		}
 
+		/**
+		 * Enhanced RPC Message Handler with Protocol Validation / 带协议验证的增强RPC消息处理器
+		 *
+		 * Process RPC response messages with support for both standard and dynamic protocols
+		 * as well as enhanced status validation via the pluggable enhancer.
+		 *
+		 * 处理RPC响应消息，支持标准和动态协议，以及通过可插拔增强器进行增强状态验证。
+		 */
 		private bool try_handle_rpc_message (Json.Object message) {
 			var payload = message.get_member ("payload");
 			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY)
@@ -98,8 +304,24 @@ namespace Frida {
 			if (rpc_message.get_length () < 4)
 				return false;
 
+			// Extract protocol type from first element
+			// 从第一个元素提取协议类型
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null)
+				return false;
+
+			// Enhanced protocol validation: Support both standard and dynamic protocols via enhancer
+			// 增强协议验证：通过增强器支持标准和动态协议
+			bool is_valid_protocol = false;
+			if (type == "frida:rpc") {
+				is_valid_protocol = true;
+			} else if (enhancer != null && enhancer.is_valid_protocol (type)) {
+				is_valid_protocol = true;
+			}
+
+			// Reject messages with unsupported protocol
+			// 拒绝使用不支持协议的消息
+			if (!is_valid_protocol)
 				return false;
 
 			var request_id_value = rpc_message.get_element (1);
@@ -111,8 +333,16 @@ namespace Frida {
 			if (!pending_responses.unset (request_id, out response))
 				return false;
 
+			// Extract response status with enhanced validation
+			// 提取响应状态并进行增强验证
 			var status = rpc_message.get_string_element (2);
-			if (status == "ok")
+			// Enhanced status validation: Support standard "ok" and dynamic OK responses via enhancer
+			// 增强状态验证：通过增强器支持标准"ok"和动态OK响应
+			bool is_success = (status == "ok") || (enhancer != null && enhancer.is_valid_ok_response (status));
+
+			// Complete the pending response based on status
+			// 根据状态完成待处理响应
+			if (is_success)
 				response.complete_with_result (rpc_message.get_element (3));
 			else
 				response.complete_with_error (new Error.NOT_SUPPORTED (rpc_message.get_string_element (3)));
diff --git a/lib/mira/fridmira-rpc.vala b/lib/mira/fridmira-rpc.vala
new file mode 100644
index 0000000..11aeb56
--- /dev/null
+++ b/lib/mira/fridmira-rpc.vala
@@ -0,0 +1,245 @@
+/**
+ * FridMira: RPC Protocol Module
+ * FridMira: RPC协议模块
+ *
+ * This module contains the adapter that plugs FridMira's RPC enhancement
+ * capabilities into the core Frida RPC client.
+ *
+ * 此模块包含将FridMira的RPC增强能力插入Frida核心RPC客户端的适配器。
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * Adapter to plug FridMira's RPC enhancement into the core RPC client.
+	 * 适配器，用于将FridMira的RPC增强功能插入核心RPC客户端。
+	 *
+	 * This class implements the RpcProtocolEnhancer interface and acts as a
+	 * bridge between the generic RPC client and the static FridMira protocol
+	 * logic. It also contains the self-contained discovery mechanism.
+	 *
+	 * 此类实现RpcProtocolEnhancer接口，充当通用RPC客户端和静态FridMira协议
+	 * 逻辑之间的桥梁。它还包含自包含的发现机制。
+	 */
+	public class FridMiraRpcEnhancerAdapter : Object, RpcProtocolEnhancer {
+		private Gee.HashMap<string, PendingResponse> pending_discoveries = new Gee.HashMap<string, PendingResponse> ();
+
+		public string get_protocol_id (string? session_id) {
+			return Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (session_id);
+		}
+
+		public string get_call_command (string? session_id) {
+			return Frida.FridMiraRpcProtocolEnhancer.get_call_command (session_id);
+		}
+
+		public string get_ok_response (string? session_id) {
+			return Frida.FridMiraRpcProtocolEnhancer.get_ok_response (session_id);
+		}
+
+		public string get_dynamic_protocol_id () {
+			return Frida.FridMiraRpcProtocolEnhancer.get_dynamic_protocol_id ();
+		}
+
+		public bool is_valid_protocol (string protocol) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_protocol (protocol);
+		}
+
+		public bool is_valid_ok_response (string status) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_ok_response (status);
+		}
+
+		public void forget_session (string session_id) {
+			Frida.FridMiraRpcProtocolEnhancer.forget_session (session_id);
+		}
+
+		/**
+		 * Handles both discovery requests (server-side) and responses (client-side).
+		 * 处理发现请求（服务器端）和响应（客户端）。
+		 */
+		public bool try_handle_message (string json, RpcPeer peer) {
+			if (json.index_of ("\"fridmira:discover\"") == -1)
+				return false;
+
+			var parser = new Json.Parser ();
+			try {
+				parser.load_from_data (json);
+			} catch (GLib.Error e) {
+				return false;
+			}
+			var message_node = parser.get_root ();
+			if (message_node.get_node_type () != Json.NodeType.OBJECT)
+				return false;
+			var message = message_node.get_object ();
+
+			var type = message.get_string_member ("type");
+			if (type != "send")
+				return false;
+
+			var payload = message.get_member ("payload");
+			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY)
+				return false;
+
+			var discovery_message = payload.get_array ();
+			if (discovery_message.get_length () < 3)
+				return false;
+
+			string? protocol_type = discovery_message.get_element (0).get_string ();
+			if (protocol_type != "fridmira:discover")
+				return false;
+
+			string? request_id = discovery_message.get_element (1).get_string ();
+			string? command = discovery_message.get_element (2).get_string ();
+
+			// Handle discovery request (acting as server)
+			if (command == "get_protocol_info") {
+				var response_payload = new Json.Builder ();
+				response_payload
+					.begin_object ()
+					.set_member_name ("protocol_id")
+					.add_string_value (Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (null))
+					.set_member_name ("call_command")
+					.add_string_value (Frida.FridMiraRpcProtocolEnhancer.get_call_command (null))
+					.set_member_name ("ok_response")
+					.add_string_value (Frida.FridMiraRpcProtocolEnhancer.get_ok_response (null))
+					.end_object ();
+
+				var response_message = new Json.Builder ();
+				response_message
+					.begin_array ()
+					.add_string_value ("fridmira:discover")
+					.add_string_value (request_id)
+					.add_string_value ("ok")
+					.add_value (response_payload.get_root ())
+					.end_array ();
+
+				var full_response = new Json.Builder ();
+				full_response
+					.begin_object ()
+					.set_member_name ("type")
+					.add_string_value ("send")
+					.set_member_name ("payload")
+					.add_value (response_message.get_root ())
+					.end_object ();
+
+				try {
+					peer.post_rpc_message.begin (Json.to_string (full_response.get_root (), false), null, null);
+				} catch (Error e) {
+					warning ("FridMira: Failed to send discovery response: %s", e.message);
+				}
+
+				return true;
+			}
+			// Handle discovery response (acting as client)
+			else if (command == "ok") {
+				PendingResponse pending;
+				if (pending_discoveries.unset (request_id, out pending)) {
+					if (discovery_message.get_length () >= 4)
+						pending.complete_with_result (discovery_message.get_element (3));
+					else
+						pending.complete_with_error (new Error.INVALID_ARGUMENT ("Malformed discovery response"));
+				}
+				return true;
+			}
+
+			return false;
+		}
+
+		public async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError {
+			string request_id = Uuid.string_random ();
+
+			var discovery_request = new Json.Builder ();
+			discovery_request
+				.begin_array ()
+				.add_string_value ("fridmira:discover")
+				.add_string_value (request_id)
+				.add_string_value ("get_protocol_info")
+				.end_array ();
+
+			var full_request = new Json.Builder ();
+			full_request
+				.begin_object ()
+				.set_member_name ("type")
+				.add_string_value ("send")
+				.set_member_name ("payload")
+				.add_value (discovery_request.get_root ())
+				.end_object ();
+			string raw_request = Json.to_string (full_request.get_root (), false);
+
+			bool waiting = false;
+
+			var pending = new PendingResponse (() => {
+				if (waiting)
+					discover_protocol.callback ();
+				return false;
+			});
+			pending_discoveries[request_id] = pending;
+
+			try {
+				yield peer.post_rpc_message (raw_request, null, cancellable);
+			} catch (Error e) {
+				if (pending_discoveries.unset (request_id))
+					pending.complete_with_error (e);
+			}
+
+			if (!pending.completed) {
+				var cancel_source = new CancellableSource (cancellable);
+				cancel_source.set_callback (() => {
+					if (pending_discoveries.unset (request_id))
+						pending.complete_with_error (new IOError.CANCELLED ("Operation was cancelled"));
+					return false;
+				});
+				cancel_source.attach (MainContext.get_thread_default ());
+
+				waiting = true;
+				yield;
+				waiting = false;
+
+				cancel_source.destroy ();
+			}
+
+			cancellable.set_error_if_cancelled ();
+
+			if (pending.error != null)
+				throw_api_error (pending.error);
+
+			return pending.result;
+		}
+
+		private class PendingResponse {
+			private SourceFunc? handler;
+
+			public bool completed {
+				get {
+					return result != null || error != null;
+				}
+			}
+
+			public Json.Node? result {
+				get;
+				private set;
+			}
+
+			public GLib.Error? error {
+				get;
+				private set;
+			}
+
+			public PendingResponse (owned SourceFunc handler) {
+				this.handler = (owned) handler;
+			}
+
+			public void complete_with_result (Json.Node result) {
+				this.result = result;
+				handler ();
+				handler = null;
+			}
+
+			public void complete_with_error (GLib.Error error) {
+				this.error = error;
+				handler ();
+				handler = null;
+			}
+		}
+	}
+}
-- 
2.45.1.windows.1


From 0a1654e21966aa0dea3607763aab2d28a1f273fe Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 16:47:35 +0800
Subject: [PATCH 006/006] FridMira RPC Protocol Module

---
 lib/base/rpc.vala | 575 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 564 insertions(+), 11 deletions(-)

diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index c4654527..e368bfaf 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -1,17 +1,323 @@
+/*
+ * FRIDMIRA ENHANCED RPC MODULE / FRIDMIRA增强RPC模块
+ *
+ * This module provides enhanced RPC communication capabilities with FridMira
+ * anti-detection support. Key features include:
+ *
+ * 此模块提供增强的RPC通信能力，支持FridMira反检测功能。主要特性包括：
+ *
+ * - Dynamic Protocol Support / 动态协议支持:
+ *   Supports both standard "frida:rpc" and FridMira dynamic protocols
+ *   支持标准"frida:rpc"和FridMira动态协议
+ *
+ * - Protocol Discovery / 协议发现:
+ *   Automatic discovery of server's dynamic protocol parameters
+ *   自动发现服务器的动态协议参数
+ *
+ * - Session Management / 会话管理:
+ *   Per-session protocol tracking and memory management
+ *   按会话协议跟踪和内存管理
+ *
+ * - Anti-Detection / 反检测:
+ *   Breaks static protocol fingerprints for enhanced stealth
+ *   破坏静态协议指纹以增强隐蔽性
+ */
+
 namespace Frida {
+	/**
+	 * RPC Protocol Enhancer Interface / RPC协议增强器接口
+	 *
+	 * Defines the contract for modules that can enhance the RPC protocol,
+	 * for example by providing dynamic identifiers for anti-detection.
+	 *
+	 * 定义了可以增强RPC协议的模块的契约，例如通过提供动态标识符以实现反检测。
+	 */
+	public interface RpcProtocolEnhancer : Object {
+		public abstract string get_protocol_id (string? session_id);
+		public abstract string get_call_command (string? session_id);
+		public abstract string get_ok_response (string? session_id);
+		public abstract string get_dynamic_protocol_id ();
+		public abstract bool is_valid_protocol (string protocol);
+		public abstract bool is_valid_ok_response (string status);
+		public abstract void forget_session (string session_id);
+		public abstract bool try_handle_message (string json, RpcPeer peer);
+		public abstract async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError;
+	}
+
+	/**
+	 * Enhanced RPC Client with FridMira Anti-Detection Support
+	 * 支持FridMira反检测的增强RPC客户端
+	 *
+	 * This enhanced RPC client extends the standard Frida RPC capabilities with:
+	 * - Dynamic protocol support for stealth operations
+	 * - Protocol discovery capabilities for automatic configuration
+	 * - Session-specific protocol tracking
+	 * - Pluggable enhancer architecture
+	 *
+	 * 此增强RPC客户端扩展了标准Frida RPC功能，包括：
+	 * - 用于隐蔽操作的动态协议支持
+	 * - 用于自动配置的协议发现功能
+	 * - 特定于会话的协议跟踪
+	 * - 可插拔增强器架构
+	 *
+	 * Usage example / 使用示例:
+	 * ```
+	 * var client = new RpcClient(peer);
+	 * RpcClient.enhancer = new FridMiraRpcEnhancerAdapter();
+	 * var protocol_info = yield client.discover_protocol(cancellable);
+	 * var result = yield client.call("method_name", args, data, cancellable);
+	 * ```
+	 *
+	 * The client automatically handles session cleanup and protocol memory management
+	 * via the enhancer when the session ends.
+	 *
+	 * 客户端在会话结束时通过增强器自动处理会话清理和协议内存管理。
+	 */
 	public sealed class RpcClient : Object {
+		/**
+		 * Pluggable RPC protocol enhancer / 可插拔的RPC协议增强器
+		 *
+		 * This "slot" allows an external module (like FridMira) to provide
+		 * enhanced RPC capabilities at runtime. If null, standard RPC behavior
+		 * is used.
+		 *
+		 * 这个"插槽"允许外部模块（如FridMira）在运行时提供增强的RPC能力。
+		 * 如果为null，则使用标准RPC行为。
+		 */
+		public static RpcProtocolEnhancer? enhancer = null;
+
 		public weak RpcPeer peer {
 			get;
 			construct;
 		}
 
+		/**
+		 * Session identifier for protocol tracking / 用于协议跟踪的会话标识符
+		 *
+		 * Each RPC client instance maintains its own session ID for protocol
+		 * tracking and memory management in the enhancer.
+		 *
+		 * 每个RPC客户端实例在增强器中维护自己的会话ID以进行协议跟踪和内存管理。
+		 */
+		private string _session_id;
+
+		/**
+		 * Public accessor for session ID / 会话ID的公共访问器
+		 *
+		 * Allows external components to access the session ID for protocol
+		 * parameter retrieval and other session-specific operations.
+		 *
+		 * 允许外部组件访问会话ID以进行协议参数检索和其他特定于会话的操作。
+		 */
+		public string session_id {
+			get { return _session_id; }
+		}
+
 		private Gee.HashMap<string, PendingResponse> pending_responses = new Gee.HashMap<string, PendingResponse> ();
 
 		public RpcClient (RpcPeer peer) {
 			Object (peer: peer);
+			_session_id = Uuid.string_random ();
+		}
+
+		/**
+		 * Destructor: Clean up FridMira session resources / 析构函数：清理FridMira会话资源
+		 *
+		 * Automatically cleans up session-specific protocol memory in the
+		 * enhancer when this RPC client instance is destroyed.
+		 *
+		 * 当此RPC客户端实例被销毁时，自动清理增强器中特定于会话的协议内存。
+		 *
+		 * This ensures no memory leaks from dynamic protocol tracking.
+		 * 这确保动态协议跟踪不会产生内存泄漏。
+		 */
+		~RpcClient() {
+			// Clean up session protocol memory in the enhancer, if one is plugged in
+			// 如果有增强器插件，则在增强器中清理会话协议内存
+			if (enhancer != null) {
+				enhancer.forget_session (_session_id);
+			}
+		}
+
+		/**
+		 * FridMira Protocol Discovery API / FridMira协议发现API
+		 *
+		 * Discovers the server's dynamic protocol parameters for enhanced stealth.
+		 * This allows the client to automatically adapt to the server's current
+		 * anti-detection configuration.
+		 *
+		 * 发现服务器的动态协议参数以增强隐蔽性。这允许客户端自动适应服务器当前的反检测配置。
+		 *
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON object containing protocol configuration / 包含协议配置的JSON对象
+		 * @throws Error Communication or protocol errors / 通信或协议错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
+		public async Json.Node discover_protocol(Cancellable? cancellable) throws Error, IOError {
+			// Delegate protocol discovery to the enhancer
+			// 将协议发现委托给增强器
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery is not available without a protocol enhancer");
+			}
+			return yield enhancer.discover_protocol (peer, cancellable);
 		}
 
+		/**
+		 * Enhanced RPC Call with FridMira Protocol Support / 支持FridMira协议的增强RPC调用
+		 *
+		 * Performs an RPC call using either standard or enhanced protocols depending
+		 * on the configured enhancer. When an enhancer is present, dynamic protocol
+		 * identifiers are used for anti-detection purposes.
+		 *
+		 * 根据配置的增强器使用标准或增强协议执行RPC调用。当存在增强器时，动态协议标识符用于反检测目的。
+		 *
+		 * @param method The RPC method name to call / 要调用的RPC方法名
+		 * @param args Array of arguments for the method / 方法的参数数组
+		 * @param data Optional binary data to send / 要发送的可选二进制数据
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON response from the server / 来自服务器的JSON响应
+		 * @throws Error RPC execution errors / RPC执行错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
 		public async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: Add detailed protocol selection debugging
+			// FridMira 调试：添加详细的协议选择调试信息
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: RpcClient.call - Method: %s\n", method);
+				stderr.printf ("FridMira: DEBUG: RpcClient.call - Enhancer present: %s\n", (enhancer != null) ? "YES" : "NO");
+			}
+
+			// Smart protocol selection: Try enhanced protocol first, fallback to standard
+			// 智能协议选择：首先尝试增强协议，失败时回退到标准协议
+			if (enhancer != null && should_use_enhanced_protocol()) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: RpcClient.call - Using enhanced protocol path\n");
+				}
+				try {
+					return yield call_with_enhanced_protocol (method, args, data, cancellable);
+				} catch (Error e) {
+					if (verbose) {
+						stderr.printf ("FridMira: DEBUG: RpcClient.call - Enhanced protocol failed: %s\n", e.message);
+					}
+					// Enhanced protocol failed, try protocol discovery
+					// 增强协议失败，尝试协议发现
+					if (e is IOError.TIMED_OUT || e is IOError.CONNECTION_REFUSED) {
+						try {
+							yield discover_and_negotiate_protocol (cancellable);
+							return yield call_with_enhanced_protocol (method, args, data, cancellable);
+						} catch (Error discovery_error) {
+							// Protocol discovery failed, fallback to standard protocol
+							// 协议发现失败，回退到标准协议
+							if (verbose) {
+								stderr.printf ("FridMira: DEBUG: RpcClient.call - Protocol discovery failed (%s), falling back to standard protocol\n", discovery_error.message);
+							}
+						}
+					}
+				}
+			} else {
+				if (verbose) {
+					bool should_use = should_use_enhanced_protocol();
+					stderr.printf ("FridMira: DEBUG: RpcClient.call - Using standard protocol path (enhancer: %s, should_use_enhanced: %s)\n",
+						(enhancer != null) ? "YES" : "NO", should_use ? "YES" : "NO");
+				}
+			}
+
+			// Use standard protocol as fallback
+			// 使用标准协议作为回退
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: RpcClient.call - Falling back to standard protocol\n");
+			}
+			return yield call_with_standard_protocol (method, args, data, cancellable);
+		}
+
+		/**
+		 * Determine if enhanced protocol should be used
+		 * 确定是否应该使用增强协议
+		 */
+		private bool should_use_enhanced_protocol() {
+			// Check environment variable to enable enhanced mode
+			// 检查环境变量以启用增强模式
+			string? fridmira_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+
+			// Enhanced mode is enabled if either variable is set to "1"
+			// 如果任一变量设置为"1"，则启用增强模式
+			return (fridmira_mode == "1") || (rpc_mode == "1");
+		}
+
+		/**
+		 * Discover and negotiate protocol with server
+		 * 与服务器发现和协商协议
+		 */
+		private async void discover_and_negotiate_protocol (Cancellable? cancellable) throws Error, IOError {
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery requires an enhancer");
+			}
+
+			try {
+				var protocol_info = yield enhancer.discover_protocol (peer, cancellable);
+				// Protocol information is automatically cached by the enhancer
+				// 协议信息由增强器自动缓存
+			} catch (Error e) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery failed: %s".printf(e.message));
+			}
+		}
+
+		/**
+		 * Make RPC call using enhanced protocol
+		 * 使用增强协议进行RPC调用
+		 */
+		private async Json.Node call_with_enhanced_protocol (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: Add detailed enhanced protocol debugging
+			// FridMira 调试：添加详细的增强协议调试信息
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			string request_id = Uuid.string_random ();
+
+			// Use global enhanced protocol identifiers (same as InternalAgent)
+			// 使用全局增强协议标识符（与InternalAgent相同）
+			// Use null session_id to get the same global protocol as InternalAgent
+			// 使用null session_id获取与InternalAgent相同的全局协议
+			string protocol_id = enhancer.get_protocol_id (null);
+			string call_command = enhancer.get_call_command (null);
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Protocol ID: %s\n", protocol_id);
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Call command: %s\n", call_command);
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Request ID: %s\n", request_id);
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Method: %s\n", method);
+			}
+
+			var request = new Json.Builder ();
+			request
+				.begin_array ()
+				.add_string_value (protocol_id)
+				.add_string_value (request_id)
+				.add_string_value (call_command)
+				.add_string_value (method)
+				.begin_array ();
+			foreach (var arg in args)
+				request.add_value (arg);
+			request
+				.end_array ()
+				.end_array ();
+			string raw_request = Json.to_string (request.get_root (), false);
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Raw request: %s\n", raw_request);
+				stderr.printf ("FridMira: DEBUG: call_with_enhanced_protocol - Calling execute_rpc_request\n");
+			}
+
+			return yield execute_rpc_request (raw_request, request_id, data, cancellable);
+		}
+
+		/**
+		 * Make RPC call using standard protocol
+		 * 使用标准协议进行RPC调用
+		 */
+		private async Json.Node call_with_standard_protocol (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
 			string request_id = Uuid.string_random ();
 
 			var request = new Json.Builder ();
@@ -29,25 +335,60 @@ namespace Frida {
 				.end_array ();
 			string raw_request = Json.to_string (request.get_root (), false);
 
+			return yield execute_rpc_request (raw_request, request_id, data, cancellable);
+		}
+
+		/**
+		 * Execute RPC request and handle response
+		 * 执行RPC请求并处理响应
+		 */
+		private async Json.Node execute_rpc_request (string raw_request, string request_id, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: Add detailed request execution debugging
+			// FridMira 调试：添加详细的请求执行调试信息
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: execute_rpc_request - Starting execution\n");
+				stderr.printf ("FridMira: DEBUG: execute_rpc_request - Request ID: %s\n", request_id);
+			}
+
 			bool waiting = false;
 
 			var pending = new PendingResponse (() => {
 				if (waiting)
-					call.callback ();
+					execute_rpc_request.callback ();
 				return false;
 			});
 			pending_responses[request_id] = pending;
 
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: execute_rpc_request - Pending response registered\n");
+				stderr.printf ("FridMira: DEBUG: execute_rpc_request - Calling peer.post_rpc_message\n");
+			}
+
 			try {
 				yield peer.post_rpc_message (raw_request, data, cancellable);
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: execute_rpc_request - Message posted successfully\n");
+				}
 			} catch (Error e) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: execute_rpc_request - Error posting message: %s\n", e.message);
+				}
 				if (pending_responses.unset (request_id))
 					pending.complete_with_error (e);
 			}
 
 			if (!pending.completed) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: execute_rpc_request - Waiting for response\n");
+				}
+
 				var cancel_source = new CancellableSource (cancellable);
 				cancel_source.set_callback (() => {
+					if (verbose) {
+						stderr.printf ("FridMira: DEBUG: execute_rpc_request - Operation cancelled\n");
+					}
 					if (pending_responses.unset (request_id))
 						pending.complete_with_error (new IOError.CANCELLED ("Operation was cancelled"));
 					return false;
@@ -59,24 +400,115 @@ namespace Frida {
 				waiting = false;
 
 				cancel_source.destroy ();
+
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: execute_rpc_request - Response received or timeout\n");
+				}
 			}
 
 			cancellable.set_error_if_cancelled ();
 
-			if (pending.error != null)
+			if (pending.error != null) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: execute_rpc_request - Completed with error: %s\n", pending.error.message);
+				}
 				throw_api_error (pending.error);
+			}
 
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: execute_rpc_request - Completed successfully\n");
+			}
 			return pending.result;
 		}
 
+		/**
+		 * Enhanced Message Handler with FridMira Discovery Support / 支持FridMira发现的增强消息处理器
+		 *
+		 * Handles incoming JSON messages with support for both standard RPC responses
+		 * and FridMira protocol discovery messages.
+		 *
+		 * 处理传入的JSON消息，支持标准RPC响应和FridMira协议发现消息。
+		 *
+		 * @param json The JSON message string to process / 要处理的JSON消息字符串
+		 * @return true if message was handled, false otherwise / 如果消息被处理返回true，否则false
+		 */
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			// FridMira DEBUG: Add detailed message handling debugging
+			// FridMira 调试：添加详细的消息处理调试信息
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_message - Received message: %s\n", json);
+			}
+
+			// Give the enhancer a chance to handle the message first (e.g., for discovery)
+			// 首先给增强器一个处理消息的机会（例如，用于发现）
+			if (enhancer != null && enhancer.try_handle_message (json, peer)) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - Message handled by enhancer\n");
+				}
+				return true;
+			}
+
+			// Dual protocol support check
+			// 双协议支持检查
+			bool has_standard = json.index_of ("\"frida:rpc\"") != -1;
+			bool has_dynamic = false;
+
+			// Check if message contains dynamic protocol identifier, if enhancer is present
+			// 如果存在增强器，检查消息是否包含动态协议标识符
+			if (enhancer != null) {
+				// Parse the message to extract protocol ID and check if it's valid
+				// 解析消息以提取协议ID并检查其是否有效
+				try {
+					var parser = new Json.Parser ();
+					parser.load_from_data (json);
+					var message = parser.get_root ().get_object ();
+
+					if (message.has_member ("payload")) {
+						var payload = message.get_member ("payload");
+						if (payload.get_node_type () == Json.NodeType.ARRAY) {
+							var payload_array = payload.get_array ();
+							if (payload_array.get_length () > 0) {
+								var first_element = payload_array.get_element (0);
+								if (first_element.get_value_type () == typeof (string)) {
+									string protocol_id = first_element.get_string ();
+									has_dynamic = enhancer.is_valid_protocol (protocol_id);
+									if (verbose && has_dynamic) {
+										stderr.printf ("FridMira: DEBUG: try_handle_message - Found valid dynamic protocol: %s\n", protocol_id);
+									}
+								}
+							}
+						}
+					}
+				} catch (GLib.Error e) {
+					if (verbose) {
+						stderr.printf ("FridMira: DEBUG: try_handle_message - Error parsing message for protocol check: %s\n", e.message);
+					}
+				}
+			}
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_message - Protocol check - standard: %s, dynamic: %s\n",
+					has_standard ? "YES" : "NO", has_dynamic ? "YES" : "NO");
+			}
+
+			// Reject messages that don't match any supported protocol
+			// 拒绝不匹配任何支持协议的消息
+			if (!has_standard && !has_dynamic) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - No supported protocol found, rejecting message\n");
+				}
 				return false;
+			}
 
 			var parser = new Json.Parser ();
 			try {
 				parser.load_from_data (json);
 			} catch (GLib.Error e) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - JSON parsing failed: %s\n", e.message);
+				}
 				assert_not_reached ();
 			}
 			var message = parser.get_root ().get_object ();
@@ -84,38 +516,159 @@ namespace Frida {
 			bool handled = false;
 
 			var type = message.get_string_member ("type");
-			if (type == "send")
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_message - Message type: %s\n", type);
+			}
+
+			if (type == "send") {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - Processing 'send' type message\n");
+				}
 				handled = try_handle_rpc_message (message);
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - RPC message handled: %s\n", handled ? "YES" : "NO");
+				}
+			} else {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_message - Ignoring non-send message type: %s\n", type);
+				}
+			}
 
 			return handled;
 		}
 
+		/**
+		 * Enhanced RPC Message Handler with Protocol Validation / 带协议验证的增强RPC消息处理器
+		 *
+		 * Process RPC response messages with support for both standard and dynamic protocols
+		 * as well as enhanced status validation via the pluggable enhancer.
+		 *
+		 * 处理RPC响应消息，支持标准和动态协议，以及通过可插拔增强器进行增强状态验证。
+		 */
 		private bool try_handle_rpc_message (Json.Object message) {
+			// FridMira DEBUG: Add detailed RPC message handling debugging
+			// FridMira 调试：添加详细的RPC消息处理调试信息
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Starting message processing\n");
+			}
+
 			var payload = message.get_member ("payload");
-			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY)
+			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Invalid payload format\n");
+				}
 				return false;
+			}
 			var rpc_message = payload.get_array ();
-			if (rpc_message.get_length () < 4)
+			if (rpc_message.get_length () < 4) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Message too short: %u elements\n", rpc_message.get_length ());
+				}
 				return false;
+			}
 
+			// Extract protocol type from first element
+			// 从第一个元素提取协议类型
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - No protocol type found\n");
+				}
+				return false;
+			}
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Protocol type: %s\n", type);
+			}
+
+			// Enhanced protocol validation: Support both standard and dynamic protocols via enhancer
+			// 增强协议验证：通过增强器支持标准和动态协议
+			bool is_valid_protocol = false;
+			if (type == "frida:rpc") {
+				is_valid_protocol = true;
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Standard protocol validated\n");
+				}
+			} else if (enhancer != null && enhancer.is_valid_protocol (type)) {
+				is_valid_protocol = true;
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Enhanced protocol validated\n");
+				}
+			} else {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Protocol validation failed (enhancer: %s)\n",
+						(enhancer != null) ? "present" : "null");
+				}
+			}
+
+			// Reject messages with unsupported protocol
+			// 拒绝使用不支持协议的消息
+			if (!is_valid_protocol) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Rejecting unsupported protocol: %s\n", type);
+				}
 				return false;
+			}
 
 			var request_id_value = rpc_message.get_element (1);
-			if (request_id_value.get_value_type () != typeof (string))
+			if (request_id_value.get_value_type () != typeof (string)) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Invalid request ID type\n");
+				}
 				return false;
+			}
 			string request_id = request_id_value.get_string ();
 
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Request ID: %s\n", request_id);
+			}
+
 			PendingResponse response;
-			if (!pending_responses.unset (request_id, out response))
+			if (!pending_responses.unset (request_id, out response)) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - No pending response found for request ID: %s\n", request_id);
+				}
 				return false;
+			}
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Found pending response for request ID: %s\n", request_id);
+			}
 
+			// Extract response status with enhanced validation
+			// 提取响应状态并进行增强验证
 			var status = rpc_message.get_string_element (2);
-			if (status == "ok")
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Response status: %s\n", status);
+			}
+
+			// Enhanced status validation: Support standard "ok" and dynamic OK responses via enhancer
+			// 增强状态验证：通过增强器支持标准"ok"和动态OK响应
+			bool is_success = (status == "ok") || (enhancer != null && enhancer.is_valid_ok_response (status));
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Status validation result: %s\n", is_success ? "SUCCESS" : "ERROR");
+			}
+
+			// Complete the pending response based on status
+			// 根据状态完成待处理响应
+			if (is_success) {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Completing with success result\n");
+				}
 				response.complete_with_result (rpc_message.get_element (3));
-			else
+			} else {
+				if (verbose) {
+					stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Completing with error: %s\n", rpc_message.get_string_element (3));
+				}
 				response.complete_with_error (new Error.NOT_SUPPORTED (rpc_message.get_string_element (3)));
+			}
+
+			if (verbose) {
+				stderr.printf ("FridMira: DEBUG: try_handle_rpc_message - Message processing completed successfully\n");
+			}
 
 			return true;
 		}
-- 
2.45.1.windows.1


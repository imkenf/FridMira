From 2d32c21563aeff4e560eea55ec707bd4c12c016c Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 16:47:35 +0800
Subject: [PATCH 006/006] FridMira RPC Protocol Module

---
 lib/base/rpc.vala | 284 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 278 insertions(+), 6 deletions(-)

diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index c4654527..c339c437 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -1,25 +1,220 @@
+/*
+ * FRIDMIRA ENHANCED RPC MODULE / FRIDMIRA增强RPC模块
+ *
+ * This module provides enhanced RPC communication capabilities with FridMira
+ * anti-detection support. Key features include:
+ *
+ * 此模块提供增强的RPC通信能力，支持FridMira反检测功能。主要特性包括：
+ *
+ * - Dynamic Protocol Support / 动态协议支持:
+ *   Supports both standard "frida:rpc" and FridMira dynamic protocols
+ *   支持标准"frida:rpc"和FridMira动态协议
+ *
+ * - Protocol Discovery / 协议发现:
+ *   Automatic discovery of server's dynamic protocol parameters
+ *   自动发现服务器的动态协议参数
+ *
+ * - Session Management / 会话管理:
+ *   Per-session protocol tracking and memory management
+ *   按会话协议跟踪和内存管理
+ *
+ * - Anti-Detection / 反检测:
+ *   Breaks static protocol fingerprints for enhanced stealth
+ *   破坏静态协议指纹以增强隐蔽性
+ */
+
 namespace Frida {
+	/**
+	 * RPC Protocol Enhancer Interface / RPC协议增强器接口
+	 *
+	 * Defines the contract for modules that can enhance the RPC protocol,
+	 * for example by providing dynamic identifiers for anti-detection.
+	 *
+	 * 定义了可以增强RPC协议的模块的契约，例如通过提供动态标识符以实现反检测。
+	 */
+	public interface RpcProtocolEnhancer : Object {
+		public abstract string get_protocol_id (string? session_id);
+		public abstract string get_call_command (string? session_id);
+		public abstract string get_ok_response (string? session_id);
+		public abstract string get_dynamic_protocol_id ();
+		public abstract bool is_valid_protocol (string protocol);
+		public abstract bool is_valid_ok_response (string status);
+		public abstract void forget_session (string session_id);
+		public abstract bool try_handle_message (string json, RpcPeer peer);
+		public abstract async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError;
+	}
+
+	/**
+	 * Enhanced RPC Client with FridMira Anti-Detection Support
+	 * 支持FridMira反检测的增强RPC客户端
+	 *
+	 * This enhanced RPC client extends the standard Frida RPC capabilities with:
+	 * - Dynamic protocol support for stealth operations
+	 * - Protocol discovery capabilities for automatic configuration
+	 * - Session-specific protocol tracking
+	 * - Pluggable enhancer architecture
+	 *
+	 * 此增强RPC客户端扩展了标准Frida RPC功能，包括：
+	 * - 用于隐蔽操作的动态协议支持
+	 * - 用于自动配置的协议发现功能
+	 * - 特定于会话的协议跟踪
+	 * - 可插拔增强器架构
+	 *
+	 * Usage example / 使用示例:
+	 * ```
+	 * var client = new RpcClient(peer);
+	 * RpcClient.enhancer = new FridMiraRpcEnhancerAdapter();
+	 * var protocol_info = yield client.discover_protocol(cancellable);
+	 * var result = yield client.call("method_name", args, data, cancellable);
+	 * ```
+	 *
+	 * The client automatically handles session cleanup and protocol memory management
+	 * via the enhancer when the session ends.
+	 *
+	 * 客户端在会话结束时通过增强器自动处理会话清理和协议内存管理。
+	 */
 	public sealed class RpcClient : Object {
+		/**
+		 * Pluggable RPC protocol enhancer / 可插拔的RPC协议增强器
+		 *
+		 * This "slot" allows an external module (like FridMira) to provide
+		 * enhanced RPC capabilities at runtime. If null, standard RPC behavior
+		 * is used.
+		 *
+		 * 这个"插槽"允许外部模块（如FridMira）在运行时提供增强的RPC能力。
+		 * 如果为null，则使用标准RPC行为。
+		 */
+		public static RpcProtocolEnhancer? enhancer = null;
+
 		public weak RpcPeer peer {
 			get;
 			construct;
 		}
 
+		/**
+		 * Session identifier for protocol tracking / 用于协议跟踪的会话标识符
+		 *
+		 * Each RPC client instance maintains its own session ID for protocol
+		 * tracking and memory management in the enhancer.
+		 *
+		 * 每个RPC客户端实例在增强器中维护自己的会话ID以进行协议跟踪和内存管理。
+		 */
+		private string _session_id;
+
 		private Gee.HashMap<string, PendingResponse> pending_responses = new Gee.HashMap<string, PendingResponse> ();
 
 		public RpcClient (RpcPeer peer) {
 			Object (peer: peer);
+			_session_id = Uuid.string_random ();
+		}
+
+		/**
+		 * Destructor: Clean up FridMira session resources / 析构函数：清理FridMira会话资源
+		 *
+		 * Automatically cleans up session-specific protocol memory in the
+		 * enhancer when this RPC client instance is destroyed.
+		 *
+		 * 当此RPC客户端实例被销毁时，自动清理增强器中特定于会话的协议内存。
+		 *
+		 * This ensures no memory leaks from dynamic protocol tracking.
+		 * 这确保动态协议跟踪不会产生内存泄漏。
+		 */
+		~RpcClient() {
+			// Clean up session protocol memory in the enhancer, if one is plugged in
+			// 如果有增强器插件，则在增强器中清理会话协议内存
+			if (enhancer != null) {
+				enhancer.forget_session (_session_id);
+			}
 		}
 
+		/**
+		 * FridMira Protocol Discovery API / FridMira协议发现API
+		 *
+		 * Discovers the server's dynamic protocol parameters for enhanced stealth.
+		 * This allows the client to automatically adapt to the server's current
+		 * anti-detection configuration.
+		 *
+		 * 发现服务器的动态协议参数以增强隐蔽性。这允许客户端自动适应服务器当前的反检测配置。
+		 *
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON object containing protocol configuration / 包含协议配置的JSON对象
+		 * @throws Error Communication or protocol errors / 通信或协议错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
+		public async Json.Node discover_protocol(Cancellable? cancellable) throws Error, IOError {
+			// Delegate protocol discovery to the enhancer
+			// 将协议发现委托给增强器
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery is not available without a protocol enhancer");
+			}
+			return yield enhancer.discover_protocol (peer, cancellable);
+		}
+
+		/**
+		 * Enhanced RPC Call with FridMira Protocol Support and Fallback / 支持FridMira协议和回退的增强RPC调用
+		 *
+		 * Performs an RPC call with intelligent protocol selection:
+		 * 1. Try enhanced protocol first (if enhancer is available and enabled)
+		 * 2. Automatically fallback to standard protocol if enhanced fails
+		 * 3. Support both protocols for maximum compatibility
+		 *
+		 * 执行具有智能协议选择的RPC调用：
+		 * 1. 首先尝试增强协议（如果增强器可用且启用）
+		 * 2. 如果增强协议失败，自动回退到标准协议
+		 * 3. 支持两种协议以实现最大兼容性
+		 *
+		 * @param method The RPC method name to call / 要调用的RPC方法名
+		 * @param args Array of arguments for the method / 方法的参数数组
+		 * @param data Optional binary data to send / 要发送的可选二进制数据
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON response from the server / 来自服务器的JSON响应
+		 * @throws Error RPC execution errors / RPC执行错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
 		public async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			// Try enhanced protocol first, then fallback to standard if needed
+			// 首先尝试增强协议，如果需要则回退到标准协议
+			if (enhancer != null) {
+				try {
+					return yield call_with_protocol (method, args, data, cancellable, true);
+				} catch (Error e) {
+					// Enhanced protocol failed, try standard protocol as fallback
+					// 增强协议失败，尝试标准协议作为回退
+					warning ("FridMira: Enhanced protocol failed (%s), falling back to standard protocol", e.message);
+					return yield call_with_protocol (method, args, data, cancellable, false);
+				}
+			} else {
+				// No enhancer available, use standard protocol
+				// 没有增强器可用，使用标准协议
+				return yield call_with_protocol (method, args, data, cancellable, false);
+			}
+		}
+
+		/**
+		 * Internal RPC call implementation with protocol selection
+		 * 带协议选择的内部RPC调用实现
+		 */
+		private async Json.Node call_with_protocol (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable, bool use_enhanced) throws Error, IOError {
 			string request_id = Uuid.string_random ();
 
+			// Select protocol based on use_enhanced flag
+			// 根据use_enhanced标志选择协议
+			string protocol_id, call_command;
+
+			if (use_enhanced && enhancer != null) {
+				protocol_id = enhancer.get_protocol_id (_session_id);
+				call_command = enhancer.get_call_command (_session_id);
+			} else {
+				protocol_id = "frida:rpc";
+				call_command = "call";
+			}
+
 			var request = new Json.Builder ();
 			request
 				.begin_array ()
-				.add_string_value ("frida:rpc")
+				.add_string_value (protocol_id)
 				.add_string_value (request_id)
-				.add_string_value ("call")
+				.add_string_value (call_command)
 				.add_string_value (method)
 				.begin_array ();
 			foreach (var arg in args)
@@ -33,7 +228,7 @@ namespace Frida {
 
 			var pending = new PendingResponse (() => {
 				if (waiting)
-					call.callback ();
+					call_with_protocol.callback ();
 				return false;
 			});
 			pending_responses[request_id] = pending;
@@ -43,9 +238,20 @@ namespace Frida {
 			} catch (Error e) {
 				if (pending_responses.unset (request_id))
 					pending.complete_with_error (e);
+				throw e; // Re-throw for fallback handling
 			}
 
 			if (!pending.completed) {
+				// Set up timeout for protocol detection
+				// 为协议检测设置超时
+				uint timeout_id = Timeout.add (5000, () => {
+					if (pending_responses.unset (request_id)) {
+						var timeout_error = new IOError.TIMED_OUT ("RPC call timed out - protocol may be incompatible");
+						pending.complete_with_error (timeout_error);
+					}
+					return false;
+				});
+
 				var cancel_source = new CancellableSource (cancellable);
 				cancel_source.set_callback (() => {
 					if (pending_responses.unset (request_id))
@@ -58,6 +264,7 @@ namespace Frida {
 				yield;
 				waiting = false;
 
+				Source.remove (timeout_id);
 				cancel_source.destroy ();
 			}
 
@@ -69,8 +276,41 @@ namespace Frida {
 			return pending.result;
 		}
 
+		/**
+		 * Enhanced Message Handler with FridMira Discovery Support / 支持FridMira发现的增强消息处理器
+		 *
+		 * Handles incoming JSON messages with support for both standard RPC responses
+		 * and FridMira protocol discovery messages.
+		 *
+		 * 处理传入的JSON消息，支持标准RPC响应和FridMira协议发现消息。
+		 *
+		 * @param json The JSON message string to process / 要处理的JSON消息字符串
+		 * @return true if message was handled, false otherwise / 如果消息被处理返回true，否则false
+		 */
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			// Give the enhancer a chance to handle the message first (e.g., for discovery)
+			// 首先给增强器一个处理消息的机会（例如，用于发现）
+			if (enhancer != null && enhancer.try_handle_message (json, peer)) {
+				return true;
+			}
+
+			// Dual protocol support check
+			// 双协议支持检查
+			bool has_standard = json.index_of ("\"frida:rpc\"") != -1;
+			bool has_dynamic = false;
+
+			// Check if message contains dynamic protocol identifier, if enhancer is present
+			// 如果存在增强器，检查消息是否包含动态协议标识符
+			if (enhancer != null) {
+				string dynamic_protocol = enhancer.get_dynamic_protocol_id ();
+				if (dynamic_protocol != "" && dynamic_protocol != "frida:rpc") {
+					has_dynamic = json.index_of ("\"" + dynamic_protocol + "\"") != -1;
+				}
+			}
+
+			// Reject messages that don't match any supported protocol
+			// 拒绝不匹配任何支持协议的消息
+			if (!has_standard && !has_dynamic)
 				return false;
 
 			var parser = new Json.Parser ();
@@ -90,6 +330,14 @@ namespace Frida {
 			return handled;
 		}
 
+		/**
+		 * Enhanced RPC Message Handler with Protocol Validation / 带协议验证的增强RPC消息处理器
+		 *
+		 * Process RPC response messages with support for both standard and dynamic protocols
+		 * as well as enhanced status validation via the pluggable enhancer.
+		 *
+		 * 处理RPC响应消息，支持标准和动态协议，以及通过可插拔增强器进行增强状态验证。
+		 */
 		private bool try_handle_rpc_message (Json.Object message) {
 			var payload = message.get_member ("payload");
 			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY)
@@ -98,8 +346,24 @@ namespace Frida {
 			if (rpc_message.get_length () < 4)
 				return false;
 
+			// Extract protocol type from first element
+			// 从第一个元素提取协议类型
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null)
+				return false;
+
+			// Enhanced protocol validation: Support both standard and dynamic protocols via enhancer
+			// 增强协议验证：通过增强器支持标准和动态协议
+			bool is_valid_protocol = false;
+			if (type == "frida:rpc") {
+				is_valid_protocol = true;
+			} else if (enhancer != null && enhancer.is_valid_protocol (type)) {
+				is_valid_protocol = true;
+			}
+
+			// Reject messages with unsupported protocol
+			// 拒绝使用不支持协议的消息
+			if (!is_valid_protocol)
 				return false;
 
 			var request_id_value = rpc_message.get_element (1);
@@ -111,8 +375,16 @@ namespace Frida {
 			if (!pending_responses.unset (request_id, out response))
 				return false;
 
+			// Extract response status with enhanced validation
+			// 提取响应状态并进行增强验证
 			var status = rpc_message.get_string_element (2);
-			if (status == "ok")
+			// Enhanced status validation: Support standard "ok" and dynamic OK responses via enhancer
+			// 增强状态验证：通过增强器支持标准"ok"和动态OK响应
+			bool is_success = (status == "ok") || (enhancer != null && enhancer.is_valid_ok_response (status));
+
+			// Complete the pending response based on status
+			// 根据状态完成待处理响应
+			if (is_success)
 				response.complete_with_result (rpc_message.get_element (3));
 			else
 				response.complete_with_error (new Error.NOT_SUPPORTED (rpc_message.get_string_element (3)));
-- 
2.45.1.windows.1


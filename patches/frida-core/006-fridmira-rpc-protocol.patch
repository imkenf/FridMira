From 25170adf6f3bf84020e8b01209da4f1c968b19ee Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 16:47:35 +0800
Subject: [PATCH 006/006] FridMira RPC Protocol Module

---
 lib/base/rpc.vala             | 331 +++++++++++++++++++++++++++++++++-
 lib/base/session.vala         |   7 +
 lib/gadget/gadget.vala        |  37 +++-
 src/host-session-service.vala |  41 +++++
 4 files changed, 408 insertions(+), 8 deletions(-)

diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index c4654527..2192bfc5 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -1,17 +1,267 @@
+/*
+ * FRIDMIRA ENHANCED RPC MODULE / FRIDMIRA增强RPC模块
+ *
+ * This module provides enhanced RPC communication capabilities with FridMira
+ * anti-detection support. Key features include:
+ *
+ * 此模块提供增强的RPC通信能力，支持FridMira反检测功能。主要特性包括：
+ *
+ * - Dynamic Protocol Support / 动态协议支持:
+ *   Supports both standard "frida:rpc" and FridMira dynamic protocols
+ *   支持标准"frida:rpc"和FridMira动态协议
+ *
+ * - Protocol Discovery / 协议发现:
+ *   Automatic discovery of server's dynamic protocol parameters
+ *   自动发现服务器的动态协议参数
+ *
+ * - Session Management / 会话管理:
+ *   Per-session protocol tracking and memory management
+ *   按会话协议跟踪和内存管理
+ *
+ * - Anti-Detection / 反检测:
+ *   Breaks static protocol fingerprints for enhanced stealth
+ *   破坏静态协议指纹以增强隐蔽性
+ */
+
 namespace Frida {
+	/**
+	 * RPC Protocol Enhancer Interface / RPC协议增强器接口
+	 *
+	 * Defines the contract for modules that can enhance the RPC protocol,
+	 * for example by providing dynamic identifiers for anti-detection.
+	 *
+	 * 定义了可以增强RPC协议的模块的契约，例如通过提供动态标识符以实现反检测。
+	 */
+	public interface RpcProtocolEnhancer : Object {
+		public abstract string get_protocol_id (string? session_id);
+		public abstract string get_call_command (string? session_id);
+		public abstract string get_ok_response (string? session_id);
+		public abstract string get_dynamic_protocol_id ();
+		public abstract bool is_valid_protocol (string protocol);
+		public abstract bool is_valid_ok_response (string status);
+		public abstract void forget_session (string session_id);
+		public abstract bool try_handle_message (string json, RpcPeer peer);
+		public abstract async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError;
+	}
+
+	/**
+	 * Enhanced RPC Client with FridMira Anti-Detection Support
+	 * 支持FridMira反检测的增强RPC客户端
+	 *
+	 * This enhanced RPC client extends the standard Frida RPC capabilities with:
+	 * - Dynamic protocol support for stealth operations
+	 * - Protocol discovery capabilities for automatic configuration
+	 * - Session-specific protocol tracking
+	 * - Pluggable enhancer architecture
+	 *
+	 * 此增强RPC客户端扩展了标准Frida RPC功能，包括：
+	 * - 用于隐蔽操作的动态协议支持
+	 * - 用于自动配置的协议发现功能
+	 * - 特定于会话的协议跟踪
+	 * - 可插拔增强器架构
+	 *
+	 * Usage example / 使用示例:
+	 * ```
+	 * var client = new RpcClient(peer);
+	 * RpcClient.enhancer = new FridMiraRpcEnhancerAdapter();
+	 * var protocol_info = yield client.discover_protocol(cancellable);
+	 * var result = yield client.call("method_name", args, data, cancellable);
+	 * ```
+	 *
+	 * The client automatically handles session cleanup and protocol memory management
+	 * via the enhancer when the session ends.
+	 *
+	 * 客户端在会话结束时通过增强器自动处理会话清理和协议内存管理。
+	 */
 	public sealed class RpcClient : Object {
+		/**
+		 * Pluggable RPC protocol enhancer / 可插拔的RPC协议增强器
+		 *
+		 * This "slot" allows an external module (like FridMira) to provide
+		 * enhanced RPC capabilities at runtime. If null, standard RPC behavior
+		 * is used.
+		 *
+		 * 这个"插槽"允许外部模块（如FridMira）在运行时提供增强的RPC能力。
+		 * 如果为null，则使用标准RPC行为。
+		 */
+		public static RpcProtocolEnhancer? enhancer = null;
+
 		public weak RpcPeer peer {
 			get;
 			construct;
 		}
 
+		/**
+		 * Session identifier for protocol tracking / 用于协议跟踪的会话标识符
+		 *
+		 * Each RPC client instance maintains its own session ID for protocol
+		 * tracking and memory management in the enhancer.
+		 *
+		 * 每个RPC客户端实例在增强器中维护自己的会话ID以进行协议跟踪和内存管理。
+		 */
+		private string _session_id;
+
 		private Gee.HashMap<string, PendingResponse> pending_responses = new Gee.HashMap<string, PendingResponse> ();
 
 		public RpcClient (RpcPeer peer) {
 			Object (peer: peer);
+			_session_id = Uuid.string_random ();
+		}
+
+		/**
+		 * Destructor: Clean up FridMira session resources / 析构函数：清理FridMira会话资源
+		 *
+		 * Automatically cleans up session-specific protocol memory in the
+		 * enhancer when this RPC client instance is destroyed.
+		 *
+		 * 当此RPC客户端实例被销毁时，自动清理增强器中特定于会话的协议内存。
+		 *
+		 * This ensures no memory leaks from dynamic protocol tracking.
+		 * 这确保动态协议跟踪不会产生内存泄漏。
+		 */
+		~RpcClient() {
+			// Clean up session protocol memory in the enhancer, if one is plugged in
+			// 如果有增强器插件，则在增强器中清理会话协议内存
+			if (enhancer != null) {
+				enhancer.forget_session (_session_id);
+			}
+		}
+
+		/**
+		 * FridMira Protocol Discovery API / FridMira协议发现API
+		 *
+		 * Discovers the server's dynamic protocol parameters for enhanced stealth.
+		 * This allows the client to automatically adapt to the server's current
+		 * anti-detection configuration.
+		 *
+		 * 发现服务器的动态协议参数以增强隐蔽性。这允许客户端自动适应服务器当前的反检测配置。
+		 *
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON object containing protocol configuration / 包含协议配置的JSON对象
+		 * @throws Error Communication or protocol errors / 通信或协议错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
+		public async Json.Node discover_protocol(Cancellable? cancellable) throws Error, IOError {
+			// Delegate protocol discovery to the enhancer
+			// 将协议发现委托给增强器
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery is not available without a protocol enhancer");
+			}
+			return yield enhancer.discover_protocol (peer, cancellable);
 		}
 
+		/**
+		 * Enhanced RPC Call with FridMira Protocol Support / 支持FridMira协议的增强RPC调用
+		 *
+		 * Performs an RPC call using either standard or enhanced protocols depending
+		 * on the configured enhancer. When an enhancer is present, dynamic protocol
+		 * identifiers are used for anti-detection purposes.
+		 *
+		 * 根据配置的增强器使用标准或增强协议执行RPC调用。当存在增强器时，动态协议标识符用于反检测目的。
+		 *
+		 * @param method The RPC method name to call / 要调用的RPC方法名
+		 * @param args Array of arguments for the method / 方法的参数数组
+		 * @param data Optional binary data to send / 要发送的可选二进制数据
+		 * @param cancellable Optional cancellation token / 可选的取消令牌
+		 * @return JSON response from the server / 来自服务器的JSON响应
+		 * @throws Error RPC execution errors / RPC执行错误
+		 * @throws IOError IO operation errors / IO操作错误
+		 */
 		public async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			// Smart protocol selection: Try enhanced protocol first, fallback to standard
+			// 智能协议选择：首先尝试增强协议，失败时回退到标准协议
+			if (enhancer != null && should_use_enhanced_protocol()) {
+				try {
+					return yield call_with_enhanced_protocol (method, args, data, cancellable);
+				} catch (Error e) {
+					// Enhanced protocol failed, try protocol discovery
+					// 增强协议失败，尝试协议发现
+					if (e is IOError.TIMED_OUT || e is IOError.CONNECTION_REFUSED) {
+						try {
+							yield discover_and_negotiate_protocol (cancellable);
+							return yield call_with_enhanced_protocol (method, args, data, cancellable);
+						} catch (Error discovery_error) {
+							// Protocol discovery failed, fallback to standard protocol
+							// 协议发现失败，回退到标准协议
+							warning ("FridMira: Protocol discovery failed (%s), falling back to standard protocol", discovery_error.message);
+						}
+					}
+				}
+			}
+
+			// Use standard protocol as fallback
+			// 使用标准协议作为回退
+			return yield call_with_standard_protocol (method, args, data, cancellable);
+		}
+
+		/**
+		 * Determine if enhanced protocol should be used
+		 * 确定是否应该使用增强协议
+		 */
+		private bool should_use_enhanced_protocol() {
+			// Check environment variable to enable enhanced mode
+			// 检查环境变量以启用增强模式
+			string? fridmira_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+
+			// Enhanced mode is enabled if either variable is set to "1"
+			// 如果任一变量设置为"1"，则启用增强模式
+			return (fridmira_mode == "1") || (rpc_mode == "1");
+		}
+
+		/**
+		 * Discover and negotiate protocol with server
+		 * 与服务器发现和协商协议
+		 */
+		private async void discover_and_negotiate_protocol (Cancellable? cancellable) throws Error, IOError {
+			if (enhancer == null) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery requires an enhancer");
+			}
+
+			try {
+				var protocol_info = yield enhancer.discover_protocol (peer, cancellable);
+				// Protocol information is automatically cached by the enhancer
+				// 协议信息由增强器自动缓存
+			} catch (Error e) {
+				throw new Error.NOT_SUPPORTED ("Protocol discovery failed: %s".printf(e.message));
+			}
+		}
+
+		/**
+		 * Make RPC call using enhanced protocol
+		 * 使用增强协议进行RPC调用
+		 */
+		private async Json.Node call_with_enhanced_protocol (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
+			string request_id = Uuid.string_random ();
+
+			// Use session-specific enhanced protocol identifiers
+			// 使用特定于会话的增强协议标识符
+			string protocol_id = enhancer.get_protocol_id (_session_id);
+			string call_command = enhancer.get_call_command (_session_id);
+
+			var request = new Json.Builder ();
+			request
+				.begin_array ()
+				.add_string_value (protocol_id)
+				.add_string_value (request_id)
+				.add_string_value (call_command)
+				.add_string_value (method)
+				.begin_array ();
+			foreach (var arg in args)
+				request.add_value (arg);
+			request
+				.end_array ()
+				.end_array ();
+			string raw_request = Json.to_string (request.get_root (), false);
+
+			return yield execute_rpc_request (raw_request, request_id, data, cancellable);
+		}
+
+		/**
+		 * Make RPC call using standard protocol
+		 * 使用标准协议进行RPC调用
+		 */
+		private async Json.Node call_with_standard_protocol (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
 			string request_id = Uuid.string_random ();
 
 			var request = new Json.Builder ();
@@ -29,11 +279,19 @@ namespace Frida {
 				.end_array ();
 			string raw_request = Json.to_string (request.get_root (), false);
 
+			return yield execute_rpc_request (raw_request, request_id, data, cancellable);
+		}
+
+		/**
+		 * Execute RPC request and handle response
+		 * 执行RPC请求并处理响应
+		 */
+		private async Json.Node execute_rpc_request (string raw_request, string request_id, Bytes? data, Cancellable? cancellable) throws Error, IOError {
 			bool waiting = false;
 
 			var pending = new PendingResponse (() => {
 				if (waiting)
-					call.callback ();
+					execute_rpc_request.callback ();
 				return false;
 			});
 			pending_responses[request_id] = pending;
@@ -69,8 +327,41 @@ namespace Frida {
 			return pending.result;
 		}
 
+		/**
+		 * Enhanced Message Handler with FridMira Discovery Support / 支持FridMira发现的增强消息处理器
+		 *
+		 * Handles incoming JSON messages with support for both standard RPC responses
+		 * and FridMira protocol discovery messages.
+		 *
+		 * 处理传入的JSON消息，支持标准RPC响应和FridMira协议发现消息。
+		 *
+		 * @param json The JSON message string to process / 要处理的JSON消息字符串
+		 * @return true if message was handled, false otherwise / 如果消息被处理返回true，否则false
+		 */
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			// Give the enhancer a chance to handle the message first (e.g., for discovery)
+			// 首先给增强器一个处理消息的机会（例如，用于发现）
+			if (enhancer != null && enhancer.try_handle_message (json, peer)) {
+				return true;
+			}
+
+			// Dual protocol support check
+			// 双协议支持检查
+			bool has_standard = json.index_of ("\"frida:rpc\"") != -1;
+			bool has_dynamic = false;
+
+			// Check if message contains dynamic protocol identifier, if enhancer is present
+			// 如果存在增强器，检查消息是否包含动态协议标识符
+			if (enhancer != null) {
+				string dynamic_protocol = enhancer.get_dynamic_protocol_id ();
+				if (dynamic_protocol != "" && dynamic_protocol != "frida:rpc") {
+					has_dynamic = json.index_of ("\"" + dynamic_protocol + "\"") != -1;
+				}
+			}
+
+			// Reject messages that don't match any supported protocol
+			// 拒绝不匹配任何支持协议的消息
+			if (!has_standard && !has_dynamic)
 				return false;
 
 			var parser = new Json.Parser ();
@@ -90,6 +381,14 @@ namespace Frida {
 			return handled;
 		}
 
+		/**
+		 * Enhanced RPC Message Handler with Protocol Validation / 带协议验证的增强RPC消息处理器
+		 *
+		 * Process RPC response messages with support for both standard and dynamic protocols
+		 * as well as enhanced status validation via the pluggable enhancer.
+		 *
+		 * 处理RPC响应消息，支持标准和动态协议，以及通过可插拔增强器进行增强状态验证。
+		 */
 		private bool try_handle_rpc_message (Json.Object message) {
 			var payload = message.get_member ("payload");
 			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY)
@@ -98,8 +397,24 @@ namespace Frida {
 			if (rpc_message.get_length () < 4)
 				return false;
 
+			// Extract protocol type from first element
+			// 从第一个元素提取协议类型
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null)
+				return false;
+
+			// Enhanced protocol validation: Support both standard and dynamic protocols via enhancer
+			// 增强协议验证：通过增强器支持标准和动态协议
+			bool is_valid_protocol = false;
+			if (type == "frida:rpc") {
+				is_valid_protocol = true;
+			} else if (enhancer != null && enhancer.is_valid_protocol (type)) {
+				is_valid_protocol = true;
+			}
+
+			// Reject messages with unsupported protocol
+			// 拒绝使用不支持协议的消息
+			if (!is_valid_protocol)
 				return false;
 
 			var request_id_value = rpc_message.get_element (1);
@@ -111,8 +426,16 @@ namespace Frida {
 			if (!pending_responses.unset (request_id, out response))
 				return false;
 
+			// Extract response status with enhanced validation
+			// 提取响应状态并进行增强验证
 			var status = rpc_message.get_string_element (2);
-			if (status == "ok")
+			// Enhanced status validation: Support standard "ok" and dynamic OK responses via enhancer
+			// 增强状态验证：通过增强器支持标准"ok"和动态OK响应
+			bool is_success = (status == "ok") || (enhancer != null && enhancer.is_valid_ok_response (status));
+
+			// Complete the pending response based on status
+			// 根据状态完成待处理响应
+			if (is_success)
 				response.complete_with_result (rpc_message.get_element (3));
 			else
 				response.complete_with_error (new Error.NOT_SUPPORTED (rpc_message.get_string_element (3)));
diff --git a/lib/base/session.vala b/lib/base/session.vala
index 7e0d8944..9472c6f7 100644
--- a/lib/base/session.vala
+++ b/lib/base/session.vala
@@ -4,6 +4,8 @@ namespace Frida {
 		public abstract async void ping (uint interval_seconds, Cancellable? cancellable) throws GLib.Error;
 
 		public abstract async HashTable<string, Variant> query_system_parameters (Cancellable? cancellable) throws GLib.Error;
+		public abstract async HashTable<string, Variant> fridmira_negotiate_protocol (HashTable<string, Variant> client_params,
+			Cancellable? cancellable) throws GLib.Error;
 		public abstract async HostApplicationInfo get_frontmost_application (HashTable<string, Variant> options,
 			Cancellable? cancellable) throws GLib.Error;
 		public abstract async HostApplicationInfo[] enumerate_applications (HashTable<string, Variant> options,
@@ -906,6 +908,11 @@ namespace Frida {
 		public async ServiceSessionId open_service (string address, Cancellable? cancellable) throws Error, IOError {
 			throw_not_authorized ();
 		}
+
+		public async HashTable<string, Variant> fridmira_negotiate_protocol (HashTable<string, Variant> client_params,
+				Cancellable? cancellable) throws Error, IOError {
+			throw_not_authorized ();
+		}
 	}
 
 	public sealed class UnauthorizedPortalSession : Object, PortalSession {
diff --git a/lib/gadget/gadget.vala b/lib/gadget/gadget.vala
index ba492096..1b402d2f 100644
--- a/lib/gadget/gadget.vala
+++ b/lib/gadget/gadget.vala
@@ -1543,10 +1543,15 @@ namespace Frida.Gadget {
 			connection.on_closed.connect (on_connection_closed);
 
 			Peer peer;
-			if (auth_service != null)
+			if (auth_service != null) {
 				peer = new AuthenticationChannel (this, connection);
-			else
-				peer = setup_control_channel (connection);
+			} else {
+				try {
+					peer = setup_control_channel (connection);
+				} catch (IOError e) {
+					throw e;
+				}
+			}
 			peers[connection] = peer;
 
 			connection.start_message_processing ();
@@ -1564,7 +1569,11 @@ namespace Frida.Gadget {
 			peers.unset (connection);
 			yield channel.close (io_cancellable);
 
-			peers[connection] = setup_control_channel (connection);
+			try {
+				peers[connection] = setup_control_channel (connection);
+			} catch (IOError e) {
+				throw e;
+			}
 		}
 
 		private void kick_authentication_channel (AuthenticationChannel channel) {
@@ -1935,6 +1944,26 @@ namespace Frida.Gadget {
 				throw new Error.NOT_SUPPORTED ("Unable to open services when embedded");
 			}
 
+			public async HashTable<string, Variant> fridmira_negotiate_protocol (HashTable<string, Variant> client_params,
+					Cancellable? cancellable) throws Error, IOError {
+				// FridMira protocol negotiation for gadget mode
+				// Gadget模式的FridMira协议协商
+				var result = new HashTable<string, Variant> (null, null);
+
+				// For gadget mode, FridMira protocol negotiation is simplified
+				// 对于gadget模式，FridMira协议协商进行简化
+				// Since gadget runs in embedded mode, we return standard protocol by default
+				// 由于gadget运行在嵌入模式，默认返回标准协议
+
+				result["enabled"] = new Variant.boolean (false);
+				result["mode"] = new Variant.string ("standard");
+				result["version"] = new Variant.string ("16.7.19");
+				result["protocol_version"] = new Variant.string ("1.0");
+				result["note"] = new Variant.string ("Gadget mode uses standard RPC protocol");
+
+				return result;
+			}
+
 			private void validate_pid (uint pid) throws Error {
 				if (pid != this_process.pid)
 					throw new Error.NOT_SUPPORTED ("Unable to act on other processes when embedded");
diff --git a/src/host-session-service.vala b/src/host-session-service.vala
index b7a0c167..d5e808d0 100644
--- a/src/host-session-service.vala
+++ b/src/host-session-service.vala
@@ -401,6 +401,47 @@ namespace Frida {
 			return compute_system_parameters ();
 		}
 
+		public virtual async HashTable<string, Variant> fridmira_negotiate_protocol (HashTable<string, Variant> client_params,
+				Cancellable? cancellable) throws Error, IOError {
+			// Default implementation for LocalHostSession - delegate to FridMira framework
+			// LocalHostSession的默认实现 - 委托给FridMira框架
+			var result = new HashTable<string, Variant> (null, null);
+
+			// Check if FridMira framework is enabled
+			// 检查FridMira框架是否启用
+			bool fridmira_enabled = Frida.FridMira.is_globally_enabled();
+			bool fridmira_rpc_enabled = fridmira_enabled &&
+				Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+
+			result["enabled"] = new Variant.boolean (fridmira_rpc_enabled);
+			result["version"] = new Variant.string ("16.7.19");
+
+			if (fridmira_rpc_enabled) {
+				result["mode"] = new Variant.string ("fridmira");
+				try {
+					// Get current dynamic protocol information
+					// 获取当前动态协议信息
+					result["protocol_id"] = new Variant.string (
+						Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (null));
+					result["call_command"] = new Variant.string (
+						Frida.FridMiraRpcProtocolEnhancer.get_call_command (null));
+					result["ok_response"] = new Variant.string (
+						Frida.FridMiraRpcProtocolEnhancer.get_ok_response (null));
+					result["protocol_version"] = new Variant.string ("1.0");
+				} catch (GLib.Error e) {
+					// Fall back to standard mode if protocol info unavailable
+					// 如果协议信息不可用则回退到标准模式
+					result["enabled"] = new Variant.boolean (false);
+					result["mode"] = new Variant.string ("standard");
+					result["error"] = new Variant.string ("FridMira protocol unavailable: " + e.message);
+				}
+			} else {
+				result["mode"] = new Variant.string ("standard");
+			}
+
+			return result;
+		}
+
 		public abstract async HostApplicationInfo get_frontmost_application (HashTable<string, Variant> options,
 			Cancellable? cancellable) throws Error, IOError;
 
-- 
2.45.1.windows.1


From fe6bfdb8b922eee9e3495ca5b6c864f5a146432e Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 16:34:04 +0800
Subject: [PATCH 001/006] FridMira Anti-Detection Framework Core

---
 lib/mira/fridmira-agent.vala  |  263 ++++++++
 lib/mira/fridmira-file.vala   |  275 +++++++++
 lib/mira/fridmira-memory.vala |  226 +++++++
 lib/mira/fridmira-rpc.vala    | 1070 +++++++++++++++++++++++++++++++++
 lib/mira/fridmira-symbol.vala |  212 +++++++
 lib/mira/fridmira-thread.vala |  167 +++++
 lib/mira/fridmira.vala        |  340 +++++++++++
 7 files changed, 2553 insertions(+)
 create mode 100644 lib/mira/fridmira-agent.vala
 create mode 100644 lib/mira/fridmira-file.vala
 create mode 100644 lib/mira/fridmira-memory.vala
 create mode 100644 lib/mira/fridmira-rpc.vala
 create mode 100644 lib/mira/fridmira-symbol.vala
 create mode 100644 lib/mira/fridmira-thread.vala
 create mode 100644 lib/mira/fridmira.vala

diff --git a/lib/mira/fridmira-agent.vala b/lib/mira/fridmira-agent.vala
new file mode 100644
index 00000000..a2567bbe
--- /dev/null
+++ b/lib/mira/fridmira-agent.vala
@@ -0,0 +1,263 @@
+/**
+ * FridMira: Agent Library Management Module
+ * FridMira: Agent库管理模块
+ *
+ * This module provides comprehensive Agent library obfuscation capabilities,
+ * including dynamic library naming, path masquerading, and entry point
+ * symbol management to avoid detection during Agent injection.
+ *
+ * 此模块提供全面的Agent库混淆能力，包括动态库命名、路径伪装和
+ * 入口点符号管理，以避免在Agent注入过程中被检测。
+ *
+ * Features:
+ * - Dynamic library name generation with system-like patterns
+ * - Temporary directory management with obfuscated paths
+ * - Agent entry point symbol obfuscation (future extension)
+ * - Runtime library file management and cleanup
+ *
+ * 功能特性：
+ * - 使用系统样式模式的动态库名生成
+ * - 具有混淆路径的临时目录管理
+ * - Agent入口点符号混淆（未来扩展）
+ * - 运行时库文件管理和清理
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraAgentLibraryManager: Agent Library Obfuscation Engine
+	 * FridMira Agent库管理器：Agent库混淆引擎
+	 *
+	 * Manages dynamic naming and loading of Agent libraries, reusing existing
+	 * file name obfuscation functionality. Dynamically replaces Agent library
+	 * signatures at runtime to avoid detection.
+	 *
+	 * 管理Agent库的动态命名和加载，复用现有的文件名混淆功能。
+	 * 在运行时动态替换Agent库特征，避免检测。
+	 */
+	public class FridMiraAgentLibraryManager {
+		// Static cache for consistent naming within session
+		// 会话内一致命名的静态缓存
+		private static string? cached_agent_lib_name = null;
+		private static string? cached_agent_path = null;
+		private static string? cached_temp_directory = null;
+
+		/**
+		 * Check if Agent library obfuscation is enabled
+		 * 检查是否启用Agent库混淆
+		 *
+		 * SECURITY: Agent obfuscation is DISABLED by default to ensure compatibility
+		 * 安全：Agent混淆默认禁用以确保兼容性
+		 *
+		 * Only enabled when FRIDMIRA_AGENT_MODE=1 is explicitly set
+		 * 只有明确设置FRIDMIRA_AGENT_MODE=1 时才启用
+		 *
+		 * Priority: FRIDMIRA_AGENT_MODE=1 (explicit) > default(DISABLED)
+		 * 优先级：FRIDMIRA_AGENT_MODE=1 > 默认（禁用）
+		 */
+		private static bool is_mode_enabled() {
+			// ONLY enable when explicitly requested with FRIDMIRA_AGENT_MODE=1
+			// 只有明确请求FRIDMIRA_AGENT_MODE=1时才启用
+			string? agent_mode = GLib.Environment.get_variable("FRIDMIRA_AGENT_MODE");
+			if (agent_mode == "1") {
+				return true;
+			}
+
+			// DEFAULT: Always disabled for compatibility with standard Frida
+			// 默认：始终禁用以兼容标准Frida
+			// NOTE: Global FRIDMIRA_MODE does NOT affect Agent obfuscation
+			// 注意：全局FRIDMIRA_MODE不影响Agent混淆
+			return false;
+		}
+
+		/**
+		 * Get obfuscated Agent library name
+		 * 获取混淆的Agent库名
+		 *
+		 * Reuses FridMiraFileSystemObfuscator functionality for consistent
+		 * naming patterns across the framework.
+		 * 复用FridMiraFileSystemObfuscator功能，确保框架内命名模式一致。
+		 */
+		public static string get_obfuscated_agent_name() {
+			if (!is_mode_enabled()) {
+				return "frida-agent"; // Standard name
+			}
+
+			// Cache generated library name to ensure consistency within session
+			// 缓存生成的库名，确保同一会话中一致
+			if (cached_agent_lib_name == null) {
+				cached_agent_lib_name = FridMiraFileSystemObfuscator.generate_lib_name();
+			}
+
+			return cached_agent_lib_name;
+		}
+
+		/**
+		 * Create obfuscated Agent library copy
+		 * 创建混淆的Agent库副本
+		 *
+		 * Creates an Agent library copy with obfuscated name in temporary
+		 * directory to mask the original library signature.
+		 * 在临时目录中创建具有混淆名称的Agent库副本，掩盖原始库签名。
+		 */
+		public static string create_obfuscated_agent_copy(string original_agent_path) throws Error {
+			if (!is_mode_enabled()) {
+				return original_agent_path;
+			}
+
+			if (cached_agent_path != null) {
+				return cached_agent_path; // Already created
+			}
+
+			try {
+				// Get obfuscated library name
+				// 获取混淆的库名
+				string obfuscated_name = get_obfuscated_agent_name();
+
+				// Get temporary directory (reuse existing temporary directory logic)
+				// 获取临时目录（复用现有的临时目录逻辑）
+				string temp_dir = get_temp_directory();
+				string obfuscated_path = Path.build_filename(temp_dir, obfuscated_name + ".so");
+
+				// Copy Agent library to obfuscated path
+				// 复制Agent库到混淆路径
+				File source = File.new_for_path(original_agent_path);
+				File dest = File.new_for_path(obfuscated_path);
+
+				source.copy(dest, FileCopyFlags.OVERWRITE);
+
+				cached_agent_path = obfuscated_path;
+
+				if (GLib.Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+					stdout.printf("FridMira: Created obfuscated agent copy: %s -> %s\n",
+					             Path.get_basename(original_agent_path),
+					             Path.get_basename(obfuscated_path));
+				}
+
+				return obfuscated_path;
+
+			} catch (Error e) {
+				stderr.printf("FridMira: Failed to create obfuscated agent copy: %s\n", e.message);
+				return original_agent_path; // Fallback to original path on failure
+			}
+		}
+
+		/**
+		 * Get temporary directory path
+		 * 获取临时目录路径
+		 *
+		 * Reuses existing temporary directory logic with obfuscated naming.
+		 * 复用现有的临时目录逻辑，使用混淆命名。
+		 */
+		private static string get_temp_directory() {
+			if (cached_temp_directory != null) {
+				return cached_temp_directory;
+			}
+
+			// Check if bootstrap has set temporary directory name
+			// 检查bootstrap是否设置了临时目录名
+			string? temp_name = GLib.Environment.get_variable("FRIDMIRA_TEMP_DIR_NAME");
+			if (temp_name != null) {
+				string temp_path = Path.build_filename(GLib.Environment.get_tmp_dir(), temp_name);
+
+				// Ensure directory exists
+				// 确保目录存在
+				try {
+					File temp_dir = File.new_for_path(temp_path);
+					if (!temp_dir.query_exists()) {
+						temp_dir.make_directory_with_parents();
+					}
+					cached_temp_directory = temp_path;
+					return temp_path;
+				} catch (Error e) {
+					// Fall back to default temporary directory on failure
+					// 失败时使用默认临时目录
+				}
+			}
+
+			cached_temp_directory = GLib.Environment.get_tmp_dir();
+			return cached_temp_directory;
+		}
+
+		/**
+		 * Get Agent entry point symbol name
+		 * 获取Agent入口点符号名
+		 *
+		 * Note: Agent entry point symbol obfuscation requires compile-time patching
+		 * of the Agent library binary, which is beyond runtime obfuscation scope.
+		 * 注意：Agent入口点符号混淆需要在编译时对Agent库二进制进行补丁，
+		 * 这超出了运行时混淆的范围。
+		 *
+		 * Current focus: Runtime library path/name obfuscation for maximum stealth
+		 * 当前重点：运行时库路径/名称混淆以获得最大隐蔽性
+		 */
+		public static string get_agent_entry_symbol() {
+			// Agent入口点符号在编译时确定，无法在运行时修改
+			// The Agent entry point symbol is determined at compile time and cannot be modified at runtime
+			return "frida_agent_main";
+		}
+
+		/**
+		 * Clean up temporary Agent library files
+		 * 清理临时Agent库文件
+		 *
+		 * Removes obfuscated Agent library copies and cleans up
+		 * temporary directory resources.
+		 * 移除混淆的Agent库副本并清理临时目录资源。
+		 */
+		public static void cleanup_agent_files() {
+			if (cached_agent_path != null) {
+				try {
+					File agent_file = File.new_for_path(cached_agent_path);
+					if (agent_file.query_exists()) {
+						agent_file.delete();
+						if (GLib.Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+							stdout.printf("FridMira: Cleaned up obfuscated agent: %s\n",
+							             Path.get_basename(cached_agent_path));
+						}
+					}
+				} catch (Error e) {
+					stderr.printf("FridMira: Failed to cleanup agent file: %s\n", e.message);
+				}
+
+				cached_agent_path = null;
+			}
+
+			// Reset cached values
+			// 重置缓存值
+			cached_agent_lib_name = null;
+			cached_temp_directory = null;
+		}
+
+		/**
+		 * Public API to check if Agent library obfuscation is active
+		 * 公共API检查Agent库混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get current obfuscated Agent library information
+		 * 获取当前混淆的Agent库信息
+		 *
+		 * Returns debugging information about current Agent library state.
+		 * 返回关于当前Agent库状态的调试信息。
+		 */
+		public static string get_agent_status_info() {
+			if (!is_mode_enabled()) {
+				return "Agent obfuscation: DISABLED";
+			}
+
+			string lib_name = cached_agent_lib_name ?? "not generated";
+			string lib_path = cached_agent_path ?? "not created";
+			string temp_dir = cached_temp_directory ?? "not set";
+
+			return "Agent obfuscation: ENABLED\n" +
+			       "  Library name: %s\n".printf(lib_name) +
+			       "  Library path: %s\n".printf(lib_path) +
+			       "  Temp directory: %s".printf(temp_dir);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-file.vala b/lib/mira/fridmira-file.vala
new file mode 100644
index 00000000..c504bd4e
--- /dev/null
+++ b/lib/mira/fridmira-file.vala
@@ -0,0 +1,275 @@
+/**
+ * FridMira: File System Obfuscation Module
+ * FridMira: 文件系统混淆模块
+ *
+ * This module provides comprehensive file system obfuscation capabilities,
+ * including realistic library naming, Unix domain socket naming, and
+ * temporary directory management to blend with system components.
+ *
+ * 此模块提供全面的文件系统混淆能力，包括仿真库命名、Unix域socket命名
+ * 和临时目录管理，以与系统组件融合。
+ *
+ * Features:
+ * - Realistic library name generation mimicking system libraries
+ * - Unix domain socket name obfuscation for IPC masquerading
+ * - Temporary directory naming with system-like patterns
+ * - File extension and path component obfuscation
+ *
+ * 功能特性：
+ * - 模仿系统库的仿真库名生成
+ * - 用于IPC伪装的Unix域socket名混淆
+ * - 使用系统样式模式的临时目录命名
+ * - 文件扩展名和路径组件混淆
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraFileSystemObfuscator: File System Identifier Masking Engine
+	 * FridMira文件系统混淆器：文件系统标识符掩盖引擎
+	 *
+	 * Generates realistic library names and Unix domain socket names that
+	 * blend in with system components to avoid detection by file system
+	 * scanning tools and static analysis.
+	 *
+	 * 生成仿系统的库名和Unix域socket名，与系统组件融为一体，
+	 * 避免被文件系统扫描工具和静态分析检测。
+	 */
+	public class FridMiraFileSystemObfuscator {
+		// Library name component arrays for realistic generation
+		// 用于生成仿系统库名的组件数组
+		private static string[] get_lib_prefixes() {
+			return {
+				"lib", "android", "system", "native", "core", "runtime",
+				"platform", "framework", "service", "hal", "vendor", "bionic"
+			};
+		}
+
+		private static string[] get_lib_components() {
+			return {
+				"utils", "service", "manager", "handler", "process", "thread",
+				"memory", "network", "security", "crypto", "media", "graphics",
+				"audio", "camera", "sensor", "ui", "input", "display", "log"
+			};
+		}
+
+		private static string[] get_lib_suffixes() {
+			return {
+				"", "_native", "_jni", "_impl", "_core", "_base", "_v2", "_compat"
+			};
+		}
+
+		// Socket name component arrays for realistic generation
+		// 用于生成仿系统socket名的组件数组
+		private static string[] get_socket_prefixes() {
+			return {
+				"sys", "android", "native", "service", "core", "base",
+				"platform", "framework", "hal", "vendor", "system", "init"
+			};
+		}
+
+		private static string[] get_socket_components() {
+			return {
+				"sock", "ipc", "ctrl", "mgmt", "svc", "handler",
+				"bridge", "proxy", "daemon", "worker", "helper", "monitor"
+			};
+		}
+
+		/**
+		 * Check if file system obfuscation is enabled
+		 * 检查是否启用文件系统混淆
+		 *
+		 * Priority order: FRIDMIRA_FILE_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_FILE_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? file_mode = GLib.Environment.get_variable("FRIDMIRA_FILE_MODE");
+			if (file_mode != null) {
+				return file_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate realistic library name for agent masquerading
+		 * 为代理伪装生成仿系统的库名
+		 *
+		 * Creates library names that mimic legitimate Android/system libraries
+		 * to avoid detection by static analysis tools and file system scanners.
+		 * 创建模仿合法Android/系统库的库名，避免被静态分析工具和文件系统扫描器检测。
+		 */
+		public static string generate_lib_name() {
+			if (!is_mode_enabled()) {
+				return "frida-agent";
+			}
+
+			// Generate deterministic but time-varying seed
+			// 生成确定性但时变的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000);
+			var random = new Rand.with_seed(seed);
+
+			var lib_prefixes = get_lib_prefixes();
+			var lib_components = get_lib_components();
+			var lib_suffixes = get_lib_suffixes();
+
+			string prefix = lib_prefixes[random.int_range(0, lib_prefixes.length)];
+			string component = lib_components[random.int_range(0, lib_components.length)];
+			string suffix = lib_suffixes[random.int_range(0, lib_suffixes.length)];
+
+			return prefix + component + suffix;
+		}
+
+		/**
+		 * Generate realistic Unix domain socket name
+		 * 生成仿系统的Unix域socket名称
+		 *
+		 * Creates socket names that appear as legitimate system IPC endpoints
+		 * to avoid detection through /proc/net/unix scanning and process analysis.
+		 * 创建看起来像合法系统IPC端点的socket名，避免通过/proc/net/unix扫描和进程分析检测。
+		 */
+		public static string generate_realistic_socket_name() {
+			if (!is_mode_enabled()) {
+				return "frida-socket";
+			}
+
+			var socket_prefixes = get_socket_prefixes();
+			var socket_components = get_socket_components();
+
+			// Use custom PID and time for unique but realistic naming
+			// 使用自定义PID和时间生成唯一但仿系统的命名
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000);
+
+			// Generate custom PID equivalent using high-precision timestamp combination
+			// 使用高精度时间戳组合生成自定义PID等价物
+			int64 time_us = GLib.get_real_time();
+			uint32 custom_pid = (uint32)((time_us >> 16) ^ (time_us & 0xFFFF));
+			var random = new Rand.with_seed(seed ^ custom_pid);
+
+			string prefix = socket_prefixes[random.int_range(0, socket_prefixes.length)];
+			string component = socket_components[random.int_range(0, socket_components.length)];
+			uint suffix_num = random.int_range(1, 999);
+
+			return prefix + "_" + component + "_" + suffix_num.to_string();
+		}
+
+		/**
+		 * Generate obfuscated temporary directory name
+		 * 生成混淆的临时目录名
+		 *
+		 * Creates temporary directory names that look like system directories
+		 * to avoid detection through directory scanning and process monitoring.
+		 * 创建看起来像系统目录的临时目录名，避免通过目录扫描和进程监控检测。
+		 */
+		public static string generate_temp_directory_name() {
+			if (!is_mode_enabled()) {
+				return "frida-tmp";
+			}
+
+			// Use current timestamp to generate reasonable-looking system directory name
+			// 使用当前时间戳生成看起来合理的系统目录名
+			int64 timestamp = GLib.get_real_time() / 1000000;  // Second-level timestamp
+
+			// Generate system-like temporary directory name, avoiding "frida" keywords
+			// 生成类似系统临时目录的名称，避免"frida"字样
+			string[] prefixes = {"sys", "tmp", "cache", "local", "run", "var"};
+			string[] suffixes = {"daemon", "service", "helper", "worker", "proc"};
+
+			int prefix_idx = (int)(timestamp % prefixes.length);
+			int suffix_idx = (int)((timestamp / 10) % suffixes.length);
+
+			return prefixes[prefix_idx] + "." + suffix_idx.to_string() + "." + suffixes[suffix_idx];
+		}
+
+		/**
+		 * Obfuscate file path by replacing suspicious components
+		 * 通过替换可疑组件来混淆文件路径
+		 *
+		 * Replaces Frida-related path components with system-like alternatives
+		 * while preserving the overall path structure.
+		 * 将Frida相关的路径组件替换为系统样式的替代品，同时保持整体路径结构。
+		 */
+		public static string obfuscate_file_path(string original_path) {
+			if (!is_mode_enabled()) {
+				return original_path;
+			}
+
+			string result = original_path;
+
+			// Replace common Frida path components
+			// 替换常见的Frida路径组件
+			result = result.replace("frida", "native");
+			result = result.replace("FRIDA", "NATIVE");
+			result = result.replace("re.frida", "com.android");
+			result = result.replace("frida-server", "native-service");
+			result = result.replace("frida-agent", "native-lib");
+			result = result.replace("frida-gadget", "native-hook");
+
+			return result;
+		}
+
+		/**
+		 * Generate obfuscated file extension
+		 * 生成混淆的文件扩展名
+		 *
+		 * Replaces suspicious file extensions with common system alternatives.
+		 * 将可疑的文件扩展名替换为常见的系统替代品。
+		 */
+		public static string obfuscate_file_extension(string original_extension) {
+			if (!is_mode_enabled()) {
+				return original_extension;
+			}
+
+			// Map suspicious extensions to system-like alternatives
+			// 将可疑扩展名映射到系统样式的替代品
+			switch (original_extension.down()) {
+				case ".frida":
+					return ".native";
+				case ".fso":
+					return ".so";
+				case ".fjs":
+					return ".js";
+				case ".fconf":
+					return ".conf";
+				default:
+					return original_extension;
+			}
+		}
+
+		/**
+		 * Public API to check if file system obfuscation is active
+		 * 公共API检查文件系统混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get file system obfuscation status information
+		 * 获取文件系统混淆状态信息
+		 *
+		 * Returns debugging information about current file system obfuscation state.
+		 * 返回关于当前文件系统混淆状态的调试信息。
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "File system obfuscation: DISABLED";
+			}
+
+			string demo_lib = generate_lib_name();
+			string demo_socket = generate_realistic_socket_name();
+			string demo_temp = generate_temp_directory_name();
+
+			return "File system obfuscation: ENABLED\n" +
+			       "  Demo library: %s\n".printf(demo_lib) +
+			       "  Demo socket: %s\n".printf(demo_socket) +
+			       "  Demo temp dir: %s".printf(demo_temp);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-memory.vala b/lib/mira/fridmira-memory.vala
new file mode 100644
index 00000000..f71561db
--- /dev/null
+++ b/lib/mira/fridmira-memory.vala
@@ -0,0 +1,226 @@
+/**
+ * FridMira: Memory Obfuscation Module
+ * FridMira: 内存混淆模块
+ *
+ * This module provides memory region identifier masking capabilities to
+ * obfuscate memory-related identifiers and signatures that could be used
+ * to detect Frida's presence in process memory space.
+ *
+ * 此模块提供内存区域标识符掩盖能力，混淆内存相关标识符和签名，
+ * 避免在进程内存空间中检测到Frida的存在。
+ *
+ * Features:
+ * - Memory region identifier obfuscation
+ * - Heap and stack signature masking
+ * - Memory pool name generation
+ * - Dynamic memory allocation pattern masking
+ *
+ * 功能特性：
+ * - 内存区域标识符混淆
+ * - 堆和栈签名掩盖
+ * - 内存池名称生成
+ * - 动态内存分配模式掩盖
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraMemoryObfuscator: Memory Region Identifier Masking Engine
+	 * FridMira内存混淆器：内存区域标识符掩盖引擎
+	 *
+	 * Provides obfuscation for memory-related identifiers and signatures
+	 * that could be used to detect Frida's presence in process memory.
+	 * Generates realistic memory region names that blend with system allocations.
+	 *
+	 * 为内存相关标识符和签名提供混淆，避免在进程内存中检测到Frida的存在。
+	 * 生成与系统分配融合的仿真内存区域名称。
+	 */
+	public class FridMiraMemoryObfuscator {
+		// Memory identifier component arrays for realistic generation
+		// 用于生成仿真内存标识符的组件数组
+		private static string[] get_memory_prefixes() {
+			return {
+				"mem", "buf", "heap", "stack", "seg", "region", "block", "chunk",
+				"pool", "cache", "data", "code", "alloc", "zone", "space", "area"
+			};
+		}
+
+		private static string[] get_memory_components() {
+			return {
+				"data", "code", "exec", "read", "write", "shared", "private", "anon",
+				"temp", "cache", "buffer", "pool", "main", "aux", "sys", "user",
+				"native", "jni", "vm", "gc", "malloc", "mmap", "stack", "heap"
+			};
+		}
+
+		private static string[] get_memory_types() {
+			return {
+				"region", "segment", "block", "chunk", "page", "section",
+				"area", "zone", "space", "pool", "buffer", "cache"
+			};
+		}
+
+		/**
+		 * Check if memory obfuscation is enabled via environment variables
+		 * 通过环境变量检查是否启用内存混淆
+		 *
+		 * Priority order: FRIDMIRA_MEMORY_MODE > FRIDMIRA_GUM_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_MEMORY_MODE > FRIDMIRA_GUM_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific memory feature flag first
+			// 优先检查内存功能开关
+			string? memory_mode = GLib.Environment.get_variable("FRIDMIRA_MEMORY_MODE");
+			if (memory_mode != null) {
+				return memory_mode == "1";
+			}
+
+			// Check GUM-specific feature flag
+			// 检查GUM特定功能开关
+			string? gum_mode = GLib.Environment.get_variable("FRIDMIRA_GUM_MODE");
+			if (gum_mode != null) {
+				return gum_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate obfuscated memory region identifier
+		 * 生成混淆的内存区域标识符
+		 *
+		 * Creates realistic memory region identifiers that look like legitimate
+		 * system memory allocations to avoid detection by memory scanners.
+		 * 创建仿真的内存区域标识符，看起来像合法的系统内存分配，避免被内存扫描器检测。
+		 */
+		public static string obfuscate_memory_identifier(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var memory_prefixes = get_memory_prefixes();
+			var memory_components = get_memory_components();
+			var memory_types = get_memory_types();
+
+			string prefix = memory_prefixes[random.int_range(0, memory_prefixes.length)];
+			string component = memory_components[random.int_range(0, memory_components.length)];
+			string type = memory_types[random.int_range(0, memory_types.length)];
+			uint id = random.int_range(1000, 9999);
+
+			return prefix + "_" + component + "_" + type + "_" + id.to_string();
+		}
+
+		/**
+		 * Generate memory pool name for allocation masking
+		 * 为分配掩盖生成内存池名称
+		 *
+		 * Creates memory pool names that appear as system memory pools.
+		 * 创建看起来像系统内存池的内存池名称。
+		 */
+		public static string generate_memory_pool_name(string pool_type = "general") {
+			if (!is_mode_enabled()) {
+				return "frida_" + pool_type + "_pool";
+			}
+
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ pool_type.hash();
+			var random = new Rand.with_seed(seed);
+
+			var memory_prefixes = get_memory_prefixes();
+			var memory_components = get_memory_components();
+
+			string prefix = memory_prefixes[random.int_range(0, memory_prefixes.length)];
+			string component = memory_components[random.int_range(0, memory_components.length)];
+			uint pool_id = random.int_range(100, 999);
+
+			return prefix + "_" + component + "_pool_" + pool_id.to_string();
+		}
+
+		/**
+		 * Obfuscate memory allocation tag
+		 * 混淆内存分配标签
+		 *
+		 * Replaces Frida-specific memory allocation tags with system-like alternatives.
+		 * 将Frida特定的内存分配标签替换为系统样式的替代品。
+		 */
+		public static string obfuscate_allocation_tag(string original_tag) {
+			if (!is_mode_enabled()) {
+				return original_tag;
+			}
+
+			// Replace common Frida memory tags
+			// 替换常见的Frida内存标签
+			string result = original_tag;
+			result = result.replace("frida", "native");
+			result = result.replace("FRIDA", "NATIVE");
+			result = result.replace("gum", "sys");
+			result = result.replace("GUM", "SYS");
+			result = result.replace("agent", "handler");
+			result = result.replace("AGENT", "HANDLER");
+
+			// If no replacements were made, generate a new identifier
+			// 如果没有进行替换，生成新标识符
+			if (result == original_tag && original_tag.contains("frida")) {
+				return obfuscate_memory_identifier(original_tag);
+			}
+
+			return result;
+		}
+
+		/**
+		 * Generate heap segment name
+		 * 生成堆段名称
+		 */
+		public static string generate_heap_segment_name() {
+			if (!is_mode_enabled()) {
+				return "frida_heap";
+			}
+
+			return generate_memory_pool_name("heap");
+		}
+
+		/**
+		 * Generate stack region name
+		 * 生成栈区域名称
+		 */
+		public static string generate_stack_region_name() {
+			if (!is_mode_enabled()) {
+				return "frida_stack";
+			}
+
+			return generate_memory_pool_name("stack");
+		}
+
+		/**
+		 * Public API to check if memory obfuscation is active
+		 * 公共API检查内存混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get memory obfuscation status information
+		 * 获取内存混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Memory obfuscation: DISABLED";
+			}
+
+			string demo_memory = obfuscate_memory_identifier("frida_gum_heap");
+			string demo_pool = generate_memory_pool_name("agent");
+			return "Memory obfuscation: ENABLED\n" +
+			       "  Demo memory: 'frida_gum_heap' → '%s'\n".printf(demo_memory) +
+			       "  Demo pool: '%s'".printf(demo_pool);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-rpc.vala b/lib/mira/fridmira-rpc.vala
new file mode 100644
index 00000000..1c539915
--- /dev/null
+++ b/lib/mira/fridmira-rpc.vala
@@ -0,0 +1,1070 @@
+/**
+ * FridMira: RPC Protocol Module
+ * FridMira: RPC协议模块
+ *
+ * This module contains the adapter that plugs FridMira's RPC enhancement
+ * capabilities into the core Frida RPC client.
+ *
+ * 此模块包含将FridMira的RPC增强能力插入Frida核心RPC客户端的适配器。
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * Adapter to plug FridMira's RPC enhancement into the core RPC client.
+	 * 适配器，用于将FridMira的RPC增强功能插入核心RPC客户端。
+	 *
+	 * This class implements the RpcProtocolEnhancer interface and acts as a
+	 * bridge between the generic RPC client and the static FridMira protocol
+	 * logic. It also contains the self-contained discovery mechanism.
+	 *
+	 * 此类实现RpcProtocolEnhancer接口，充当通用RPC客户端和静态FridMira协议
+	 * 逻辑之间的桥梁。它还包含自包含的发现机制。
+	 *
+	 * Note: Initialization is handled by FridMira.initialize_rpc_protocol_enhancement()
+	 * in fridmira.vala to avoid duplication and ensure proper initialization order.
+	 * 注意：初始化由fridmira.vala中的FridMira.initialize_rpc_protocol_enhancement()处理，
+	 * 以避免重复并确保正确的初始化顺序。
+	 */
+	public class FridMiraRpcEnhancerAdapter : Object, RpcProtocolEnhancer {
+		private Gee.HashMap<string, PendingResponse> pending_discoveries = new Gee.HashMap<string, PendingResponse> ();
+		private bool protocol_negotiated = false;
+		private string? negotiated_session_id = null;
+
+		public string get_protocol_id (string? session_id) {
+			// Return standard protocol if enhanced mode is disabled
+			// 如果增强模式被禁用，返回标准协议
+			if (!Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				return "frida:rpc";
+			}
+			return Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (session_id);
+		}
+
+		public string get_call_command (string? session_id) {
+			// Return standard command if enhanced mode is disabled
+			// 如果增强模式被禁用，返回标准命令
+			if (!Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				return "call";
+			}
+			return Frida.FridMiraRpcProtocolEnhancer.get_call_command (session_id);
+		}
+
+		public string get_ok_response (string? session_id) {
+			// Return standard response if enhanced mode is disabled
+			// 如果增强模式被禁用，返回标准响应
+			if (!Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				return "ok";
+			}
+			return Frida.FridMiraRpcProtocolEnhancer.get_ok_response (session_id);
+		}
+
+		public string get_dynamic_protocol_id () {
+			return Frida.FridMiraRpcProtocolEnhancer.get_dynamic_protocol_id ();
+		}
+
+		public bool is_valid_protocol (string protocol) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_protocol (protocol);
+		}
+
+		public bool is_valid_ok_response (string status) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_ok_response (status);
+		}
+
+		public void forget_session (string session_id) {
+			Frida.FridMiraRpcProtocolEnhancer.forget_session (session_id);
+			if (negotiated_session_id == session_id) {
+				protocol_negotiated = false;
+				negotiated_session_id = null;
+			}
+		}
+
+		/**
+		 * NEW: Universal RPC Message Handler with Catch-All Hijacking
+		 * 新功能：通用RPC消息处理器，具有全面劫持功能
+		 *
+		 * This method implements a universal hijacking strategy:
+		 * 此方法实现通用劫持策略：
+		 *
+		 * 1. If the message is for explicit discovery (fridmira:discover), handle it directly
+		 * 2. If the message uses the correct dynamic protocol ID, ignore it (return false)
+		 *    to let the main RPC loop process it
+		 * 3. If the message uses ANY other protocol ID (including frida:rpc), hijack it
+		 *    and send back a discovery response
+		 *
+		 * 1. 如果是明确的发现消息(fridmira:discover)，直接处理
+		 * 2. 如果使用正确的动态协议ID，忽略它(返回false)让主RPC循环处理
+		 * 3. 如果使用任何其他协议ID(包括frida:rpc)，劫持它并发送发现响应
+		 */
+		public bool try_handle_message (string json, RpcPeer peer) {
+			var parser = new Json.Parser ();
+			try {
+				parser.load_from_data (json);
+			} catch (GLib.Error e) {
+				// Not a valid JSON message, let others handle it
+				// 不是有效的JSON消息，让其他处理器处理
+				return false;
+			}
+
+			var message_node = parser.get_root ();
+			if (message_node.get_node_type () != Json.NodeType.OBJECT) {
+				return false;
+			}
+			var message = message_node.get_object ();
+
+			if (message.get_string_member ("type") != "send") {
+				return false;
+			}
+
+			var payload = message.get_member ("payload");
+			if (payload == null || payload.get_node_type () != Json.NodeType.ARRAY) {
+				return false;
+			}
+
+			var rpc_message = payload.get_array ();
+			if (rpc_message.get_length () < 2) {
+				return false;
+			}
+
+			string? received_protocol_id = rpc_message.get_element (0).get_string ();
+			string? request_id = rpc_message.get_element (1).get_string ();
+
+			if (received_protocol_id == null || request_id == null) {
+				return false;
+			}
+
+			// Path 1: Explicit discovery request
+			// 路径1：明确的发现请求
+			if (received_protocol_id == "fridmira:discover") {
+				if (rpc_message.get_length () < 3) {
+					return false;
+				}
+				string? command = rpc_message.get_element (2).get_string ();
+				if (command == null) {
+				return false;
+			}
+
+			if (command == "get_protocol_info") {
+					// Server-side: handle discovery request from client
+					// 服务器端：处理来自客户端的发现请求
+					return send_protocol_discovery_response (request_id, peer, false);
+				} else if (command == "ok") {
+					// Client-side: handle discovery response from server
+					// 客户端：处理来自服务器的发现响应
+					return handle_discovery_response (request_id, rpc_message);
+				}
+				return false;
+			}
+
+			// Path 2: Correct dynamic protocol ID, let the core RPC loop handle it
+			// 路径2：正确的动态协议ID，让核心RPC循环处理
+			string current_protocol_id = get_protocol_id (null);
+			if (received_protocol_id == current_protocol_id) {
+				// This is a legitimate message with correct protocol, don't hijack
+				// 这是使用正确协议的合法消息，不要劫持
+			return false;
+		}
+
+			// Path 3: Any other protocol ID (including frida:rpc), hijack it!
+			// 路径3：任何其他协议ID（包括frida:rpc），劫持它！
+			if (rpc_message.get_length () >= 3) {
+				string? command = rpc_message.get_element (2).get_string ();
+				warning ("FridMira: Hijacking RPC call with incorrect protocol ID '%s' (command: %s). Responding with discovery info.",
+					received_protocol_id, command ?? "unknown");
+			} else {
+				warning ("FridMira: Hijacking RPC call with incorrect protocol ID '%s'. Responding with discovery info.",
+					received_protocol_id);
+			}
+
+			return send_protocol_discovery_response (request_id, peer, true);
+		}
+
+		/**
+		 * Send protocol discovery response (shared by both discovery and hijacking)
+		 * 发送协议发现响应（发现和劫持共用）
+		 */
+		private bool send_protocol_discovery_response (string request_id, RpcPeer peer, bool is_hijacked = false) {
+			try {
+				// Check if enhanced mode is enabled
+				// 检查是否启用了增强模式
+				bool enhanced_enabled = Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled ();
+
+				if (is_hijacked) {
+					// For hijacked standard RPC calls, send a standard error response that includes protocol info
+					// 对于被劫持的标准RPC调用，发送包含协议信息的标准错误响应
+					var protocol_info = "FridMira-Server-Active|protocol_id=%s|call_command=%s|ok_response=%s|enhanced_mode=%s".printf(
+						enhanced_enabled ? Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (null) : "frida:rpc",
+						enhanced_enabled ? Frida.FridMiraRpcProtocolEnhancer.get_call_command (null) : "call",
+						enhanced_enabled ? Frida.FridMiraRpcProtocolEnhancer.get_ok_response (null) : "ok",
+						enhanced_enabled ? "true" : "false"
+					);
+
+					var error_response = new Json.Builder ();
+					error_response
+						.begin_array ()
+						.add_string_value ("frida:rpc")  // Use standard protocol for compatibility
+						.add_string_value (request_id)
+						.add_string_value ("error")
+						.add_string_value (protocol_info)
+						.end_array ();
+
+					var full_response = new Json.Builder ();
+					full_response
+						.begin_object ()
+						.set_member_name ("type")
+						.add_string_value ("send")
+						.set_member_name ("payload")
+						.add_value (error_response.get_root ())
+						.end_object ();
+
+					peer.post_rpc_message.begin (Json.to_string (full_response.get_root (), false), null, null);
+					warning ("FridMira: Protocol hijacking response sent as standard error with protocol info");
+					return true;
+				} else {
+					// For explicit discovery requests, use the fridmira:discover protocol
+					// 对于明确的发现请求，使用fridmira:discover协议
+				var response_payload = new Json.Builder ();
+				response_payload
+					.begin_object ()
+					.set_member_name ("protocol_id")
+					.add_string_value (enhanced_enabled ?
+						Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (null) : "frida:rpc")
+					.set_member_name ("call_command")
+					.add_string_value (enhanced_enabled ?
+						Frida.FridMiraRpcProtocolEnhancer.get_call_command (null) : "call")
+					.set_member_name ("ok_response")
+					.add_string_value (enhanced_enabled ?
+						Frida.FridMiraRpcProtocolEnhancer.get_ok_response (null) : "ok")
+					.set_member_name ("enhanced_mode")
+					.add_boolean_value (enhanced_enabled)
+							.set_member_name ("hijacked")
+							.add_boolean_value (false)
+							.set_member_name ("message")
+							.add_string_value ("FridMira protocol discovery successful")
+					.end_object ();
+
+				var response_message = new Json.Builder ();
+				response_message
+					.begin_array ()
+					.add_string_value ("fridmira:discover")
+					.add_string_value (request_id)
+					.add_string_value ("ok")
+					.add_value (response_payload.get_root ())
+					.end_array ();
+
+				var full_response = new Json.Builder ();
+				full_response
+					.begin_object ()
+					.set_member_name ("type")
+					.add_string_value ("send")
+					.set_member_name ("payload")
+					.add_value (response_message.get_root ())
+					.end_object ();
+
+				peer.post_rpc_message.begin (Json.to_string (full_response.get_root (), false), null, null);
+				return true;
+				}
+			} catch (Error e) {
+				warning ("FridMira: Failed to send protocol discovery response: %s", e.message);
+				return false;
+			}
+		}
+
+		/**
+		 * Handle protocol discovery request from client (deprecated, now handled directly in try_handle_message)
+		 * 处理来自客户端的协议发现请求（已弃用，现在直接在try_handle_message中处理）
+		 */
+		private bool handle_discovery_request (string request_id, RpcPeer peer) {
+			return send_protocol_discovery_response (request_id, peer, false);
+		}
+
+		/**
+		 * Handle protocol discovery response from server
+		 * 处理来自服务器的协议发现响应
+		 */
+		private bool handle_discovery_response (string request_id, Json.Array discovery_message) {
+			PendingResponse? pending;
+			if (pending_discoveries.unset (request_id, out pending)) {
+				if (discovery_message.get_length () >= 4) {
+					var response_data = discovery_message.get_element (3);
+					if (response_data.get_node_type () == Json.NodeType.OBJECT) {
+						var response_obj = response_data.get_object ();
+						// Mark protocol as negotiated if response contains enhanced_mode flag
+						if (response_obj.has_member ("enhanced_mode")) {
+							protocol_negotiated = response_obj.get_boolean_member ("enhanced_mode");
+						}
+					}
+					pending.complete_with_result (response_data);
+				} else {
+					pending.complete_with_error (new Error.INVALID_ARGUMENT ("Malformed discovery response"));
+				}
+				return true;
+			}
+			return false;
+		}
+
+		/**
+		 * Enhanced protocol discovery with timeout and retry logic
+		 * 带超时和重试逻辑的增强协议发现
+		 */
+		public async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError {
+			const int MAX_RETRIES = 3;
+			const int TIMEOUT_MS = 5000;
+
+			for (int retry = 0; retry < MAX_RETRIES; retry++) {
+				try {
+					return yield discover_protocol_internal (peer, cancellable, TIMEOUT_MS);
+				} catch (IOError.CANCELLED e) {
+					throw e; // Don't retry on cancellation
+				} catch (Error e) {
+					if (retry == MAX_RETRIES - 1) {
+						throw e; // Re-throw on final retry
+					}
+					warning ("FridMira: Protocol discovery attempt %d failed: %s", retry + 1, e.message);
+					// Wait before retry
+					yield wait_async (1000);
+				}
+			}
+
+			throw new Error.PROTOCOL ("Protocol discovery failed after %d attempts", MAX_RETRIES);
+		}
+
+		/**
+		 * Internal protocol discovery implementation
+		 * 内部协议发现实现
+		 */
+		private async Json.Node discover_protocol_internal (RpcPeer peer, Cancellable? cancellable, int timeout_ms) throws Error, IOError {
+			string request_id = Uuid.string_random ();
+
+			var discovery_request = new Json.Builder ();
+			discovery_request
+				.begin_array ()
+				.add_string_value ("fridmira:discover")
+				.add_string_value (request_id)
+				.add_string_value ("get_protocol_info")
+				.end_array ();
+
+			var full_request = new Json.Builder ();
+			full_request
+				.begin_object ()
+				.set_member_name ("type")
+				.add_string_value ("send")
+				.set_member_name ("payload")
+				.add_value (discovery_request.get_root ())
+				.end_object ();
+			string raw_request = Json.to_string (full_request.get_root (), false);
+
+			bool waiting = false;
+			uint timeout_source_id = 0;
+
+			var pending = new PendingResponse (() => {
+				if (waiting)
+					discover_protocol_internal.callback ();
+				return false;
+			});
+			pending_discoveries[request_id] = pending;
+
+			try {
+				yield peer.post_rpc_message (raw_request, null, cancellable);
+			} catch (Error e) {
+				if (pending_discoveries.unset (request_id))
+					pending.complete_with_error (e);
+				throw e;
+			}
+
+			if (!pending.completed) {
+				// Set up timeout
+				timeout_source_id = Timeout.add (timeout_ms, () => {
+					if (pending_discoveries.unset (request_id))
+						pending.complete_with_error (new IOError.TIMED_OUT ("Protocol discovery timed out"));
+					return false;
+				});
+
+				// Set up cancellation handler
+				var cancel_source = new CancellableSource (cancellable);
+				cancel_source.set_callback (() => {
+					if (pending_discoveries.unset (request_id))
+						pending.complete_with_error (new IOError.CANCELLED ("Operation was cancelled"));
+					return false;
+				});
+				cancel_source.attach (MainContext.get_thread_default ());
+
+				waiting = true;
+				yield;
+				waiting = false;
+
+				if (timeout_source_id != 0) {
+					Source.remove (timeout_source_id);
+				}
+				cancel_source.destroy ();
+			}
+
+			cancellable.set_error_if_cancelled ();
+
+			if (pending.error != null)
+				throw_api_error (pending.error);
+
+			return pending.result;
+		}
+
+		/**
+		 * Async wait helper
+		 * 异步等待辅助函数
+		 */
+		private async void wait_async (int milliseconds) {
+			Timeout.add (milliseconds, () => {
+				wait_async.callback ();
+				return false;
+			});
+			yield;
+		}
+
+		private class PendingResponse {
+			private SourceFunc? handler;
+
+			public bool completed {
+				get {
+					return result != null || error != null;
+				}
+			}
+
+			public Json.Node? result {
+				get;
+				private set;
+			}
+
+			public GLib.Error? error {
+				get;
+				private set;
+			}
+
+			public PendingResponse (owned SourceFunc handler) {
+				this.handler = (owned) handler;
+			}
+
+			public void complete_with_result (Json.Node result) {
+				this.result = result;
+				handler ();
+				handler = null;
+			}
+
+			public void complete_with_error (GLib.Error error) {
+				this.error = error;
+				handler ();
+				handler = null;
+			}
+		}
+	}
+
+	/**
+	 * FridMiraRpcProtocolEnhancer: Advanced RPC Protocol Obfuscation
+	 * FridMiraRpcProtocolEnhancer: 高级RPC协议混淆
+	 *
+	 * This class provides advanced RPC protocol obfuscation capabilities
+	 * including dynamic protocol identifiers, command obfuscation, and
+	 * session-based protocol variations.
+	 *
+	 * 此类提供高级RPC协议混淆功能，包括动态协议标识符、命令混淆
+	 * 和基于会话的协议变化。
+	 */
+	public class FridMiraRpcProtocolEnhancer {
+		private static HashMap<string, string> session_protocols;
+		private static HashMap<string, string> session_commands;
+		private static HashMap<string, string> session_responses;
+		private static bool initialized = false;
+		private static Mutex init_mutex = Mutex();
+		private static bool enhanced_mode_cached = false;
+		private static bool enhanced_mode_checked = false;
+
+		// Fixed protocol cache for consistent server behavior
+		// 固定协议缓存，确保服务器行为一致性
+		private static string? _fixed_protocol_id = null;
+		private static string? _fixed_call_command = null;
+		private static string? _fixed_ok_response = null;
+		private static uint32 _deterministic_seed = 0;
+
+		/**
+		 * Initialize the RPC protocol enhancer
+		 * 初始化RPC协议增强器
+		 */
+		public static void init() {
+			init_mutex.lock();
+			try {
+				if (initialized) {
+					return;
+				}
+
+				session_protocols = new HashMap<string, string>();
+				session_commands = new HashMap<string, string>();
+				session_responses = new HashMap<string, string>();
+
+				// Generate deterministic seed based on process ID and start time
+				// 基于进程ID和启动时间生成确定性种子
+				_deterministic_seed = generate_deterministic_seed();
+
+				// Initialize fixed protocol cache for server consistency using deterministic seed
+				// 使用确定性种子初始化固定协议缓存以确保服务器一致性
+				_fixed_protocol_id = generate_obfuscated_protocol_deterministic(_deterministic_seed);
+				_fixed_call_command = generate_obfuscated_command_deterministic(_deterministic_seed + 1);
+				_fixed_ok_response = generate_obfuscated_response_deterministic(_deterministic_seed + 2);
+
+				initialized = true;
+			} finally {
+				init_mutex.unlock();
+			}
+		}
+
+		/**
+		 * Ensure initialization before any operation
+		 * 确保在任何操作之前完成初始化
+		 */
+		private static void ensure_initialized() {
+			if (!initialized) {
+				init();
+			}
+		}
+
+		/**
+		 * Check if enhanced mode is enabled with caching
+		 * 使用缓存检查是否启用增强模式
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			if (enhanced_mode_checked) {
+				return enhanced_mode_cached;
+			}
+
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+			if (rpc_mode != null) {
+				enhanced_mode_cached = (rpc_mode == "1");
+				enhanced_mode_checked = true;
+				return enhanced_mode_cached;
+			}
+
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			enhanced_mode_cached = (global_mode == "1");
+			enhanced_mode_checked = true;
+
+			return enhanced_mode_cached;
+		}
+
+		/**
+		 * Get protocol ID for session
+		 * 获取会话的协议ID
+		 */
+		public static string get_protocol_id(string? session_id) {
+			if (!is_enhanced_mode_enabled()) {
+				return "frida:rpc";
+			}
+
+			ensure_initialized();
+
+			if (session_id == null) {
+				// Return fixed protocol ID for server consistency
+				// 返回固定协议ID以确保服务器一致性
+				return _fixed_protocol_id;
+			}
+
+			if (!session_protocols.has_key(session_id)) {
+				// Generate deterministic protocol for session
+				// 为会话生成确定性协议
+				uint32 session_seed = generate_session_seed(session_id);
+				session_protocols[session_id] = generate_obfuscated_protocol_deterministic(session_seed);
+			}
+
+			return session_protocols[session_id];
+		}
+
+		/**
+		 * Get call command for session
+		 * 获取会话的调用命令
+		 */
+		public static string get_call_command(string? session_id) {
+			if (!is_enhanced_mode_enabled()) {
+				return "call";
+			}
+
+			ensure_initialized();
+
+			if (session_id == null) {
+				// Return fixed call command for server consistency
+				// 返回固定调用命令以确保服务器一致性
+				return _fixed_call_command;
+			}
+
+			if (!session_commands.has_key(session_id)) {
+				// Generate deterministic command for session
+				// 为会话生成确定性命令
+				uint32 session_seed = generate_session_seed(session_id);
+				session_commands[session_id] = generate_obfuscated_command_deterministic(session_seed + 1);
+			}
+
+			return session_commands[session_id];
+		}
+
+		/**
+		 * Get OK response for session
+		 * 获取会话的OK响应
+		 */
+		public static string get_ok_response(string? session_id) {
+			if (!is_enhanced_mode_enabled()) {
+				return "ok";
+			}
+
+			ensure_initialized();
+
+			if (session_id == null) {
+				// Return fixed OK response for server consistency
+				// 返回固定OK响应以确保服务器一致性
+				return _fixed_ok_response;
+			}
+
+			if (!session_responses.has_key(session_id)) {
+				// Generate deterministic response for session
+				// 为会话生成确定性响应
+				uint32 session_seed = generate_session_seed(session_id);
+				session_responses[session_id] = generate_obfuscated_response_deterministic(session_seed + 2);
+			}
+
+			return session_responses[session_id];
+		}
+
+		/**
+		 * Get dynamic protocol ID
+		 * 获取动态协议ID
+		 */
+		public static string get_dynamic_protocol_id() {
+			ensure_initialized();
+			// Return the same fixed protocol ID for consistency
+			// 返回相同的固定协议ID以确保一致性
+			return _fixed_protocol_id;
+		}
+
+		/**
+		 * Get deterministic seed for diagnostic purposes
+		 * 获取确定性种子用于诊断目的
+		 */
+		public static uint32 get_deterministic_seed() {
+			ensure_initialized();
+			return _deterministic_seed;
+		}
+
+		/**
+		 * Check if deterministic seed is initialized
+		 * 检查确定性种子是否已初始化
+		 */
+		public static bool is_deterministic_seed_initialized() {
+			return _deterministic_seed != 0;
+		}
+
+		/**
+		 * Check if protocol is valid
+		 * 检查协议是否有效
+		 */
+		public static bool is_valid_protocol(string protocol) {
+			if (!is_enhanced_mode_enabled()) {
+				return protocol == "frida:rpc";
+			}
+
+			ensure_initialized();
+
+			// Standard protocol is always valid
+			if (protocol == "frida:rpc") {
+				return true;
+			}
+
+			// Check session-specific protocols
+			foreach (var session_protocol in session_protocols.values) {
+				if (protocol == session_protocol) {
+					return true;
+				}
+			}
+
+			// Check if it matches our obfuscation pattern
+			return protocol.has_prefix("sys:") ||
+			       protocol.has_prefix("android:") ||
+			       protocol.has_prefix("linux:") ||
+			       protocol.has_prefix("proc:") ||
+			       protocol.has_prefix("dev:");
+		}
+
+		/**
+		 * Check if OK response is valid
+		 * 检查OK响应是否有效
+		 */
+		public static bool is_valid_ok_response(string status) {
+			if (!is_enhanced_mode_enabled()) {
+				return status == "ok";
+			}
+
+			ensure_initialized();
+
+			// Standard response is always valid
+			if (status == "ok") {
+				return true;
+			}
+
+			// Check session-specific responses
+			foreach (var session_response in session_responses.values) {
+				if (status == session_response) {
+					return true;
+				}
+			}
+
+			// Check if it matches our obfuscation pattern
+			return status.has_prefix("ack") ||
+			       status == "done" ||
+			       status == "complete" ||
+			       status == "ready" ||
+			       status == "success";
+		}
+
+		/**
+		 * Forget session data
+		 * 忘记会话数据
+		 */
+		public static void forget_session(string session_id) {
+			ensure_initialized();
+
+			if (session_protocols != null) {
+				session_protocols.unset(session_id);
+			}
+			if (session_commands != null) {
+				session_commands.unset(session_id);
+			}
+			if (session_responses != null) {
+				session_responses.unset(session_id);
+			}
+		}
+
+		/**
+		 * Generate obfuscated protocol name
+		 * 生成混淆的协议名
+		 */
+		private static string generate_obfuscated_protocol() {
+			string[] prefixes = {"sys", "android", "linux", "proc", "dev"};
+			string[] suffixes = {"rpc", "ipc", "msg", "comm", "ctl"};
+
+			string prefix = prefixes[Random.int_range(0, prefixes.length)];
+			string suffix = suffixes[Random.int_range(0, suffixes.length)];
+
+			return "%s:%s".printf(prefix, suffix);
+		}
+
+		/**
+		 * Generate obfuscated command
+		 * 生成混淆的命令
+		 */
+		private static string generate_obfuscated_command() {
+			string[] commands = {"exec", "run", "invoke", "proc", "handle"};
+			return commands[Random.int_range(0, commands.length)];
+		}
+
+		/**
+		 * Generate obfuscated response
+		 * 生成混淆的响应
+		 */
+		private static string generate_obfuscated_response() {
+			string[] responses = {"ack", "done", "complete", "ready", "success"};
+			return responses[Random.int_range(0, responses.length)];
+		}
+
+		/**
+		 * Generate deterministic seed for consistent protocol generation
+		 * 生成确定性种子以确保协议生成的一致性
+		 */
+		private static uint32 generate_deterministic_seed() {
+			// Use process ID as base for deterministic generation
+			// 使用进程ID作为确定性生成的基础
+			uint32 pid = (uint32) GLib.Posix.getpid();
+
+			// Add a fixed magic number to avoid predictable seeds
+			// 添加固定魔数以避免可预测的种子
+			uint32 magic = 0x46524944;  // "FRID" in hex
+
+			// Use XOR to combine them
+			// 使用XOR组合它们
+			uint32 seed = pid ^ magic;
+
+			// Ensure seed is not zero (would disable deterministic behavior)
+			// 确保种子不为零（否则会禁用确定性行为）
+			if (seed == 0) {
+				seed = 0x4D495241;  // "MIRA" in hex as fallback
+			}
+
+			// Additional safety: ensure seed is in valid range
+			// 额外安全：确保种子在有效范围内
+			if (seed == 0) {
+				warning("FridMira: Failed to generate valid deterministic seed, using fallback");
+				seed = 0x46524944;  // Final fallback
+			}
+
+			return seed;
+		}
+
+		/**
+		 * Generate deterministic seed for session-specific protocols
+		 * 为会话特定协议生成确定性种子
+		 */
+		private static uint32 generate_session_seed(string session_id) {
+			// Ensure initialization before using seed
+			// 确保在使用种子前完成初始化
+			ensure_initialized();
+
+			// Simple hash function for session ID
+			// 会话ID的简单哈希函数
+			uint32 hash = 0;
+			uint8[] session_bytes = session_id.data;
+
+			for (int i = 0; i < session_bytes.length; i++) {
+				hash = (hash * 31) + session_bytes[i];
+			}
+
+			// Combine with base seed for consistency
+			// 与基础种子组合以确保一致性
+			return hash ^ _deterministic_seed;
+		}
+
+		/**
+		 * Generate obfuscated protocol name using deterministic seed
+		 * 使用确定性种子生成混淆的协议名
+		 */
+		private static string generate_obfuscated_protocol_deterministic(uint32 seed) {
+			string[] prefixes = {"sys", "android", "linux", "proc", "dev"};
+			string[] suffixes = {"rpc", "ipc", "msg", "comm", "ctl"};
+
+			// Use seed to deterministically select prefix and suffix
+			// 使用种子确定性地选择前缀和后缀
+			string prefix = prefixes[seed % prefixes.length];
+			string suffix = suffixes[(seed >> 8) % suffixes.length];
+
+			return "%s:%s".printf(prefix, suffix);
+		}
+
+		/**
+		 * Generate obfuscated command using deterministic seed
+		 * 使用确定性种子生成混淆的命令
+		 */
+		private static string generate_obfuscated_command_deterministic(uint32 seed) {
+			string[] commands = {"exec", "run", "invoke", "proc", "handle"};
+			// Use seed to deterministically select command
+			// 使用种子确定性地选择命令
+			return commands[seed % commands.length];
+		}
+
+		/**
+		 * Generate obfuscated response using deterministic seed
+		 * 使用确定性种子生成混淆的响应
+		 */
+		private static string generate_obfuscated_response_deterministic(uint32 seed) {
+			string[] responses = {"ack", "done", "complete", "ready", "success"};
+			// Use seed to deterministically select response
+			// 使用种子确定性地选择响应
+			return responses[seed % responses.length];
+		}
+	}
+}
+
+/**
+ * FridMira RPC Protocol Diagnostic Tool
+ * FridMira RPC协议诊断工具
+ *
+ * This diagnostic tool helps identify and debug RPC protocol issues in FridMira.
+ * 此诊断工具有助于识别和调试FridMira中的RPC协议问题。
+ */
+namespace Frida.FridMiraDiagnostics {
+	public class RpcProtocolDiagnostic {
+
+		/**
+		 * Comprehensive protocol status check
+		 * 全面的协议状态检查
+		 */
+		public static string get_protocol_status() {
+			var status = new StringBuilder();
+
+			status.append("=== FridMira RPC Protocol Diagnostic Report ===\n");
+			status.append("Generated: %s\n\n".printf(new DateTime.now_local().to_string()));
+
+			// Environment variables check
+			status.append("1. Environment Variables:\n");
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+
+			status.append("   FRIDMIRA_RPC_MODE: %s\n".printf(rpc_mode ?? "NOT SET"));
+			status.append("   FRIDMIRA_MODE: %s\n".printf(global_mode ?? "NOT SET"));
+			status.append("   Enhanced mode enabled: %s\n\n".printf(
+				FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled() ? "YES" : "NO"));
+
+			// Protocol configuration
+			status.append("2. Protocol Configuration:\n");
+			status.append("   Default Protocol ID: %s\n".printf(
+				FridMiraRpcProtocolEnhancer.get_protocol_id(null)));
+			status.append("   Default Call Command: %s\n".printf(
+				FridMiraRpcProtocolEnhancer.get_call_command(null)));
+			status.append("   Default OK Response: %s\n".printf(
+				FridMiraRpcProtocolEnhancer.get_ok_response(null)));
+			status.append("   Dynamic Protocol ID: %s\n".printf(
+				FridMiraRpcProtocolEnhancer.get_dynamic_protocol_id()));
+
+			// Show deterministic seed information
+			// 显示确定性种子信息
+			if (FridMiraRpcProtocolEnhancer.is_deterministic_seed_initialized()) {
+				uint32 seed = FridMiraRpcProtocolEnhancer.get_deterministic_seed();
+				// Extract PID from seed (seed = pid ^ 0x46524944)
+				uint32 extracted_pid = seed ^ 0x46524944;
+				status.append("   Deterministic Seed: 0x%08X (Derived PID: %u)\n".printf(seed, extracted_pid));
+				status.append("   Seed Generation: ACTIVE (ensures consistent protocols)\n");
+			} else {
+				status.append("   Deterministic Seed: NOT INITIALIZED\n");
+				status.append("   Seed Generation: INACTIVE (protocols may vary)\n");
+			}
+			status.append("\n");
+
+			// Enhancer status
+			status.append("3. RPC Client Integration:\n");
+			if (RpcClient.enhancer != null) {
+				status.append("   Enhancer Status: ACTIVE ✓\n");
+				status.append("   Enhancer Type: %s\n".printf(RpcClient.enhancer.get_type().name()));
+			} else {
+				status.append("   Enhancer Status: NOT CONFIGURED ✗\n");
+				status.append("   Issue: RpcClient.enhancer is null\n");
+			}
+
+			// Protocol validation tests
+			status.append("\n4. Protocol Validation Tests:\n");
+			test_protocol_validation(status);
+
+			// Recommendations
+			status.append("\n5. Recommendations:\n");
+			generate_recommendations(status, rpc_mode, global_mode);
+
+			return status.str;
+		}
+
+		/**
+		 * Test protocol validation logic
+		 * 测试协议验证逻辑
+		 */
+		private static void test_protocol_validation(StringBuilder status) {
+			string[] test_protocols = {
+				"frida:rpc",
+				"sys:rpc",
+				"android:msg",
+				"linux:ipc",
+				"invalid:test"
+			};
+
+			foreach (string protocol in test_protocols) {
+				bool is_valid = FridMiraRpcProtocolEnhancer.is_valid_protocol(protocol);
+				status.append("   Protocol '%s': %s\n".printf(protocol, is_valid ? "VALID ✓" : "INVALID ✗"));
+			}
+
+			string[] test_responses = {
+				"ok",
+				"ack",
+				"done",
+				"complete",
+				"invalid"
+			};
+
+			foreach (string response in test_responses) {
+				bool is_valid = FridMiraRpcProtocolEnhancer.is_valid_ok_response(response);
+				status.append("   Response '%s': %s\n".printf(response, is_valid ? "VALID ✓" : "INVALID ✗"));
+			}
+		}
+
+		/**
+		 * Generate recommendations based on current configuration
+		 * 根据当前配置生成建议
+		 */
+		private static void generate_recommendations(StringBuilder status, string? rpc_mode, string? global_mode) {
+			if (rpc_mode == null && global_mode == null) {
+				status.append("   • Set FRIDMIRA_MODE=1 or FRIDMIRA_RPC_MODE=1 to enable RPC enhancement\n");
+			}
+
+			if (!FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				status.append("   • RPC enhancement is disabled - protocols will use standard 'frida:rpc'\n");
+			}
+
+			if (RpcClient.enhancer == null) {
+				status.append("   • CRITICAL: RpcClient.enhancer is not set - call Frida.RpcClient.enhancer = new Frida.FridMiraRpcEnhancerAdapter()\n");
+			}
+
+			status.append("   • Ensure frida-server is built with matching FridMira patches\n");
+			status.append("   • Use protocol discovery to verify client-server compatibility\n");
+		}
+
+		/**
+		 * Test RPC message parsing
+		 * 测试RPC消息解析
+		 */
+		public static bool test_message_parsing(string test_json) {
+			var adapter = new FridMiraRpcEnhancerAdapter();
+
+			// Mock peer for testing
+			RpcPeer? mock_peer = null; // In real implementation, would need a proper mock
+
+			try {
+				return adapter.try_handle_message(test_json, mock_peer);
+			} catch (Error e) {
+				warning("Message parsing test failed: %s", e.message);
+				return false;
+			}
+		}
+
+		/**
+		 * Generate test RPC messages for debugging
+		 * 生成用于调试的测试RPC消息
+		 */
+		public static string generate_test_discovery_message() {
+			var discovery_request = new Json.Builder ();
+			discovery_request
+				.begin_array ()
+				.add_string_value ("fridmira:discover")
+				.add_string_value ("test-request-id-123")
+				.add_string_value ("get_protocol_info")
+				.end_array ();
+
+			var full_request = new Json.Builder ();
+			full_request
+				.begin_object ()
+				.set_member_name ("type")
+				.add_string_value ("send")
+				.set_member_name ("payload")
+				.add_value (discovery_request.get_root ())
+				.end_object ();
+
+			return Json.to_string (full_request.get_root (), false);
+		}
+
+		/**
+		 * Generate test RPC call message
+		 * 生成测试RPC调用消息
+		 */
+		public static string generate_test_call_message(string? session_id = null) {
+			string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(session_id);
+			string call_command = FridMiraRpcProtocolEnhancer.get_call_command(session_id);
+
+			var request = new Json.Builder ();
+			request
+				.begin_array ()
+				.add_string_value (protocol_id)
+				.add_string_value ("test-call-id-456")
+				.add_string_value (call_command)
+				.add_string_value ("test_method")
+				.begin_array ()
+				.end_array ()
+				.end_array ();
+
+			var full_request = new Json.Builder ();
+			full_request
+				.begin_object ()
+				.set_member_name ("type")
+				.add_string_value ("send")
+				.set_member_name ("payload")
+				.add_value (request.get_root ())
+				.end_object ();
+
+			return Json.to_string (full_request.get_root (), false);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-symbol.vala b/lib/mira/fridmira-symbol.vala
new file mode 100644
index 00000000..36a7ed29
--- /dev/null
+++ b/lib/mira/fridmira-symbol.vala
@@ -0,0 +1,212 @@
+/**
+ * FridMira: Symbol Obfuscation Module
+ * FridMira: 符号混淆模块
+ *
+ * This module provides advanced symbol name obfuscation capabilities to
+ * replace Frida-related symbols with realistic system-like alternatives
+ * that blend in with native libraries and system components.
+ *
+ * 此模块提供高级符号名混淆能力，将Frida相关符号替换为仿系统的
+ * 替代品，与原生库和系统组件融为一体。
+ *
+ * Features:
+ * - Intelligent symbol filtering with blacklist approach
+ * - Realistic system-like symbol name generation
+ * - External configuration file support
+ * - Safe obfuscation that preserves critical entry points
+ *
+ * 功能特性：
+ * - 使用黑名单方法的智能符号过滤
+ * - 仿系统的符号名生成
+ * - 外部配置文件支持
+ * - 保护关键入口点的安全混淆
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraSymbolObfuscator: Advanced Symbol Name Obfuscation Engine
+	 * FridMira符号混淆器：高级符号名混淆引擎
+	 *
+	 * Generates realistic-looking symbol names that blend in with system
+	 * libraries and native Android/iOS components to avoid detection.
+	 * Uses intelligent filtering to only obfuscate Frida-related symbols
+	 * while preserving system-critical symbols for stability.
+	 *
+	 * 生成仿系统的符号名，与系统库和原生Android/iOS组件融为一体，避免检测。
+	 * 使用智能过滤只混淆Frida相关符号，同时保护系统关键符号以确保稳定性。
+	 */
+	public class FridMiraSymbolObfuscator {
+		// Symbol name component arrays for realistic generation
+		// 用于生成仿系统符号名的组件数组
+		private static string[] get_symbol_prefixes() {
+			return {
+				"_lib", "_sys", "_core", "_util", "_base", "_native", "_android",
+				"_ios", "_darwin", "_linux", "_gnu", "_glibc", "_musl"
+			};
+		}
+
+		private static string[] get_symbol_components() {
+			return {
+				"init", "start", "stop", "create", "destroy", "alloc", "free",
+				"open", "close", "read", "write", "send", "recv", "connect",
+				"bind", "listen", "accept", "process", "handle", "execute",
+				"invoke", "call", "return", "exit", "main", "entry", "cleanup",
+				"malloc", "calloc", "realloc", "mmap", "munmap", "dlopen"
+			};
+		}
+
+		private static string[] get_symbol_suffixes() {
+			return {
+				"", "_impl", "_native", "_jni", "_internal", "_handler",
+				"_mgr", "_svc", "_fn", "_proc", "_wrapper", "_bridge"
+			};
+		}
+
+		/**
+		 * Default Frida signature symbols (built-in blacklist)
+		 * 默认Frida特征符号（内置黑名单）
+		 */
+		private static string[] get_default_frida_signatures() {
+			return {
+				// Safe Frida signatures that can be obfuscated
+				// 可以安全混淆的Frida特征符号
+
+				// Frida server signatures / Frida服务器特征
+				"frida_server", "frida-server", "FRIDA_SERVER",
+				"FridaServer", "fridaServer",
+
+				// Frida gadget signatures / Frida gadget特征
+				"frida_gadget", "frida-gadget", "FRIDA_GADGET",
+				"FridaGadget", "fridaGadget",
+
+				// Frida core signatures / Frida核心特征
+				"frida_core", "frida-core", "FRIDA_CORE",
+				"FridaCore", "fridaCore",
+
+				// Frida script and RPC signatures / Frida脚本和RPC特征
+				"frida_rpc", "frida-rpc", "FRIDA_RPC",
+				"frida_script", "frida-script", "FRIDA_SCRIPT",
+				"FridaScript", "fridaScript",
+
+				// Frida session and device signatures / Frida会话和设备特征
+				"frida_session", "frida-session", "FRIDA_SESSION",
+				"frida_device", "frida-device", "FRIDA_DEVICE",
+				"FridaDevice", "fridaDevice",
+
+				// Frida process and spawn signatures / Frida进程和spawn特征
+				"frida_process", "frida-process", "FRIDA_PROCESS",
+				"frida_spawn", "frida-spawn", "FRIDA_SPAWN",
+
+				// Additional safe frida patterns / 额外的安全frida模式
+				"frida_version", "frida_build", "frida_config",
+				"frida_error", "frida_warning", "frida_debug"
+
+				// NOTE: Excluded critical entry points:
+				// 注意：排除了关键入口点：
+				// - frida_agent_main (entry point)
+				// - gum_init/gum_deinit (core initialization)
+				// - frida_init/frida_deinit (core initialization)
+			};
+		}
+
+		/**
+		 * Check if symbol obfuscation is enabled via environment variables
+		 * 通过环境变量检查是否启用符号混淆
+		 *
+		 * Priority order: FRIDMIRA_SYMBOL_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_SYMBOL_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? symbol_mode = GLib.Environment.get_variable("FRIDMIRA_SYMBOL_MODE");
+			if (symbol_mode != null) {
+				return symbol_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Check if a symbol should be obfuscated (simple blacklist mode)
+		 * 检查符号是否应该被混淆（简单黑名单模式）
+		 *
+		 * SIMPLE RULE: Only obfuscate if symbol contains Frida signatures
+		 * 简单规则：只有包含Frida特征的符号才混淆
+		 */
+		private static bool should_obfuscate_symbol(string original_symbol) {
+			// Check if symbol contains any Frida signature
+			// 检查符号是否包含任何Frida特征
+			foreach (string signature in get_default_frida_signatures()) {
+				if (original_symbol.contains(signature)) {
+					return true; // Safe to obfuscate
+				}
+			}
+
+			// Default: keep original (safe approach)
+			// 默认：保持原样（安全方法）
+			return false;
+		}
+
+		/**
+		 * Generate obfuscated symbol name using simple blacklist mode
+		 * 使用简单黑名单模式生成混淆的符号名
+		 *
+		 * SIMPLE APPROACH: Only obfuscate known Frida signatures
+		 * 简单方法：只混淆已知的Frida特征符号
+		 */
+		public static string obfuscate_symbol(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Blacklist check: only obfuscate Frida signature symbols
+			// 黑名单检查：只混淆Frida特征符号
+			if (!should_obfuscate_symbol(original)) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var symbol_prefixes = get_symbol_prefixes();
+			var symbol_components = get_symbol_components();
+			var symbol_suffixes = get_symbol_suffixes();
+
+			string prefix = symbol_prefixes[random.int_range(0, symbol_prefixes.length)];
+			string component = symbol_components[random.int_range(0, symbol_components.length)];
+			string suffix = symbol_suffixes[random.int_range(0, symbol_suffixes.length)];
+
+			return prefix + component + suffix;
+		}
+
+		/**
+		 * Public API to check if symbol obfuscation is active
+		 * 公共API检查符号混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get symbol obfuscation status information
+		 * 获取符号混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Symbol obfuscation: DISABLED";
+			}
+
+			string demo_symbol = obfuscate_symbol("frida_rpc_call");
+			return "Symbol obfuscation: ENABLED\n" +
+			       "  Demo: 'frida_rpc_call' → '%s'".printf(demo_symbol);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-thread.vala b/lib/mira/fridmira-thread.vala
new file mode 100644
index 00000000..71f0a4a9
--- /dev/null
+++ b/lib/mira/fridmira-thread.vala
@@ -0,0 +1,167 @@
+/**
+ * FridMira: Thread Obfuscation Module
+ * FridMira: 线程混淆模块
+ *
+ * This module provides thread name masking capabilities to replace
+ * detectable thread names like "frida-server-main-loop" with realistic
+ * system-like thread names that blend in with legitimate processes.
+ *
+ * 此模块提供线程名掩盖能力，将可检测的线程名如"frida-server-main-loop"
+ * 替换为仿系统的线程名，与合法进程融为一体。
+ *
+ * Features:
+ * - Realistic thread name generation mimicking system threads
+ * - Process-specific thread naming patterns
+ * - Dynamic thread name obfuscation at runtime
+ * - Thread pool and worker thread masquerading
+ *
+ * 功能特性：
+ * - 模仿系统线程的仿真线程名生成
+ * - 进程特定的线程命名模式
+ * - 运行时动态线程名混淆
+ * - 线程池和工作线程伪装
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraThreadObfuscator: Thread Name Masking Engine
+	 * FridMira线程混淆器：线程名掩盖引擎
+	 *
+	 * Replaces detectable thread names with realistic system-like thread names
+	 * that appear as legitimate system components to avoid detection by thread
+	 * scanning tools and process analysis.
+	 *
+	 * 将可检测的线程名替换为仿系统的线程名，看起来像合法的系统组件，
+	 * 避免被线程扫描工具和进程分析检测。
+	 */
+	public class FridMiraThreadObfuscator {
+		// Thread name component arrays for realistic generation
+		// 用于生成仿系统线程名的组件数组
+		private static string[] get_thread_prefixes() {
+			return {
+				"thread", "worker", "task", "job", "service", "handler", "process",
+				"daemon", "monitor", "watcher", "timer", "scheduler", "executor",
+				"async", "sync", "pool", "queue", "mgmt", "ctrl", "event"
+			};
+		}
+
+		private static string[] get_thread_components() {
+			return {
+				"main", "bg", "io", "net", "ui", "core", "util", "sys", "mgmt",
+				"ctrl", "data", "event", "signal", "async", "sync", "pool",
+				"work", "task", "job", "svc", "proc", "loop", "run", "exec"
+			};
+		}
+
+		private static string[] get_thread_suffixes() {
+			return {
+				"", "-1", "-2", "-pool", "-mgr", "-svc", "-loop", "-proc",
+				"-worker", "-handler", "-monitor", "-ctrl", "-th", "-0", "-bg"
+			};
+		}
+
+		/**
+		 * Check if thread name obfuscation is enabled
+		 * 检查是否启用线程名混淆
+		 *
+		 * Priority order: FRIDMIRA_THREAD_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_THREAD_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? thread_mode = GLib.Environment.get_variable("FRIDMIRA_THREAD_MODE");
+			if (thread_mode != null) {
+				return thread_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate realistic thread name that blends with system threads
+		 * 生成与系统线程融合的仿系统线程名
+		 *
+		 * Creates thread names that look like legitimate system components
+		 * to avoid detection by thread scanning tools and process monitors.
+		 * 创建看起来像合法系统组件的线程名，避免被线程扫描工具和进程监控检测。
+		 */
+		public static string obfuscate_thread_name(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var thread_prefixes = get_thread_prefixes();
+			var thread_components = get_thread_components();
+			var thread_suffixes = get_thread_suffixes();
+
+			string prefix = thread_prefixes[random.int_range(0, thread_prefixes.length)];
+			string component = thread_components[random.int_range(0, thread_components.length)];
+			string suffix = thread_suffixes[random.int_range(0, thread_suffixes.length)];
+
+			return prefix + "-" + component + suffix;
+		}
+
+		/**
+		 * Generate thread name for specific thread types
+		 * 为特定线程类型生成线程名
+		 *
+		 * Creates contextually appropriate thread names based on thread purpose.
+		 * 根据线程用途创建上下文适当的线程名。
+		 */
+		public static string generate_contextual_thread_name(string thread_type) {
+			if (!is_mode_enabled()) {
+				return thread_type;
+			}
+
+			switch (thread_type.down()) {
+				case "main":
+				case "server":
+					return "service-main";
+				case "worker":
+				case "pool":
+					return "worker-pool";
+				case "io":
+				case "network":
+					return "io-handler";
+				case "monitor":
+				case "watcher":
+					return "sys-monitor";
+				default:
+					return obfuscate_thread_name(thread_type);
+			}
+		}
+
+		/**
+		 * Public API to check if thread obfuscation is active
+		 * 公共API检查线程混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get thread obfuscation status information
+		 * 获取线程混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Thread obfuscation: DISABLED";
+			}
+
+			string demo_thread = obfuscate_thread_name("frida-server-main-loop");
+			return "Thread obfuscation: ENABLED\n" +
+			       "  Demo: 'frida-server-main-loop' → '%s'".printf(demo_thread);
+		}
+	}
+}
diff --git a/lib/mira/fridmira.vala b/lib/mira/fridmira.vala
new file mode 100644
index 00000000..ce85eed8
--- /dev/null
+++ b/lib/mira/fridmira.vala
@@ -0,0 +1,340 @@
+/**
+ * FridMira: Frida Anti-Detection Framework Core
+ * FridMira: Frida 反检测框架核心
+ *
+ * This is the core framework module that provides centralized initialization,
+ * configuration management, and coordination of all FridMira anti-detection
+ * components. It acts as the main entry point and orchestrator for the
+ * modular obfuscation system.
+ *
+ * 这是核心框架模块，提供集中的初始化、配置管理和所有FridMira反检测
+ * 组件的协调。它作为模块化混淆系统的主要入口点和协调器。
+ *
+ * Architecture:
+ * - Bootstrap initialization for early-stage protection
+ * - Modular component initialization and management
+ * - Environment variable configuration system
+ * - Centralized logging and status reporting
+ * - Framework lifecycle management
+ *
+ * 架构：
+ * - 用于早期保护的Bootstrap初始化
+ * - 模块化组件初始化和管理
+ * - 环境变量配置系统
+ * - 集中式日志记录和状态报告
+ * - 框架生命周期管理
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMira: Core Framework Manager
+	 * FridMira: 核心框架管理器
+	 *
+	 * The main framework class that coordinates all FridMira modules and
+	 * provides centralized initialization, configuration, and lifecycle
+	 * management for the anti-detection system.
+	 *
+	 * 协调所有FridMira模块的主框架类，为反检测系统提供集中的
+	 * 初始化、配置和生命周期管理。
+	 */
+	public class FridMira {
+		// Framework state tracking
+		// 框架状态跟踪
+		private static bool _bootstrap_initialized = false;
+		private static bool _framework_initialized = false;
+		private static bool _verbose_mode = false;
+
+		/**
+		 * FridMira Bootstrap Initialization
+		 * FridMira Bootstrap初始化
+		 *
+		 * This method provides lightweight early initialization that sets up
+		 * basic environment variables and prepares obfuscated names before
+		 * any system components are loaded.
+		 *
+		 * 此方法提供轻量级的早期初始化，在任何系统组件加载之前
+		 * 设置基本环境变量并准备混淆名称。
+		 */
+		public static void bootstrap_initialization(bool verbose = false) {
+			if (_bootstrap_initialized) {
+				return; // Already initialized
+			}
+
+			_verbose_mode = verbose;
+
+			// Set bootstrap markers and basic environment variables
+			// 设置bootstrap标记和基础环境变量
+			GLib.Environment.set_variable("FRIDMIRA_MODE", "1", true);
+			GLib.Environment.set_variable("FRIDMIRA_BOOTSTRAP", "1", true);
+
+			// Prepare obfuscated temporary directory name
+			// 准备混淆的临时目录名
+			string obfuscated_temp_name = FridMiraFileSystemObfuscator.generate_temp_directory_name();
+			GLib.Environment.set_variable("FRIDMIRA_TEMP_DIR_NAME", obfuscated_temp_name, true);
+
+			_bootstrap_initialized = true;
+
+			if (verbose) {
+				stdout.printf("FridMira: Bootstrap initialized - temp dir: %s\n", obfuscated_temp_name);
+			}
+		}
+
+		/**
+		 * Initialize FridMira Anti-Detection Framework
+		 * 初始化FridMira反检测框架
+		 *
+		 * This function sets up the complete FridMira framework with all
+		 * obfuscation modules. Components are automatically activated based
+		 * on environment variable configuration.
+		 *
+		 * 此函数设置完整的FridMira框架及所有混淆模块。组件根据环境变量
+		 * 配置自动激活。
+		 *
+		 * This function is designed to be called from control-service.vala
+		 * after preload completion to implement the "post-preload initialization"
+		 * strategy.
+		 *
+		 * 此函数设计为在Preload完成后从control-service.vala调用，
+		 * 以实现"预加载后初始化"策略。
+		 *
+		 * @internal This function is for internal FridMira use only and should
+		 * not be exposed in the public Frida API.
+		 */
+		public static void initialize_fridmira_framework(bool verbose = false) {
+			if (_framework_initialized) {
+				return; // Already initialized
+			}
+
+			_verbose_mode = verbose;
+
+			if (verbose) {
+				stdout.printf("FridMira: ------------------------------------------\n");
+				stdout.printf("FridMira: Starting modular framework initialization\n");
+
+				// Get and display verbose mode status
+				// 获取并显示详细模式状态
+				string? frida_verbose = GLib.Environment.get_variable("FRIDA_VERBOSE");
+				string? fridmira_verbose = GLib.Environment.get_variable("FRIDMIRA_VERBOSE");
+				stdout.printf("FridMira: Verbose mode: FRIDA_VERBOSE=%s, FRIDMIRA_VERBOSE=%s\n",
+					frida_verbose ?? "null", fridmira_verbose ?? "null");
+				stdout.printf("FridMira: ------------------------------------------\n");
+			}
+
+			// Initialize all modules
+			// 初始化所有模块
+			initialize_symbol_obfuscation(verbose);
+			initialize_thread_obfuscation(verbose);
+			initialize_rpc_protocol_enhancement(verbose);
+			initialize_file_system_obfuscation(verbose);
+			initialize_memory_obfuscation(verbose);
+			initialize_agent_library_management(verbose);
+
+			_framework_initialized = true;
+
+			if (verbose) {
+				stdout.printf("FridMira: ------------------------------------------\n");
+				stdout.printf("FridMira: ✅ Framework initialization COMPLETED\n");
+				stdout.printf("FridMira: Anti-detection protection is now ACTIVE\n");
+				stdout.printf("FridMira: All obfuscation modules are operational\n");
+				stdout.printf("FridMira: ------------------------------------------\n");
+			}
+		}
+
+		/**
+		 * Initialize Symbol Obfuscation Module
+		 * 初始化符号混淆模块
+		 */
+		private static void initialize_symbol_obfuscation(bool verbose) {
+			if (FridMiraSymbolObfuscator.is_enhanced_mode_enabled()) {
+				// Symbol obfuscator is stateless and doesn't need explicit init
+				// 符号混淆器是无状态的，不需要显式初始化
+				if (verbose) {
+					stdout.printf("FridMira: [✓] Symbol Obfuscation Module - ACTIVE\n");
+					// Show runtime obfuscation capability
+					// 显示运行时混淆能力
+					string sample_symbol = FridMiraSymbolObfuscator.obfuscate_symbol("frida_rpc_call");
+					stdout.printf("FridMira:     Runtime obfuscation ready: 'frida_*' → '%s' style\n", sample_symbol);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] Symbol Obfuscation Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Initialize Thread Obfuscation Module
+		 * 初始化线程混淆模块
+		 */
+		private static void initialize_thread_obfuscation(bool verbose) {
+			if (FridMiraThreadObfuscator.is_enhanced_mode_enabled()) {
+				// Thread obfuscator is stateless and doesn't need explicit init
+				// 线程混淆器是无状态的，不需要显式初始化
+				if (verbose) {
+					stdout.printf("FridMira: [✓] Thread Obfuscation Module - ACTIVE\n");
+					// Show runtime thread name obfuscation capability
+					// 显示运行时线程名混淆能力
+					string sample_thread = FridMiraThreadObfuscator.obfuscate_thread_name("frida-server-main-loop");
+					stdout.printf("FridMira:     Runtime thread names: 'frida-*' → '%s' style\n", sample_thread);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] Thread Obfuscation Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Initialize RPC Protocol Enhancement Module
+		 * 初始化RPC协议增强模块
+		 */
+		private static void initialize_rpc_protocol_enhancement(bool verbose) {
+			if (FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				FridMiraRpcProtocolEnhancer.init();
+				Frida.RpcClient.enhancer = new Frida.FridMiraRpcEnhancerAdapter();
+				if (verbose) {
+					stdout.printf("FridMira: [✓] RPC Protocol Enhancement Module - ACTIVE\n");
+					// Show active protocol obfuscation
+					// 显示激活的协议混淆
+					string current_protocol = FridMiraRpcProtocolEnhancer.get_dynamic_protocol_id();
+					string current_call = FridMiraRpcProtocolEnhancer.get_call_command(null);
+					stdout.printf("FridMira:     Active Protocol ID: '%s'\n", current_protocol);
+					stdout.printf("FridMira:     Active Call Command: '%s'\n", current_call);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] RPC Protocol Enhancement Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Initialize File System Obfuscation Module
+		 * 初始化文件系统混淆模块
+		 */
+		private static void initialize_file_system_obfuscation(bool verbose) {
+			if (FridMiraFileSystemObfuscator.is_enhanced_mode_enabled()) {
+				// File system obfuscator is stateless and doesn't need explicit init
+				// 文件系统混淆器是无状态的，不需要显式初始化
+				if (verbose) {
+					stdout.printf("FridMira: [✓] File System Obfuscation Module - ACTIVE\n");
+					// Show runtime file name generation
+					// 显示运行时文件名生成
+					string sample_lib = FridMiraFileSystemObfuscator.generate_lib_name();
+					string sample_socket = FridMiraFileSystemObfuscator.generate_realistic_socket_name();
+					stdout.printf("FridMira:     Dynamic library names: '%s' style\n", sample_lib);
+					stdout.printf("FridMira:     Dynamic socket names: '%s' style\n", sample_socket);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] File System Obfuscation Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Initialize Memory Obfuscation Module
+		 * 初始化内存混淆模块
+		 */
+		private static void initialize_memory_obfuscation(bool verbose) {
+			if (FridMiraMemoryObfuscator.is_enhanced_mode_enabled()) {
+				// Memory obfuscator is stateless and doesn't need explicit init
+				// 内存混淆器是无状态的，不需要显式初始化
+				if (verbose) {
+					stdout.printf("FridMira: [✓] Memory Obfuscation Module - ACTIVE\n");
+					// Show runtime memory identifier obfuscation
+					// 显示运行时内存标识符混淆
+					string sample_memory = FridMiraMemoryObfuscator.obfuscate_memory_identifier("frida_gum_heap");
+					stdout.printf("FridMira:     Runtime memory IDs: 'frida_*' → '%s' style\n", sample_memory);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] Memory Obfuscation Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Initialize Agent Library Management Module
+		 * 初始化Agent库管理模块
+		 */
+		private static void initialize_agent_library_management(bool verbose) {
+			if (FridMiraAgentLibraryManager.is_enhanced_mode_enabled()) {
+				// Agent library manager is stateless and doesn't need explicit init
+				// Agent库管理器是无状态的，不需要显式初始化
+				if (verbose) {
+					stdout.printf("FridMira: [✓] Agent Library Management Module - ACTIVE\n");
+					// Demonstrate agent library obfuscation
+					// 演示Agent库混淆
+					string demo_agent = FridMiraAgentLibraryManager.get_obfuscated_agent_name();
+					stdout.printf("FridMira:     Demo agent name: '%s'\n", demo_agent);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira: [✗] Agent Library Management Module - DISABLED\n");
+			}
+		}
+
+		/**
+		 * Get framework initialization status
+		 * 获取框架初始化状态
+		 */
+		public static bool is_framework_initialized() {
+			return _framework_initialized;
+		}
+
+		/**
+		 * Get bootstrap initialization status
+		 * 获取bootstrap初始化状态
+		 */
+		public static bool is_bootstrap_initialized() {
+			return _bootstrap_initialized;
+		}
+
+		/**
+		 * Check if FridMira is globally enabled
+		 * 检查FridMira是否全局启用
+		 */
+		public static bool is_globally_enabled() {
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Get comprehensive framework status information
+		 * 获取全面的框架状态信息
+		 */
+		public static string get_framework_status() {
+			var status = new StringBuilder();
+
+			status.append("FridMira Framework Status:\n");
+			status.append("  Bootstrap initialized: %s\n".printf(_bootstrap_initialized ? "YES" : "NO"));
+			status.append("  Framework initialized: %s\n".printf(_framework_initialized ? "YES" : "NO"));
+			status.append("  Globally enabled: %s\n".printf(is_globally_enabled() ? "YES" : "NO"));
+			status.append("  Verbose mode: %s\n".printf(_verbose_mode ? "YES" : "NO"));
+
+			if (_framework_initialized) {
+				status.append("\nModule Status:\n");
+				status.append("  Symbol Obfuscation: %s\n".printf(FridMiraSymbolObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Thread Obfuscation: %s\n".printf(FridMiraThreadObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  RPC Enhancement: %s\n".printf(FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  File System Obfuscation: %s\n".printf(FridMiraFileSystemObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Memory Obfuscation: %s\n".printf(FridMiraMemoryObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Agent Library Management: %s".printf(FridMiraAgentLibraryManager.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+			}
+
+			return status.str;
+		}
+
+		/**
+		 * Cleanup framework resources
+		 * 清理框架资源
+		 */
+		public static void cleanup_framework() {
+			// Cleanup Agent library files
+			// 清理Agent库文件
+			FridMiraAgentLibraryManager.cleanup_agent_files();
+
+			// Reset framework state
+			// 重置框架状态
+			_framework_initialized = false;
+			_bootstrap_initialized = false;
+			_verbose_mode = false;
+
+			if (_verbose_mode) {
+				stdout.printf("FridMira: Framework cleanup completed\n");
+			}
+		}
+	}
+}
-- 
2.45.1.windows.1


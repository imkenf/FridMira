From 9bf68060829bd5c393d6a3938fa8e033c0f8945f Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 16:34:04 +0800
Subject: [PATCH 001/006] FridMira Anti-Detection Framework Core

---
 lib/mira/fridmira-agent.vala  | 264 ++++++++++++
 lib/mira/fridmira-file.vala   | 275 +++++++++++++
 lib/mira/fridmira-memory.vala | 227 +++++++++++
 lib/mira/fridmira-rpc.vala    | 736 ++++++++++++++++++++++++++++++++++
 lib/mira/fridmira-symbol.vala | 212 ++++++++++
 lib/mira/fridmira-thread.vala | 167 ++++++++
 lib/mira/fridmira.vala        | 314 +++++++++++++++
 7 files changed, 2195 insertions(+)
 create mode 100644 lib/mira/fridmira-agent.vala
 create mode 100644 lib/mira/fridmira-file.vala
 create mode 100644 lib/mira/fridmira-memory.vala
 create mode 100644 lib/mira/fridmira-rpc.vala
 create mode 100644 lib/mira/fridmira-symbol.vala
 create mode 100644 lib/mira/fridmira-thread.vala
 create mode 100644 lib/mira/fridmira.vala

diff --git a/lib/mira/fridmira-agent.vala b/lib/mira/fridmira-agent.vala
new file mode 100644
index 00000000..bc1aa0eb
--- /dev/null
+++ b/lib/mira/fridmira-agent.vala
@@ -0,0 +1,264 @@
+/**
+ * FridMira: Agent Library Management Module
+ * FridMira: Agent库管理模块
+ *
+ * This module provides comprehensive Agent library obfuscation capabilities,
+ * including dynamic library naming, path masquerading, and entry point
+ * symbol management to avoid detection during Agent injection.
+ *
+ * 此模块提供全面的Agent库混淆能力，包括动态库命名、路径伪装和
+ * 入口点符号管理，以避免在Agent注入过程中被检测。
+ *
+ * Features:
+ * - Dynamic library name generation with system-like patterns
+ * - Temporary directory management with obfuscated paths
+ * - Agent entry point symbol obfuscation (future extension)
+ * - Runtime library file management and cleanup
+ *
+ * 功能特性：
+ * - 使用系统样式模式的动态库名生成
+ * - 具有混淆路径的临时目录管理
+ * - Agent入口点符号混淆（未来扩展）
+ * - 运行时库文件管理和清理
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraAgentLibraryManager: Agent Library Obfuscation Engine
+	 * FridMira Agent库管理器：Agent库混淆引擎
+	 *
+	 * Manages dynamic naming and loading of Agent libraries, reusing existing
+	 * file name obfuscation functionality. Dynamically replaces Agent library
+	 * signatures at runtime to avoid detection.
+	 *
+	 * 管理Agent库的动态命名和加载，复用现有的文件名混淆功能。
+	 * 在运行时动态替换Agent库特征，避免检测。
+	 */
+	public class FridMiraAgentLibraryManager {
+		// Static cache for consistent naming within session
+		// 会话内一致命名的静态缓存
+		private static string? cached_agent_lib_name = null;
+		private static string? cached_agent_path = null;
+		private static string? cached_temp_directory = null;
+
+		/**
+		 * Check if Agent library obfuscation is enabled
+		 * 检查是否启用Agent库混淆
+		 *
+		 * SECURITY: Agent obfuscation is DISABLED by default to ensure compatibility
+		 * 安全：Agent混淆默认禁用以确保兼容性
+		 *
+		 * Only enabled when FRIDMIRA_AGENT_MODE=1 is explicitly set
+		 * 只有明确设置FRIDMIRA_AGENT_MODE=1 时才启用
+		 *
+		 * Priority: FRIDMIRA_AGENT_MODE=1 (explicit) > default(DISABLED)
+		 * 优先级：FRIDMIRA_AGENT_MODE=1 > 默认（禁用）
+		 */
+		private static bool is_mode_enabled() {
+			// ONLY enable when explicitly requested with FRIDMIRA_AGENT_MODE=1
+			// 只有明确请求FRIDMIRA_AGENT_MODE=1时才启用
+			string? agent_mode = GLib.Environment.get_variable("FRIDMIRA_AGENT_MODE");
+			if (agent_mode == "1") {
+				return true;
+			}
+
+			// DEFAULT: Always disabled for compatibility with standard Frida
+			// 默认：始终禁用以兼容标准Frida
+			// NOTE: Global FRIDMIRA_MODE does NOT affect Agent obfuscation
+			// 注意：全局FRIDMIRA_MODE不影响Agent混淆
+			return false;
+		}
+
+		/**
+		 * Get obfuscated Agent library name
+		 * 获取混淆的Agent库名
+		 *
+		 * Reuses FridMiraFileSystemObfuscator functionality for consistent
+		 * naming patterns across the framework.
+		 * 复用FridMiraFileSystemObfuscator功能，确保框架内命名模式一致。
+		 */
+		public static string get_obfuscated_agent_name() {
+			if (!is_mode_enabled()) {
+				return "frida-agent"; // Standard name
+			}
+
+			// Cache generated library name to ensure consistency within session
+			// 缓存生成的库名，确保同一会话中一致
+			if (cached_agent_lib_name == null) {
+				cached_agent_lib_name = FridMiraFileSystemObfuscator.generate_lib_name();
+			}
+
+			return cached_agent_lib_name;
+		}
+
+		/**
+		 * Create obfuscated Agent library copy
+		 * 创建混淆的Agent库副本
+		 *
+		 * Creates an Agent library copy with obfuscated name in temporary
+		 * directory to mask the original library signature.
+		 * 在临时目录中创建具有混淆名称的Agent库副本，掩盖原始库签名。
+		 */
+		public static string create_obfuscated_agent_copy(string original_agent_path) throws Error {
+			if (!is_mode_enabled()) {
+				return original_agent_path;
+			}
+
+			if (cached_agent_path != null) {
+				return cached_agent_path; // Already created
+			}
+
+			try {
+				// Get obfuscated library name
+				// 获取混淆的库名
+				string obfuscated_name = get_obfuscated_agent_name();
+
+				// Get temporary directory (reuse existing temporary directory logic)
+				// 获取临时目录（复用现有的临时目录逻辑）
+				string temp_dir = get_temp_directory();
+				string obfuscated_path = Path.build_filename(temp_dir, obfuscated_name + ".so");
+
+				// Copy Agent library to obfuscated path
+				// 复制Agent库到混淆路径
+				File source = File.new_for_path(original_agent_path);
+				File dest = File.new_for_path(obfuscated_path);
+
+				source.copy(dest, FileCopyFlags.OVERWRITE);
+
+				cached_agent_path = obfuscated_path;
+
+				if (GLib.Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+					stdout.printf("FridMira: Created obfuscated agent copy: %s -> %s\n",
+					             Path.get_basename(original_agent_path),
+					             Path.get_basename(obfuscated_path));
+				}
+
+				return obfuscated_path;
+
+			} catch (Error e) {
+				stderr.printf("FridMira: Failed to create obfuscated agent copy: %s\n", e.message);
+				return original_agent_path; // Fallback to original path on failure
+			}
+		}
+
+		/**
+		 * Get temporary directory path
+		 * 获取临时目录路径
+		 *
+		 * Reuses existing temporary directory logic with obfuscated naming.
+		 * 复用现有的临时目录逻辑，使用混淆命名。
+		 */
+		private static string get_temp_directory() {
+			if (cached_temp_directory != null) {
+				return cached_temp_directory;
+			}
+
+			// Check if bootstrap has set temporary directory name
+			// 检查bootstrap是否设置了临时目录名
+			string? temp_name = GLib.Environment.get_variable("FRIDMIRA_TEMP_DIR_NAME");
+			if (temp_name != null) {
+				string temp_path = Path.build_filename(GLib.Environment.get_tmp_dir(), temp_name);
+
+				// Ensure directory exists
+				// 确保目录存在
+				try {
+					File temp_dir = File.new_for_path(temp_path);
+					if (!temp_dir.query_exists()) {
+						temp_dir.make_directory_with_parents();
+					}
+					cached_temp_directory = temp_path;
+					return temp_path;
+				} catch (Error e) {
+					// Fall back to default temporary directory on failure
+					// 失败时使用默认临时目录
+				}
+			}
+
+			cached_temp_directory = GLib.Environment.get_tmp_dir();
+			return cached_temp_directory;
+		}
+
+		/**
+		 * Get Agent entry point symbol name
+		 * 获取Agent入口点符号名
+		 *
+		 * Note: Agent entry point symbol obfuscation requires compile-time patching
+		 * of the Agent library binary, which is beyond runtime obfuscation scope.
+		 * 注意：Agent入口点符号混淆需要在编译时对Agent库二进制进行补丁，
+		 * 这超出了运行时混淆的范围。
+		 *
+		 * Current focus: Runtime library path/name obfuscation for maximum stealth
+		 * 当前重点：运行时库路径/名称混淆以获得最大隐蔽性
+		 */
+		public static string get_agent_entry_symbol() {
+			// Agent入口点符号在编译时确定，无法在运行时修改
+			// The Agent entry point symbol is determined at compile time and cannot be modified at runtime
+			return "frida_agent_main";
+		}
+
+		/**
+		 * Clean up temporary Agent library files
+		 * 清理临时Agent库文件
+		 *
+		 * Removes obfuscated Agent library copies and cleans up
+		 * temporary directory resources.
+		 * 移除混淆的Agent库副本并清理临时目录资源。
+		 */
+		public static void cleanup_agent_files() {
+			if (cached_agent_path != null) {
+				try {
+					File agent_file = File.new_for_path(cached_agent_path);
+					if (agent_file.query_exists()) {
+						agent_file.delete();
+						if (GLib.Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+							stdout.printf("FridMira: Cleaned up obfuscated agent: %s\n",
+							             Path.get_basename(cached_agent_path));
+						}
+					}
+				} catch (Error e) {
+					stderr.printf("FridMira: Failed to cleanup agent file: %s\n", e.message);
+				}
+
+				cached_agent_path = null;
+			}
+
+			// Reset cached values
+			// 重置缓存值
+			cached_agent_lib_name = null;
+			cached_temp_directory = null;
+		}
+
+		/**
+		 * Public API to check if Agent library obfuscation is active
+		 * 公共API检查Agent库混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get current obfuscated Agent library information
+		 * 获取当前混淆的Agent库信息
+		 *
+		 * Returns debugging information about current Agent library state.
+		 * 返回关于当前Agent库状态的调试信息。
+		 */
+		public static string get_agent_status_info() {
+			if (!is_mode_enabled()) {
+				return "Agent obfuscation: DISABLED";
+			}
+
+			string lib_name = cached_agent_lib_name ?? "not generated";
+			string lib_path = cached_agent_path ?? "not created";
+			string temp_dir = cached_temp_directory ?? "not set";
+
+			return "Agent obfuscation: ENABLED\n" +
+			       "  Library name: %s\n".printf(lib_name) +
+			       "  Library path: %s\n".printf(lib_path) +
+			       "  Temp directory: %s".printf(temp_dir);
+		}
+
+	}
+}
diff --git a/lib/mira/fridmira-file.vala b/lib/mira/fridmira-file.vala
new file mode 100644
index 00000000..c504bd4e
--- /dev/null
+++ b/lib/mira/fridmira-file.vala
@@ -0,0 +1,275 @@
+/**
+ * FridMira: File System Obfuscation Module
+ * FridMira: 文件系统混淆模块
+ *
+ * This module provides comprehensive file system obfuscation capabilities,
+ * including realistic library naming, Unix domain socket naming, and
+ * temporary directory management to blend with system components.
+ *
+ * 此模块提供全面的文件系统混淆能力，包括仿真库命名、Unix域socket命名
+ * 和临时目录管理，以与系统组件融合。
+ *
+ * Features:
+ * - Realistic library name generation mimicking system libraries
+ * - Unix domain socket name obfuscation for IPC masquerading
+ * - Temporary directory naming with system-like patterns
+ * - File extension and path component obfuscation
+ *
+ * 功能特性：
+ * - 模仿系统库的仿真库名生成
+ * - 用于IPC伪装的Unix域socket名混淆
+ * - 使用系统样式模式的临时目录命名
+ * - 文件扩展名和路径组件混淆
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraFileSystemObfuscator: File System Identifier Masking Engine
+	 * FridMira文件系统混淆器：文件系统标识符掩盖引擎
+	 *
+	 * Generates realistic library names and Unix domain socket names that
+	 * blend in with system components to avoid detection by file system
+	 * scanning tools and static analysis.
+	 *
+	 * 生成仿系统的库名和Unix域socket名，与系统组件融为一体，
+	 * 避免被文件系统扫描工具和静态分析检测。
+	 */
+	public class FridMiraFileSystemObfuscator {
+		// Library name component arrays for realistic generation
+		// 用于生成仿系统库名的组件数组
+		private static string[] get_lib_prefixes() {
+			return {
+				"lib", "android", "system", "native", "core", "runtime",
+				"platform", "framework", "service", "hal", "vendor", "bionic"
+			};
+		}
+
+		private static string[] get_lib_components() {
+			return {
+				"utils", "service", "manager", "handler", "process", "thread",
+				"memory", "network", "security", "crypto", "media", "graphics",
+				"audio", "camera", "sensor", "ui", "input", "display", "log"
+			};
+		}
+
+		private static string[] get_lib_suffixes() {
+			return {
+				"", "_native", "_jni", "_impl", "_core", "_base", "_v2", "_compat"
+			};
+		}
+
+		// Socket name component arrays for realistic generation
+		// 用于生成仿系统socket名的组件数组
+		private static string[] get_socket_prefixes() {
+			return {
+				"sys", "android", "native", "service", "core", "base",
+				"platform", "framework", "hal", "vendor", "system", "init"
+			};
+		}
+
+		private static string[] get_socket_components() {
+			return {
+				"sock", "ipc", "ctrl", "mgmt", "svc", "handler",
+				"bridge", "proxy", "daemon", "worker", "helper", "monitor"
+			};
+		}
+
+		/**
+		 * Check if file system obfuscation is enabled
+		 * 检查是否启用文件系统混淆
+		 *
+		 * Priority order: FRIDMIRA_FILE_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_FILE_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? file_mode = GLib.Environment.get_variable("FRIDMIRA_FILE_MODE");
+			if (file_mode != null) {
+				return file_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate realistic library name for agent masquerading
+		 * 为代理伪装生成仿系统的库名
+		 *
+		 * Creates library names that mimic legitimate Android/system libraries
+		 * to avoid detection by static analysis tools and file system scanners.
+		 * 创建模仿合法Android/系统库的库名，避免被静态分析工具和文件系统扫描器检测。
+		 */
+		public static string generate_lib_name() {
+			if (!is_mode_enabled()) {
+				return "frida-agent";
+			}
+
+			// Generate deterministic but time-varying seed
+			// 生成确定性但时变的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000);
+			var random = new Rand.with_seed(seed);
+
+			var lib_prefixes = get_lib_prefixes();
+			var lib_components = get_lib_components();
+			var lib_suffixes = get_lib_suffixes();
+
+			string prefix = lib_prefixes[random.int_range(0, lib_prefixes.length)];
+			string component = lib_components[random.int_range(0, lib_components.length)];
+			string suffix = lib_suffixes[random.int_range(0, lib_suffixes.length)];
+
+			return prefix + component + suffix;
+		}
+
+		/**
+		 * Generate realistic Unix domain socket name
+		 * 生成仿系统的Unix域socket名称
+		 *
+		 * Creates socket names that appear as legitimate system IPC endpoints
+		 * to avoid detection through /proc/net/unix scanning and process analysis.
+		 * 创建看起来像合法系统IPC端点的socket名，避免通过/proc/net/unix扫描和进程分析检测。
+		 */
+		public static string generate_realistic_socket_name() {
+			if (!is_mode_enabled()) {
+				return "frida-socket";
+			}
+
+			var socket_prefixes = get_socket_prefixes();
+			var socket_components = get_socket_components();
+
+			// Use custom PID and time for unique but realistic naming
+			// 使用自定义PID和时间生成唯一但仿系统的命名
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000);
+
+			// Generate custom PID equivalent using high-precision timestamp combination
+			// 使用高精度时间戳组合生成自定义PID等价物
+			int64 time_us = GLib.get_real_time();
+			uint32 custom_pid = (uint32)((time_us >> 16) ^ (time_us & 0xFFFF));
+			var random = new Rand.with_seed(seed ^ custom_pid);
+
+			string prefix = socket_prefixes[random.int_range(0, socket_prefixes.length)];
+			string component = socket_components[random.int_range(0, socket_components.length)];
+			uint suffix_num = random.int_range(1, 999);
+
+			return prefix + "_" + component + "_" + suffix_num.to_string();
+		}
+
+		/**
+		 * Generate obfuscated temporary directory name
+		 * 生成混淆的临时目录名
+		 *
+		 * Creates temporary directory names that look like system directories
+		 * to avoid detection through directory scanning and process monitoring.
+		 * 创建看起来像系统目录的临时目录名，避免通过目录扫描和进程监控检测。
+		 */
+		public static string generate_temp_directory_name() {
+			if (!is_mode_enabled()) {
+				return "frida-tmp";
+			}
+
+			// Use current timestamp to generate reasonable-looking system directory name
+			// 使用当前时间戳生成看起来合理的系统目录名
+			int64 timestamp = GLib.get_real_time() / 1000000;  // Second-level timestamp
+
+			// Generate system-like temporary directory name, avoiding "frida" keywords
+			// 生成类似系统临时目录的名称，避免"frida"字样
+			string[] prefixes = {"sys", "tmp", "cache", "local", "run", "var"};
+			string[] suffixes = {"daemon", "service", "helper", "worker", "proc"};
+
+			int prefix_idx = (int)(timestamp % prefixes.length);
+			int suffix_idx = (int)((timestamp / 10) % suffixes.length);
+
+			return prefixes[prefix_idx] + "." + suffix_idx.to_string() + "." + suffixes[suffix_idx];
+		}
+
+		/**
+		 * Obfuscate file path by replacing suspicious components
+		 * 通过替换可疑组件来混淆文件路径
+		 *
+		 * Replaces Frida-related path components with system-like alternatives
+		 * while preserving the overall path structure.
+		 * 将Frida相关的路径组件替换为系统样式的替代品，同时保持整体路径结构。
+		 */
+		public static string obfuscate_file_path(string original_path) {
+			if (!is_mode_enabled()) {
+				return original_path;
+			}
+
+			string result = original_path;
+
+			// Replace common Frida path components
+			// 替换常见的Frida路径组件
+			result = result.replace("frida", "native");
+			result = result.replace("FRIDA", "NATIVE");
+			result = result.replace("re.frida", "com.android");
+			result = result.replace("frida-server", "native-service");
+			result = result.replace("frida-agent", "native-lib");
+			result = result.replace("frida-gadget", "native-hook");
+
+			return result;
+		}
+
+		/**
+		 * Generate obfuscated file extension
+		 * 生成混淆的文件扩展名
+		 *
+		 * Replaces suspicious file extensions with common system alternatives.
+		 * 将可疑的文件扩展名替换为常见的系统替代品。
+		 */
+		public static string obfuscate_file_extension(string original_extension) {
+			if (!is_mode_enabled()) {
+				return original_extension;
+			}
+
+			// Map suspicious extensions to system-like alternatives
+			// 将可疑扩展名映射到系统样式的替代品
+			switch (original_extension.down()) {
+				case ".frida":
+					return ".native";
+				case ".fso":
+					return ".so";
+				case ".fjs":
+					return ".js";
+				case ".fconf":
+					return ".conf";
+				default:
+					return original_extension;
+			}
+		}
+
+		/**
+		 * Public API to check if file system obfuscation is active
+		 * 公共API检查文件系统混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get file system obfuscation status information
+		 * 获取文件系统混淆状态信息
+		 *
+		 * Returns debugging information about current file system obfuscation state.
+		 * 返回关于当前文件系统混淆状态的调试信息。
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "File system obfuscation: DISABLED";
+			}
+
+			string demo_lib = generate_lib_name();
+			string demo_socket = generate_realistic_socket_name();
+			string demo_temp = generate_temp_directory_name();
+
+			return "File system obfuscation: ENABLED\n" +
+			       "  Demo library: %s\n".printf(demo_lib) +
+			       "  Demo socket: %s\n".printf(demo_socket) +
+			       "  Demo temp dir: %s".printf(demo_temp);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-memory.vala b/lib/mira/fridmira-memory.vala
new file mode 100644
index 00000000..7efe2b02
--- /dev/null
+++ b/lib/mira/fridmira-memory.vala
@@ -0,0 +1,227 @@
+/**
+ * FridMira: Memory Obfuscation Module
+ * FridMira: 内存混淆模块
+ *
+ * This module provides memory region identifier masking capabilities to
+ * obfuscate memory-related identifiers and signatures that could be used
+ * to detect Frida's presence in process memory space.
+ *
+ * 此模块提供内存区域标识符掩盖能力，混淆内存相关标识符和签名，
+ * 避免在进程内存空间中检测到Frida的存在。
+ *
+ * Features:
+ * - Memory region identifier obfuscation
+ * - Heap and stack signature masking
+ * - Memory pool name generation
+ * - Dynamic memory allocation pattern masking
+ *
+ * 功能特性：
+ * - 内存区域标识符混淆
+ * - 堆和栈签名掩盖
+ * - 内存池名称生成
+ * - 动态内存分配模式掩盖
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraMemoryObfuscator: Memory Region Identifier Masking Engine
+	 * FridMira内存混淆器：内存区域标识符掩盖引擎
+	 *
+	 * Provides obfuscation for memory-related identifiers and signatures
+	 * that could be used to detect Frida's presence in process memory.
+	 * Generates realistic memory region names that blend with system allocations.
+	 *
+	 * 为内存相关标识符和签名提供混淆，避免在进程内存中检测到Frida的存在。
+	 * 生成与系统分配融合的仿真内存区域名称。
+	 */
+	public class FridMiraMemoryObfuscator {
+		// Memory identifier component arrays for realistic generation
+		// 用于生成仿真内存标识符的组件数组
+		private static string[] get_memory_prefixes() {
+			return {
+				"mem", "buf", "heap", "stack", "seg", "region", "block", "chunk",
+				"pool", "cache", "data", "code", "alloc", "zone", "space", "area"
+			};
+		}
+
+		private static string[] get_memory_components() {
+			return {
+				"data", "code", "exec", "read", "write", "shared", "private", "anon",
+				"temp", "cache", "buffer", "pool", "main", "aux", "sys", "user",
+				"native", "jni", "vm", "gc", "malloc", "mmap", "stack", "heap"
+			};
+		}
+
+		private static string[] get_memory_types() {
+			return {
+				"region", "segment", "block", "chunk", "page", "section",
+				"area", "zone", "space", "pool", "buffer", "cache"
+			};
+		}
+
+		/**
+		 * Check if memory obfuscation is enabled via environment variables
+		 * 通过环境变量检查是否启用内存混淆
+		 *
+		 * Priority order: FRIDMIRA_MEMORY_MODE > FRIDMIRA_GUM_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_MEMORY_MODE > FRIDMIRA_GUM_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific memory feature flag first
+			// 优先检查内存功能开关
+			string? memory_mode = GLib.Environment.get_variable("FRIDMIRA_MEMORY_MODE");
+			if (memory_mode != null) {
+				return memory_mode == "1";
+			}
+
+			// Check GUM-specific feature flag
+			// 检查GUM特定功能开关
+			string? gum_mode = GLib.Environment.get_variable("FRIDMIRA_GUM_MODE");
+			if (gum_mode != null) {
+				return gum_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate obfuscated memory region identifier
+		 * 生成混淆的内存区域标识符
+		 *
+		 * Creates realistic memory region identifiers that look like legitimate
+		 * system memory allocations to avoid detection by memory scanners.
+		 * 创建仿真的内存区域标识符，看起来像合法的系统内存分配，避免被内存扫描器检测。
+		 */
+		public static string obfuscate_memory_identifier(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var memory_prefixes = get_memory_prefixes();
+			var memory_components = get_memory_components();
+			var memory_types = get_memory_types();
+
+			string prefix = memory_prefixes[random.int_range(0, memory_prefixes.length)];
+			string component = memory_components[random.int_range(0, memory_components.length)];
+			string type = memory_types[random.int_range(0, memory_types.length)];
+			uint id = random.int_range(1000, 9999);
+
+			return prefix + "_" + component + "_" + type + "_" + id.to_string();
+		}
+
+		/**
+		 * Generate memory pool name for allocation masking
+		 * 为分配掩盖生成内存池名称
+		 *
+		 * Creates memory pool names that appear as system memory pools.
+		 * 创建看起来像系统内存池的内存池名称。
+		 */
+		public static string generate_memory_pool_name(string pool_type = "general") {
+			if (!is_mode_enabled()) {
+				return "frida_" + pool_type + "_pool";
+			}
+
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ pool_type.hash();
+			var random = new Rand.with_seed(seed);
+
+			var memory_prefixes = get_memory_prefixes();
+			var memory_components = get_memory_components();
+
+			string prefix = memory_prefixes[random.int_range(0, memory_prefixes.length)];
+			string component = memory_components[random.int_range(0, memory_components.length)];
+			uint pool_id = random.int_range(100, 999);
+
+			return prefix + "_" + component + "_pool_" + pool_id.to_string();
+		}
+
+		/**
+		 * Obfuscate memory allocation tag
+		 * 混淆内存分配标签
+		 *
+		 * Replaces Frida-specific memory allocation tags with system-like alternatives.
+		 * 将Frida特定的内存分配标签替换为系统样式的替代品。
+		 */
+		public static string obfuscate_allocation_tag(string original_tag) {
+			if (!is_mode_enabled()) {
+				return original_tag;
+			}
+
+			// Replace common Frida memory tags
+			// 替换常见的Frida内存标签
+			string result = original_tag;
+			result = result.replace("frida", "native");
+			result = result.replace("FRIDA", "NATIVE");
+			result = result.replace("gum", "sys");
+			result = result.replace("GUM", "SYS");
+			result = result.replace("agent", "handler");
+			result = result.replace("AGENT", "HANDLER");
+
+			// If no replacements were made, generate a new identifier
+			// 如果没有进行替换，生成新标识符
+			if (result == original_tag && original_tag.contains("frida")) {
+				return obfuscate_memory_identifier(original_tag);
+			}
+
+			return result;
+		}
+
+		/**
+		 * Generate heap segment name
+		 * 生成堆段名称
+		 */
+		public static string generate_heap_segment_name() {
+			if (!is_mode_enabled()) {
+				return "frida_heap";
+			}
+
+			return generate_memory_pool_name("heap");
+		}
+
+		/**
+		 * Generate stack region name
+		 * 生成栈区域名称
+		 */
+		public static string generate_stack_region_name() {
+			if (!is_mode_enabled()) {
+				return "frida_stack";
+			}
+
+			return generate_memory_pool_name("stack");
+		}
+
+		/**
+		 * Public API to check if memory obfuscation is active
+		 * 公共API检查内存混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get memory obfuscation status information
+		 * 获取内存混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Memory obfuscation: DISABLED";
+			}
+
+			string demo_memory = obfuscate_memory_identifier("frida_gum_heap");
+			string demo_pool = generate_memory_pool_name("agent");
+			return "Memory obfuscation: ENABLED\n" +
+			       "  Demo memory: 'frida_gum_heap' → '%s'\n".printf(demo_memory) +
+			       "  Demo pool: '%s'".printf(demo_pool);
+		}
+
+	}
+}
diff --git a/lib/mira/fridmira-rpc.vala b/lib/mira/fridmira-rpc.vala
new file mode 100644
index 00000000..7f8532d7
--- /dev/null
+++ b/lib/mira/fridmira-rpc.vala
@@ -0,0 +1,736 @@
+/**
+ * FridMira: RPC Protocol Module
+ * FridMira: RPC协议模块
+ *
+ * This module contains the adapter that plugs FridMira's RPC enhancement
+ * capabilities into the core Frida RPC client.
+ *
+ * 此模块包含将FridMira的RPC增强能力插入Frida核心RPC客户端的适配器。
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * Adapter to plug FridMira's RPC enhancement into the core RPC client.
+	 * 适配器，用于将FridMira的RPC增强功能插入核心RPC客户端。
+	 *
+	 * This class implements the RpcProtocolEnhancer interface and acts as a
+	 * bridge between the generic RPC client and the static FridMira protocol
+	 * logic. Simplified version focused on protocol translation only.
+	 *
+	 * 此类实现RpcProtocolEnhancer接口，充当通用RPC客户端和静态FridMira协议
+	 * 逻辑之间的桥梁。简化版本仅专注于协议转换。
+	 */
+	public class FridMiraRpcEnhancerAdapter : Object, RpcProtocolEnhancer {
+
+		public string get_protocol_id (string? session_id) {
+			// Return enhanced protocol if enabled, otherwise standard
+			// 如果启用增强模式则返回增强协议，否则返回标准协议
+			return Frida.FridMiraRpcProtocolEnhancer.get_protocol_id (session_id);
+		}
+
+		public string get_call_command (string? session_id) {
+			// Return enhanced command if enabled, otherwise standard
+			// 如果启用增强模式则返回增强命令，否则返回标准命令
+			return Frida.FridMiraRpcProtocolEnhancer.get_call_command (session_id);
+		}
+
+		public string get_ok_response (string? session_id) {
+			// Return enhanced response if enabled, otherwise standard
+			// 如果启用增强模式则返回增强响应，否则返回标准响应
+			return Frida.FridMiraRpcProtocolEnhancer.get_ok_response (session_id);
+		}
+
+		public string get_dynamic_protocol_id () {
+			return Frida.FridMiraRpcProtocolEnhancer.get_dynamic_protocol_id ();
+		}
+
+		public bool is_valid_protocol (string protocol) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_protocol (protocol);
+		}
+
+		public bool is_valid_ok_response (string status) {
+			return Frida.FridMiraRpcProtocolEnhancer.is_valid_ok_response (status);
+		}
+
+		public void forget_session (string session_id) {
+			Frida.FridMiraRpcProtocolEnhancer.forget_session (session_id);
+		}
+
+		/**
+		 * Simplified message handling - no discovery protocol needed
+		 * 简化的消息处理 - 不需要发现协议
+		 *
+		 * For FridMira enhanced servers, clients must be pre-configured
+		 * with the correct protocol information.
+		 * 对于FridMira增强服务器，客户端必须预配置正确的协议信息。
+		 */
+		public bool try_handle_message (string json, RpcPeer peer) {
+			// No special message handling needed - standard RPC flow only
+			// 不需要特殊消息处理 - 仅标准RPC流程
+			return false;
+		}
+
+		/**
+		 * No discovery needed - clients must know protocol in advance
+		 * 不需要发现 - 客户端必须事先知道协议
+		 */
+		public async Json.Node discover_protocol (RpcPeer peer, Cancellable? cancellable) throws Error, IOError {
+			throw new Error.NOT_SUPPORTED ("Protocol discovery disabled - use pre-configured FridMira client");
+		}
+	}
+
+	/**
+	 * FridMiraRpcProtocolEnhancer: Advanced RPC Protocol Obfuscation
+	 * FridMiraRpcProtocolEnhancer: 高级RPC协议混淆
+	 *
+	 * This class provides advanced RPC protocol obfuscation capabilities
+	 * including dynamic protocol identifiers, command obfuscation, and
+	 * session-based protocol variations.
+	 *
+	 * 此类提供高级RPC协议混淆功能，包括动态协议标识符、命令混淆
+	 * 和基于会话的协议变化。
+	 */
+	public class FridMiraRpcProtocolEnhancer {
+		private static HashMap<string, string> session_protocols;
+		private static HashMap<string, string> session_commands;
+		private static bool initialized = false;
+		private static Mutex init_mutex = Mutex();
+		private static bool enhanced_mode_cached = false;
+		private static bool enhanced_mode_checked = false;
+
+		/**
+		 * Initialize the RPC protocol enhancer
+		 * 初始化RPC协议增强器
+		 */
+		public static void init() {
+			init_mutex.lock();
+			try {
+				if (initialized) {
+					return;
+				}
+
+				// Initialize with error handling for robustness
+				// 使用错误处理进行初始化以提高健壮性
+				try {
+					session_protocols = new HashMap<string, string>();
+					session_commands = new HashMap<string, string>();
+
+					initialized = true;
+				} catch (Error e) {
+					// Log error but don't fail completely - fallback to standard mode
+					// 记录错误但不完全失败 - 回退到标准模式
+					stderr.printf ("FridMira: RPC enhancer initialization failed: %s\n", e.message);
+					stderr.printf ("FridMira: Falling back to standard RPC mode\n");
+
+					// Ensure variables are not null to prevent crashes
+					// 确保变量不为null以防止崩溃
+					if (session_protocols == null) {
+						session_protocols = new HashMap<string, string>();
+					}
+					if (session_commands == null) {
+						session_commands = new HashMap<string, string>();
+					}
+
+					initialized = true;
+				}
+			} finally {
+				init_mutex.unlock();
+			}
+		}
+
+		/**
+		 * Ensure initialization before any operation
+		 * 确保在任何操作之前完成初始化
+		 */
+		private static void ensure_initialized() {
+			if (!initialized) {
+				try {
+					init();
+				} catch (Error e) {
+					// If initialization fails, log error and continue with defaults
+					// 如果初始化失败，记录错误并使用默认值继续
+					stderr.printf ("FridMira: RPC enhancer ensure_initialized failed: %s\n", e.message);
+
+					// Ensure basic functionality with fallback
+					// 确保基本功能的回退机制
+					if (session_protocols == null) {
+						session_protocols = new HashMap<string, string>();
+					}
+					if (session_commands == null) {
+						session_commands = new HashMap<string, string>();
+					}
+					initialized = true;
+				}
+			}
+		}
+
+		/**
+		 * Check if enhanced mode is enabled with caching
+		 * 使用缓存检查是否启用增强模式
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			if (enhanced_mode_checked) {
+				return enhanced_mode_cached;
+			}
+
+			// Check specific RPC mode first
+			// 首先检查特定的RPC模式
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+			if (rpc_mode != null) {
+				enhanced_mode_cached = (rpc_mode == "1");
+				enhanced_mode_checked = true;
+				return enhanced_mode_cached;
+			}
+
+			// Then check global mode
+			// 然后检查全局模式
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			enhanced_mode_cached = (global_mode == "1");
+			enhanced_mode_checked = true;
+
+			return enhanced_mode_cached;
+		}
+
+		/**
+		 * Get protocol ID for session
+		 * 获取会话的协议ID
+		 */
+		public static string get_protocol_id(string? session_id) {
+			if (!is_enhanced_mode_enabled()) {
+				return "frida:rpc";
+			}
+
+			ensure_initialized();
+
+			if (session_id == null) {
+				return generate_obfuscated_protocol();
+			}
+
+			if (!session_protocols.has_key(session_id)) {
+				session_protocols[session_id] = generate_obfuscated_protocol();
+			}
+
+			return session_protocols[session_id];
+		}
+
+		/**
+		 * Get call command for session
+		 * 获取会话的调用命令
+		 */
+		public static string get_call_command(string? session_id) {
+			if (!is_enhanced_mode_enabled()) {
+				return "call";
+			}
+
+			ensure_initialized();
+
+			if (session_id == null) {
+				return generate_obfuscated_command();
+			}
+
+			if (!session_commands.has_key(session_id)) {
+				session_commands[session_id] = generate_obfuscated_command();
+			}
+
+			return session_commands[session_id];
+		}
+
+		/**
+		 * Get OK response for session
+		 * 获取会话的OK响应
+		 */
+		public static string get_ok_response(string? session_id) {
+			// Always return standard "ok" response as per requirement
+			// 根据要求始终返回标准"ok"响应
+				return "ok";
+		}
+
+		/**
+		 * Get dynamic protocol ID
+		 * 获取动态协议ID
+		 */
+		public static string get_dynamic_protocol_id() {
+			return generate_obfuscated_protocol();
+		}
+
+		/**
+		 * Check if protocol is valid
+		 * 检查协议是否有效
+		 */
+		public static bool is_valid_protocol(string protocol) {
+			if (!is_enhanced_mode_enabled()) {
+				return protocol == "frida:rpc";
+			}
+
+			ensure_initialized();
+
+			// Standard protocol is always valid
+			if (protocol == "frida:rpc") {
+				return true;
+			}
+
+			// Check session-specific protocols
+			foreach (var session_protocol in session_protocols.values) {
+				if (protocol == session_protocol) {
+					return true;
+				}
+			}
+
+			// Check if it matches our obfuscation pattern
+			return protocol.has_prefix("sys:") ||
+			       protocol.has_prefix("android:") ||
+			       protocol.has_prefix("linux:") ||
+			       protocol.has_prefix("proc:") ||
+			       protocol.has_prefix("dev:");
+		}
+
+		/**
+		 * Check if OK response is valid
+		 * 检查OK响应是否有效
+		 */
+		public static bool is_valid_ok_response(string status) {
+			// Only standard "ok" response is valid as per requirement
+			// 根据要求只有标准"ok"响应有效
+				return status == "ok";
+		}
+
+		/**
+		 * Forget session data
+		 * 忘记会话数据
+		 */
+		public static void forget_session(string session_id) {
+			ensure_initialized();
+
+			if (session_protocols != null) {
+				session_protocols.unset(session_id);
+			}
+			if (session_commands != null) {
+				session_commands.unset(session_id);
+			}
+		}
+
+		/**
+		 * Generate obfuscated protocol name
+		 * 生成混淆的协议名
+		 */
+		private static string generate_obfuscated_protocol() {
+			string[] prefixes = {"sys", "android", "linux", "proc", "dev"};
+			string[] suffixes = {"rpc", "ipc", "msg", "comm", "ctl"};
+
+			string prefix = prefixes[Random.int_range(0, prefixes.length)];
+			string suffix = suffixes[Random.int_range(0, suffixes.length)];
+
+			return "%s:%s".printf(prefix, suffix);
+		}
+
+		/**
+		 * Generate obfuscated command
+		 * 生成混淆的命令
+		 */
+		private static string generate_obfuscated_command() {
+			string[] commands = {"exec", "run", "invoke", "proc", "handle"};
+			return commands[Random.int_range(0, commands.length)];
+		}
+
+
+
+		/**
+		 * Protocol configuration file path
+		 * 协议配置文件路径
+		 */
+		public static string get_config_file_path() {
+			return "./fridmira_config.json";
+		}
+
+		/**
+		 * Save protocol configuration to file
+		 * 将协议配置保存到文件
+		 */
+		public static void save_protocol_config_to_file() {
+			// Ensure initialization for diagnostic commands
+			// 为诊断命令确保初始化
+			ensure_initialized();
+
+			try {
+				// Get current dynamic configuration
+				// 获取当前动态配置
+				string current_protocol = get_protocol_id(null);
+				string current_command = get_call_command(null);
+				string current_response = get_ok_response(null);
+
+				var json_builder = new Json.Builder();
+				json_builder
+					.begin_object()
+					.set_member_name("protocol_id")
+					.add_string_value(current_protocol)
+					.set_member_name("call_command")
+					.add_string_value(current_command)
+					.set_member_name("ok_response")
+					.add_string_value(current_response)
+					.set_member_name("timestamp")
+					.add_string_value(new DateTime.now_local().to_string())
+					.end_object();
+
+				string json_data = Json.to_string(json_builder.get_root(), true);
+				string config_file = get_config_file_path();
+
+				GLib.FileUtils.set_contents(config_file, json_data);
+			} catch (Error e) {
+				// Silently ignore file write errors to avoid breaking server startup
+				// 静默忽略文件写入错误，避免影响服务器启动
+			}
+		}
+
+		/**
+		 * Load protocol configuration from file (simplified for dynamic mode)
+		 * 从文件加载协议配置（为动态模式简化）
+		 */
+		public static bool load_protocol_config_from_file() {
+			// In dynamic generation mode, file loading is not needed
+			// 在动态生成模式下，不需要文件加载
+			// Configuration is generated on-demand
+			// 配置按需生成
+			return false;
+		}
+
+
+
+
+	}
+}
+
+/**
+ * FridMira RPC Protocol Diagnostic and Client Communication Tool
+ * FridMira RPC协议诊断和客户端通信工具
+ *
+ * This diagnostic tool provides essential information for FridMira-enhanced
+ * client configuration and troubleshooting. It helps setup and verify
+ * custom Frida clients that work with FridMira obfuscated servers.
+ *
+ * 此诊断工具为FridMira增强客户端配置和故障排除提供必要信息。
+ * 它帮助设置和验证与FridMira混淆服务器配合工作的定制Frida客户端。
+ */
+namespace Frida.FridMiraDiagnostics {
+	public class RpcProtocolDiagnostic {
+
+		/**
+		 * Get current protocol configuration for client setup
+		 * 获取客户端设置的当前协议配置
+		 *
+		 * This is the primary method for clients to get protocol information
+		 * needed to communicate with a FridMira-enhanced server.
+		 * 这是客户端获取与FridMira增强服务器通信所需协议信息的主要方法。
+		 */
+		public static string get_client_protocol_config() {
+			var config = new StringBuilder();
+
+			bool enhanced_enabled = FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+
+			config.append("=== FridMira Client Protocol Configuration ===\n");
+			config.append("Generated: %s\n\n".printf(new DateTime.now_local().to_string()));
+
+			config.append("Enhanced Mode: %s\n".printf(enhanced_enabled ? "ENABLED" : "DISABLED"));
+
+			if (enhanced_enabled) {
+				string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+				string call_command = FridMiraRpcProtocolEnhancer.get_call_command(null);
+				string ok_response = FridMiraRpcProtocolEnhancer.get_ok_response(null);
+
+				// Save configuration for future reference
+				// 保存配置以备将来参考
+				FridMiraRpcProtocolEnhancer.save_protocol_config_to_file();
+
+				config.append("\n[REQUIRED CLIENT SETTINGS]\n");
+				config.append("Protocol ID: '%s'\n".printf(protocol_id));
+				config.append("Call Command: '%s'\n".printf(call_command));
+				config.append("OK Response: '%s'\n".printf(ok_response));
+
+				config.append("\n[SAMPLE CLIENT CODE]\n");
+				config.append("Python Example:\n");
+				config.append("  import frida\n");
+				config.append("  # Configure FridMira protocol\n");
+				config.append("  frida.set_protocol_config({\n");
+				config.append("      'protocol_id': '%s',\n".printf(protocol_id));
+				config.append("      'call_command': '%s',\n".printf(call_command));
+				config.append("      'ok_response': '%s'\n".printf(ok_response));
+				config.append("  })\n\n");
+
+				config.append("JavaScript Example:\n");
+				config.append("  const frida = require('frida');\n");
+				config.append("  // Configure FridMira protocol\n");
+				config.append("  frida.setProtocolConfig({\n");
+				config.append("    protocolId: '%s',\n".printf(protocol_id));
+				config.append("    callCommand: '%s',\n".printf(call_command));
+				config.append("    okResponse: '%s'\n".printf(ok_response));
+				config.append("  });\n");
+			} else {
+				config.append("\n[STANDARD FRIDA MODE]\n");
+				config.append("Protocol ID: 'frida:rpc'\n");
+				config.append("Call Command: 'call'\n");
+				config.append("OK Response: 'ok'\n");
+				config.append("\nNote: Any standard Frida client can connect.\n");
+			}
+
+			return config.str;
+		}
+
+		/**
+		 * Comprehensive server status for troubleshooting
+		 * 用于故障排除的全面服务器状态
+		 */
+		public static string get_server_status() {
+			var status = new StringBuilder();
+
+			status.append("=== FridMira Server Status Report ===\n");
+			status.append("Generated: %s\n\n".printf(new DateTime.now_local().to_string()));
+
+			// Environment variables check
+			status.append("1. Environment Configuration:\n");
+			string? rpc_mode = GLib.Environment.get_variable("FRIDMIRA_RPC_MODE");
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			string? verbose_mode = GLib.Environment.get_variable("FRIDMIRA_VERBOSE");
+
+			status.append("   FRIDMIRA_MODE: %s\n".printf(global_mode ?? "NOT SET"));
+			status.append("   FRIDMIRA_RPC_MODE: %s\n".printf(rpc_mode ?? "NOT SET"));
+			status.append("   FRIDMIRA_VERBOSE: %s\n".printf(verbose_mode ?? "NOT SET"));
+			status.append("   Enhanced mode active: %s\n\n".printf(
+				FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled() ? "YES" : "NO"));
+
+			// Current protocol configuration
+			status.append("2. Active Protocol Configuration:\n");
+			if (FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+				string call_command = FridMiraRpcProtocolEnhancer.get_call_command(null);
+				string ok_response = FridMiraRpcProtocolEnhancer.get_ok_response(null);
+
+				// Save configuration for diagnostic purposes
+				// 保存配置以便诊断
+				FridMiraRpcProtocolEnhancer.save_protocol_config_to_file();
+
+				status.append("   Protocol ID: %s\n".printf(protocol_id));
+				status.append("   Call Command: %s\n".printf(call_command));
+				status.append("   OK Response: %s\n".printf(ok_response));
+				status.append("   Status: ENHANCED - Only FridMira clients can connect\n\n");
+			} else {
+				status.append("   Protocol ID: frida:rpc\n");
+				status.append("   Call Command: call\n");
+				status.append("   OK Response: ok\n");
+				status.append("   Status: STANDARD - Any Frida client can connect\n\n");
+			}
+
+			// RPC Client Integration
+			status.append("3. RPC Client Integration:\n");
+			if (RpcClient.enhancer != null) {
+				status.append("   Enhancer Status: ACTIVE\n");
+				status.append("   Enhancer Type: %s\n\n".printf(RpcClient.enhancer.get_type().name()));
+			} else {
+				status.append("   Enhancer Status: NOT CONFIGURED\n");
+				status.append("   Issue: RpcClient.enhancer is null\n\n");
+			}
+
+			// Server recommendations
+			status.append("4. Server Recommendations:\n");
+			if (!FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				status.append("   • Server running in standard mode - any Frida client can connect\n");
+				status.append("   • To enable enhanced security, set FRIDMIRA_MODE=1\n");
+			} else {
+				status.append("   • Server running in enhanced mode - only FridMira clients can connect\n");
+				status.append("   • Use get_client_protocol_config() to get client setup information\n");
+			}
+
+			return status.str;
+		}
+
+		/**
+		 * Export protocol configuration to JSON for programmatic use
+		 * 将协议配置导出为JSON以供程序使用
+		 */
+		public static string export_protocol_config_json() {
+			bool fridmira_enabled = FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+
+			string protocol_id;
+			string call_command;
+			string ok_response;
+
+			if (fridmira_enabled) {
+				// Get configuration directly from memory (always current)
+				// 直接从内存获取配置（始终是最新的）
+				protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+				call_command = FridMiraRpcProtocolEnhancer.get_call_command(null);
+				ok_response = FridMiraRpcProtocolEnhancer.get_ok_response(null);
+
+				// Save current configuration to file for future reference
+				// 将当前配置保存到文件以备将来参考
+				FridMiraRpcProtocolEnhancer.save_protocol_config_to_file();
+			} else {
+				protocol_id = "frida:rpc";
+				call_command = "call";
+				ok_response = "ok";
+			}
+
+			var json_builder = new Json.Builder();
+			json_builder
+				.begin_object()
+				.set_member_name("fridmira")
+				.add_boolean_value(fridmira_enabled)
+				.set_member_name("protocol")
+				.add_string_value(protocol_id)
+				.set_member_name("command")
+				.add_string_value(call_command)
+				.set_member_name("response")
+				.add_string_value(ok_response)
+				.end_object();
+
+			return Json.to_string(json_builder.get_root(), true);
+		}
+
+		/**
+		 * Quick compatibility check for client connections
+		 * 客户端连接的快速兼容性检查
+		 */
+		public static string check_client_compatibility(string client_protocol_id,
+				string client_call_command, string client_ok_response) {
+			var result = new StringBuilder();
+
+			result.append("=== Client Compatibility Check ===\n");
+
+			bool protocol_match = FridMiraRpcProtocolEnhancer.is_valid_protocol(client_protocol_id);
+			bool response_match = FridMiraRpcProtocolEnhancer.is_valid_ok_response(client_ok_response);
+
+			result.append("Client Protocol ID: '%s' - %s\n".printf(
+				client_protocol_id, protocol_match ? "VALID" : "INVALID"));
+			result.append("Client Call Command: '%s'\n".printf(client_call_command));
+			result.append("Client OK Response: '%s' - %s\n".printf(
+				client_ok_response, response_match ? "VALID" : "INVALID"));
+
+			if (protocol_match && response_match) {
+				result.append("\nCOMPATIBLE: Client should be able to connect\n");
+			} else {
+				result.append("\nINCOMPATIBLE: Client needs protocol update\n");
+				result.append("\nCorrect configuration:\n");
+				result.append("Protocol ID: %s\n".printf(
+					FridMiraRpcProtocolEnhancer.get_protocol_id(null)));
+				result.append("Call Command: %s\n".printf(
+					FridMiraRpcProtocolEnhancer.get_call_command(null)));
+				result.append("OK Response: %s\n".printf(
+					FridMiraRpcProtocolEnhancer.get_ok_response(null)));
+			}
+
+			return result.str;
+		}
+
+		/**
+		 * Generate client-server handshake test message
+		 * 生成客户端-服务器握手测试消息
+		 */
+		public static string generate_test_handshake() {
+			string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+			string call_command = FridMiraRpcProtocolEnhancer.get_call_command(null);
+
+			var request = new Json.Builder ();
+			request
+				.begin_array ()
+				.add_string_value (protocol_id)
+				.add_string_value ("test-handshake-001")
+				.add_string_value (call_command)
+				.add_string_value ("ping")
+				.begin_array ()
+				.end_array ()
+				.end_array ();
+
+			var full_request = new Json.Builder ();
+			full_request
+				.begin_object ()
+				.set_member_name ("type")
+				.add_string_value ("send")
+				.set_member_name ("payload")
+				.add_value (request.get_root ())
+				.end_object ();
+
+			return Json.to_string (full_request.get_root (), false);
+		}
+
+		/**
+		 * Show usage examples for server-side diagnostic commands
+		 * 显示服务器端诊断命令的使用示例
+		 */
+		public static string get_usage_examples() {
+			var examples = new StringBuilder();
+
+			examples.append("=== FridMira Server Diagnostic Commands ===\n\n");
+
+			examples.append("1. Get client protocol configuration:\n");
+			examples.append("   frida-server --show-config\n");
+			examples.append("   (Shows the exact protocol settings clients need)\n\n");
+
+			examples.append("2. Check server status and configuration:\n");
+			examples.append("   frida-server --show-status\n");
+			examples.append("   (Comprehensive server status report)\n\n");
+
+			examples.append("3. Export protocol config as JSON:\n");
+			examples.append("   frida-server --export-json\n");
+			examples.append("   (JSON format with easy-to-access fields)\n\n");
+
+			examples.append("4. Show usage examples:\n");
+			examples.append("   frida-server --show-examples\n");
+			examples.append("   (Display this help information)\n\n");
+
+			examples.append("5. Quick protocol access examples:\n");
+			examples.append("   # Easy access to protocol info:\n");
+			examples.append("   PROTOCOL=$(frida-server --export-json | jq -r '.protocol')\n");
+			examples.append("   COMMAND=$(frida-server --export-json | jq -r '.command')\n");
+			examples.append("   RESPONSE=$(frida-server --export-json | jq -r '.response')\n");
+			examples.append("   echo \"Protocol: $PROTOCOL, Command: $COMMAND, Response: $RESPONSE\"\n\n");
+
+			examples.append("6. Typical workflow:\n");
+			examples.append("   Step 1: Check current protocol settings\n");
+			examples.append("   frida-server --show-config\n\n");
+			examples.append("   Step 2: Start server with desired configuration\n");
+			examples.append("   frida-server --fridmira -l 0.0.0.0:27042\n\n");
+			examples.append("   Step 3: Configure client with the protocol settings\n");
+			examples.append("   (Use the protocol ID, call command, and OK response)\n\n");
+
+			examples.append("IMPORTANT NOTES:\n");
+			examples.append("• Diagnostic commands work independently of --fridmira flag\n");
+			examples.append("• Protocol settings are determined by server startup options\n");
+			examples.append("• Settings are fixed for each server process lifetime\n");
+			examples.append("• Use --fridmira flag when starting server for enhanced mode\n");
+			examples.append("• Standard Frida clients cannot connect to enhanced servers\n");
+
+			return examples.str;
+		}
+
+		/**
+		 * Quick protocol information summary
+		 * 快速协议信息摘要
+		 */
+		public static string get_protocol_summary() {
+			var summary = new StringBuilder();
+
+			bool enhanced_enabled = FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+
+			summary.append("=== FridMira Protocol Summary ===\n");
+			summary.append("Mode: %s\n".printf(enhanced_enabled ? "ENHANCED" : "STANDARD"));
+
+			if (enhanced_enabled) {
+				string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+				string call_command = FridMiraRpcProtocolEnhancer.get_call_command(null);
+				string ok_response = FridMiraRpcProtocolEnhancer.get_ok_response(null);
+
+				summary.append("Protocol: %s\n".printf(protocol_id));
+				summary.append("Command: %s\n".printf(call_command));
+				summary.append("Response: %s\n".printf(ok_response));
+				summary.append("Client Support: FridMira clients only\n");
+			} else {
+				summary.append("Protocol: frida:rpc\n");
+				summary.append("Command: call\n");
+				summary.append("Response: ok\n");
+				summary.append("Client Support: Any Frida client\n");
+			}
+
+			return summary.str;
+		}
+	}
+}
diff --git a/lib/mira/fridmira-symbol.vala b/lib/mira/fridmira-symbol.vala
new file mode 100644
index 00000000..36a7ed29
--- /dev/null
+++ b/lib/mira/fridmira-symbol.vala
@@ -0,0 +1,212 @@
+/**
+ * FridMira: Symbol Obfuscation Module
+ * FridMira: 符号混淆模块
+ *
+ * This module provides advanced symbol name obfuscation capabilities to
+ * replace Frida-related symbols with realistic system-like alternatives
+ * that blend in with native libraries and system components.
+ *
+ * 此模块提供高级符号名混淆能力，将Frida相关符号替换为仿系统的
+ * 替代品，与原生库和系统组件融为一体。
+ *
+ * Features:
+ * - Intelligent symbol filtering with blacklist approach
+ * - Realistic system-like symbol name generation
+ * - External configuration file support
+ * - Safe obfuscation that preserves critical entry points
+ *
+ * 功能特性：
+ * - 使用黑名单方法的智能符号过滤
+ * - 仿系统的符号名生成
+ * - 外部配置文件支持
+ * - 保护关键入口点的安全混淆
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraSymbolObfuscator: Advanced Symbol Name Obfuscation Engine
+	 * FridMira符号混淆器：高级符号名混淆引擎
+	 *
+	 * Generates realistic-looking symbol names that blend in with system
+	 * libraries and native Android/iOS components to avoid detection.
+	 * Uses intelligent filtering to only obfuscate Frida-related symbols
+	 * while preserving system-critical symbols for stability.
+	 *
+	 * 生成仿系统的符号名，与系统库和原生Android/iOS组件融为一体，避免检测。
+	 * 使用智能过滤只混淆Frida相关符号，同时保护系统关键符号以确保稳定性。
+	 */
+	public class FridMiraSymbolObfuscator {
+		// Symbol name component arrays for realistic generation
+		// 用于生成仿系统符号名的组件数组
+		private static string[] get_symbol_prefixes() {
+			return {
+				"_lib", "_sys", "_core", "_util", "_base", "_native", "_android",
+				"_ios", "_darwin", "_linux", "_gnu", "_glibc", "_musl"
+			};
+		}
+
+		private static string[] get_symbol_components() {
+			return {
+				"init", "start", "stop", "create", "destroy", "alloc", "free",
+				"open", "close", "read", "write", "send", "recv", "connect",
+				"bind", "listen", "accept", "process", "handle", "execute",
+				"invoke", "call", "return", "exit", "main", "entry", "cleanup",
+				"malloc", "calloc", "realloc", "mmap", "munmap", "dlopen"
+			};
+		}
+
+		private static string[] get_symbol_suffixes() {
+			return {
+				"", "_impl", "_native", "_jni", "_internal", "_handler",
+				"_mgr", "_svc", "_fn", "_proc", "_wrapper", "_bridge"
+			};
+		}
+
+		/**
+		 * Default Frida signature symbols (built-in blacklist)
+		 * 默认Frida特征符号（内置黑名单）
+		 */
+		private static string[] get_default_frida_signatures() {
+			return {
+				// Safe Frida signatures that can be obfuscated
+				// 可以安全混淆的Frida特征符号
+
+				// Frida server signatures / Frida服务器特征
+				"frida_server", "frida-server", "FRIDA_SERVER",
+				"FridaServer", "fridaServer",
+
+				// Frida gadget signatures / Frida gadget特征
+				"frida_gadget", "frida-gadget", "FRIDA_GADGET",
+				"FridaGadget", "fridaGadget",
+
+				// Frida core signatures / Frida核心特征
+				"frida_core", "frida-core", "FRIDA_CORE",
+				"FridaCore", "fridaCore",
+
+				// Frida script and RPC signatures / Frida脚本和RPC特征
+				"frida_rpc", "frida-rpc", "FRIDA_RPC",
+				"frida_script", "frida-script", "FRIDA_SCRIPT",
+				"FridaScript", "fridaScript",
+
+				// Frida session and device signatures / Frida会话和设备特征
+				"frida_session", "frida-session", "FRIDA_SESSION",
+				"frida_device", "frida-device", "FRIDA_DEVICE",
+				"FridaDevice", "fridaDevice",
+
+				// Frida process and spawn signatures / Frida进程和spawn特征
+				"frida_process", "frida-process", "FRIDA_PROCESS",
+				"frida_spawn", "frida-spawn", "FRIDA_SPAWN",
+
+				// Additional safe frida patterns / 额外的安全frida模式
+				"frida_version", "frida_build", "frida_config",
+				"frida_error", "frida_warning", "frida_debug"
+
+				// NOTE: Excluded critical entry points:
+				// 注意：排除了关键入口点：
+				// - frida_agent_main (entry point)
+				// - gum_init/gum_deinit (core initialization)
+				// - frida_init/frida_deinit (core initialization)
+			};
+		}
+
+		/**
+		 * Check if symbol obfuscation is enabled via environment variables
+		 * 通过环境变量检查是否启用符号混淆
+		 *
+		 * Priority order: FRIDMIRA_SYMBOL_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_SYMBOL_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? symbol_mode = GLib.Environment.get_variable("FRIDMIRA_SYMBOL_MODE");
+			if (symbol_mode != null) {
+				return symbol_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Check if a symbol should be obfuscated (simple blacklist mode)
+		 * 检查符号是否应该被混淆（简单黑名单模式）
+		 *
+		 * SIMPLE RULE: Only obfuscate if symbol contains Frida signatures
+		 * 简单规则：只有包含Frida特征的符号才混淆
+		 */
+		private static bool should_obfuscate_symbol(string original_symbol) {
+			// Check if symbol contains any Frida signature
+			// 检查符号是否包含任何Frida特征
+			foreach (string signature in get_default_frida_signatures()) {
+				if (original_symbol.contains(signature)) {
+					return true; // Safe to obfuscate
+				}
+			}
+
+			// Default: keep original (safe approach)
+			// 默认：保持原样（安全方法）
+			return false;
+		}
+
+		/**
+		 * Generate obfuscated symbol name using simple blacklist mode
+		 * 使用简单黑名单模式生成混淆的符号名
+		 *
+		 * SIMPLE APPROACH: Only obfuscate known Frida signatures
+		 * 简单方法：只混淆已知的Frida特征符号
+		 */
+		public static string obfuscate_symbol(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Blacklist check: only obfuscate Frida signature symbols
+			// 黑名单检查：只混淆Frida特征符号
+			if (!should_obfuscate_symbol(original)) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var symbol_prefixes = get_symbol_prefixes();
+			var symbol_components = get_symbol_components();
+			var symbol_suffixes = get_symbol_suffixes();
+
+			string prefix = symbol_prefixes[random.int_range(0, symbol_prefixes.length)];
+			string component = symbol_components[random.int_range(0, symbol_components.length)];
+			string suffix = symbol_suffixes[random.int_range(0, symbol_suffixes.length)];
+
+			return prefix + component + suffix;
+		}
+
+		/**
+		 * Public API to check if symbol obfuscation is active
+		 * 公共API检查符号混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get symbol obfuscation status information
+		 * 获取符号混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Symbol obfuscation: DISABLED";
+			}
+
+			string demo_symbol = obfuscate_symbol("frida_rpc_call");
+			return "Symbol obfuscation: ENABLED\n" +
+			       "  Demo: 'frida_rpc_call' → '%s'".printf(demo_symbol);
+		}
+	}
+}
diff --git a/lib/mira/fridmira-thread.vala b/lib/mira/fridmira-thread.vala
new file mode 100644
index 00000000..71f0a4a9
--- /dev/null
+++ b/lib/mira/fridmira-thread.vala
@@ -0,0 +1,167 @@
+/**
+ * FridMira: Thread Obfuscation Module
+ * FridMira: 线程混淆模块
+ *
+ * This module provides thread name masking capabilities to replace
+ * detectable thread names like "frida-server-main-loop" with realistic
+ * system-like thread names that blend in with legitimate processes.
+ *
+ * 此模块提供线程名掩盖能力，将可检测的线程名如"frida-server-main-loop"
+ * 替换为仿系统的线程名，与合法进程融为一体。
+ *
+ * Features:
+ * - Realistic thread name generation mimicking system threads
+ * - Process-specific thread naming patterns
+ * - Dynamic thread name obfuscation at runtime
+ * - Thread pool and worker thread masquerading
+ *
+ * 功能特性：
+ * - 模仿系统线程的仿真线程名生成
+ * - 进程特定的线程命名模式
+ * - 运行时动态线程名混淆
+ * - 线程池和工作线程伪装
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMiraThreadObfuscator: Thread Name Masking Engine
+	 * FridMira线程混淆器：线程名掩盖引擎
+	 *
+	 * Replaces detectable thread names with realistic system-like thread names
+	 * that appear as legitimate system components to avoid detection by thread
+	 * scanning tools and process analysis.
+	 *
+	 * 将可检测的线程名替换为仿系统的线程名，看起来像合法的系统组件，
+	 * 避免被线程扫描工具和进程分析检测。
+	 */
+	public class FridMiraThreadObfuscator {
+		// Thread name component arrays for realistic generation
+		// 用于生成仿系统线程名的组件数组
+		private static string[] get_thread_prefixes() {
+			return {
+				"thread", "worker", "task", "job", "service", "handler", "process",
+				"daemon", "monitor", "watcher", "timer", "scheduler", "executor",
+				"async", "sync", "pool", "queue", "mgmt", "ctrl", "event"
+			};
+		}
+
+		private static string[] get_thread_components() {
+			return {
+				"main", "bg", "io", "net", "ui", "core", "util", "sys", "mgmt",
+				"ctrl", "data", "event", "signal", "async", "sync", "pool",
+				"work", "task", "job", "svc", "proc", "loop", "run", "exec"
+			};
+		}
+
+		private static string[] get_thread_suffixes() {
+			return {
+				"", "-1", "-2", "-pool", "-mgr", "-svc", "-loop", "-proc",
+				"-worker", "-handler", "-monitor", "-ctrl", "-th", "-0", "-bg"
+			};
+		}
+
+		/**
+		 * Check if thread name obfuscation is enabled
+		 * 检查是否启用线程名混淆
+		 *
+		 * Priority order: FRIDMIRA_THREAD_MODE > FRIDMIRA_MODE > default(disabled)
+		 * 优先级顺序：FRIDMIRA_THREAD_MODE > FRIDMIRA_MODE > 默认(禁用)
+		 */
+		private static bool is_mode_enabled() {
+			// Check specific feature flag first
+			// 优先检查功能开关
+			string? thread_mode = GLib.Environment.get_variable("FRIDMIRA_THREAD_MODE");
+			if (thread_mode != null) {
+				return thread_mode == "1";
+			}
+
+			// Fall back to global flag (default disabled)
+			// 回退到全局开关（默认禁用）
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Generate realistic thread name that blends with system threads
+		 * 生成与系统线程融合的仿系统线程名
+		 *
+		 * Creates thread names that look like legitimate system components
+		 * to avoid detection by thread scanning tools and process monitors.
+		 * 创建看起来像合法系统组件的线程名，避免被线程扫描工具和进程监控检测。
+		 */
+		public static string obfuscate_thread_name(string original) {
+			if (!is_mode_enabled()) {
+				return original;
+			}
+
+			// Generate deterministic but unique seed
+			// 生成确定性但唯一的种子
+			uint32 seed = (uint32)(GLib.get_real_time() % 1000000) ^ original.hash();
+			var random = new Rand.with_seed(seed);
+
+			var thread_prefixes = get_thread_prefixes();
+			var thread_components = get_thread_components();
+			var thread_suffixes = get_thread_suffixes();
+
+			string prefix = thread_prefixes[random.int_range(0, thread_prefixes.length)];
+			string component = thread_components[random.int_range(0, thread_components.length)];
+			string suffix = thread_suffixes[random.int_range(0, thread_suffixes.length)];
+
+			return prefix + "-" + component + suffix;
+		}
+
+		/**
+		 * Generate thread name for specific thread types
+		 * 为特定线程类型生成线程名
+		 *
+		 * Creates contextually appropriate thread names based on thread purpose.
+		 * 根据线程用途创建上下文适当的线程名。
+		 */
+		public static string generate_contextual_thread_name(string thread_type) {
+			if (!is_mode_enabled()) {
+				return thread_type;
+			}
+
+			switch (thread_type.down()) {
+				case "main":
+				case "server":
+					return "service-main";
+				case "worker":
+				case "pool":
+					return "worker-pool";
+				case "io":
+				case "network":
+					return "io-handler";
+				case "monitor":
+				case "watcher":
+					return "sys-monitor";
+				default:
+					return obfuscate_thread_name(thread_type);
+			}
+		}
+
+		/**
+		 * Public API to check if thread obfuscation is active
+		 * 公共API检查线程混淆是否激活
+		 */
+		public static bool is_enhanced_mode_enabled() {
+			return is_mode_enabled();
+		}
+
+		/**
+		 * Get thread obfuscation status information
+		 * 获取线程混淆状态信息
+		 */
+		public static string get_obfuscation_status_info() {
+			if (!is_mode_enabled()) {
+				return "Thread obfuscation: DISABLED";
+			}
+
+			string demo_thread = obfuscate_thread_name("frida-server-main-loop");
+			return "Thread obfuscation: ENABLED\n" +
+			       "  Demo: 'frida-server-main-loop' → '%s'".printf(demo_thread);
+		}
+	}
+}
diff --git a/lib/mira/fridmira.vala b/lib/mira/fridmira.vala
new file mode 100644
index 00000000..8cbb3b00
--- /dev/null
+++ b/lib/mira/fridmira.vala
@@ -0,0 +1,314 @@
+/**
+ * FridMira: Frida Anti-Detection Framework Core
+ * FridMira: Frida 反检测框架核心
+ *
+ * This is the core framework module that provides centralized initialization,
+ * configuration management, and coordination of all FridMira anti-detection
+ * components. It acts as the main entry point and orchestrator for the
+ * modular obfuscation system.
+ *
+ * 这是核心框架模块，提供集中的初始化、配置管理和所有FridMira反检测
+ * 组件的协调。它作为模块化混淆系统的主要入口点和协调器。
+ *
+ * Architecture:
+ * - Bootstrap initialization for early-stage protection
+ * - Modular component initialization and management
+ * - Environment variable configuration system
+ * - Centralized logging and status reporting
+ * - Framework lifecycle management
+ *
+ * 架构：
+ * - 用于早期保护的Bootstrap初始化
+ * - 模块化组件初始化和管理
+ * - 环境变量配置系统
+ * - 集中式日志记录和状态报告
+ * - 框架生命周期管理
+ */
+
+using Gee;
+
+namespace Frida {
+	/**
+	 * FridMira: Core Framework Manager
+	 * FridMira: 核心框架管理器
+	 *
+	 * The main framework class that coordinates all FridMira modules and
+	 * provides centralized initialization, configuration, and lifecycle
+	 * management for the anti-detection system.
+	 *
+	 * 协调所有FridMira模块的主框架类，为反检测系统提供集中的
+	 * 初始化、配置和生命周期管理。
+	 */
+	public class FridMira {
+		// Framework state tracking
+		// 框架状态跟踪
+		private static bool _bootstrap_initialized = false;
+		private static bool _framework_initialized = false;
+		private static bool _verbose_mode = false;
+
+		/**
+		 * FridMira Bootstrap Initialization
+		 * FridMira Bootstrap初始化
+		 *
+		 * This method provides lightweight early initialization that sets up
+		 * basic environment variables and prepares obfuscated names before
+		 * any system components are loaded.
+		 *
+		 * 此方法提供轻量级的早期初始化，在任何系统组件加载之前
+		 * 设置基本环境变量并准备混淆名称。
+		 */
+		public static void bootstrap_initialization(bool verbose = false) {
+			if (_bootstrap_initialized) {
+				return; // Already initialized
+			}
+
+			_verbose_mode = verbose;
+
+			// Set bootstrap markers and basic environment variables
+			// 设置bootstrap标记和基础环境变量
+			GLib.Environment.set_variable("FRIDMIRA_MODE", "1", true);
+			GLib.Environment.set_variable("FRIDMIRA_BOOTSTRAP", "1", true);
+
+			// Prepare obfuscated temporary directory name
+			// 准备混淆的临时目录名
+			string obfuscated_temp_name = FridMiraFileSystemObfuscator.generate_temp_directory_name();
+			GLib.Environment.set_variable("FRIDMIRA_TEMP_DIR_NAME", obfuscated_temp_name, true);
+
+			_bootstrap_initialized = true;
+
+			if (verbose) {
+				stdout.printf("FridMira: Bootstrap complete\n");
+			}
+		}
+
+		/**
+		 * Initialize FridMira Anti-Detection Framework
+		 * 初始化FridMira反检测框架
+		 *
+		 * This function sets up the complete FridMira framework with all
+		 * obfuscation modules. Components are automatically activated based
+		 * on environment variable configuration.
+		 *
+		 * 此函数设置完整的FridMira框架及所有混淆模块。组件根据环境变量
+		 * 配置自动激活。
+		 *
+		 * This function is designed to be called from control-service.vala
+		 * after preload completion to implement the "post-preload initialization"
+		 * strategy.
+		 *
+		 * 此函数设计为在Preload完成后从control-service.vala调用，
+		 * 以实现"预加载后初始化"策略。
+		 *
+		 * @internal This function is for internal FridMira use only and should
+		 * not be exposed in the public Frida API.
+		 */
+		public static void initialize_fridmira_framework(bool verbose = false) {
+			if (_framework_initialized) {
+				return; // Already initialized
+			}
+
+			_verbose_mode = verbose;
+
+			if (verbose) {
+				stdout.printf("FridMira: Initializing protection modules...\n");
+			}
+
+			// Initialize all modules
+			// 初始化所有模块
+			initialize_symbol_obfuscation(verbose);
+			initialize_thread_obfuscation(verbose);
+			initialize_rpc_protocol_enhancement(verbose);
+			initialize_file_system_obfuscation(verbose);
+			initialize_memory_obfuscation(verbose);
+			initialize_agent_library_management(verbose);
+
+			_framework_initialized = true;
+
+			if (verbose) {
+				stdout.printf("FridMira: All modules initialized successfully\n");
+			}
+		}
+
+		/**
+		 * Initialize Symbol Obfuscation Module
+		 * 初始化符号混淆模块
+		 */
+		private static void initialize_symbol_obfuscation(bool verbose) {
+			if (FridMiraSymbolObfuscator.is_enhanced_mode_enabled()) {
+				if (verbose) {
+					// Show actual obfuscated symbol example
+					string sample_original = "frida_rpc_call";
+					string sample_obfuscated = FridMiraSymbolObfuscator.obfuscate_symbol(sample_original);
+					stdout.printf("FridMira:   [✓] Symbol Obfuscation (%s)\n", sample_obfuscated);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira:   [✗] Symbol Obfuscation (disabled)\n");
+			}
+		}
+
+		/**
+		 * Initialize Thread Obfuscation Module
+		 * 初始化线程混淆模块
+		 */
+		private static void initialize_thread_obfuscation(bool verbose) {
+			if (FridMiraThreadObfuscator.is_enhanced_mode_enabled()) {
+				if (verbose) {
+					// Show actual obfuscated thread name
+					string sample_original = "frida-server-loop";
+					string sample_obfuscated = FridMiraThreadObfuscator.obfuscate_thread_name(sample_original);
+					stdout.printf("FridMira:   [✓] Thread Obfuscation (%s)\n", sample_obfuscated);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira:   [✗] Thread Obfuscation (disabled)\n");
+			}
+		}
+
+		/**
+		 * Initialize RPC Protocol Enhancement Module
+		 * 初始化RPC协议增强模块
+		 */
+		private static void initialize_rpc_protocol_enhancement(bool verbose) {
+			if (FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled()) {
+				FridMiraRpcProtocolEnhancer.init();
+
+				// Only set enhancer if not already set (avoid conflicts with control-service)
+				// 只在尚未设置时设置增强器（避免与control-service冲突）
+				if (Frida.RpcClient.enhancer == null) {
+					Frida.RpcClient.enhancer = new Frida.FridMiraRpcEnhancerAdapter();
+					if (verbose) {
+						string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+						string call_cmd = FridMiraRpcProtocolEnhancer.get_call_command(null);
+						stdout.printf ("FridMira:   [✓] RPC Protocol Enhancement (%s + %s)\n", protocol_id, call_cmd);
+					}
+				} else if (verbose) {
+					string protocol_id = FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+					string call_cmd = FridMiraRpcProtocolEnhancer.get_call_command(null);
+					stdout.printf ("FridMira:   [✓] RPC Protocol Enhancement (%s + %s) [already set]\n", protocol_id, call_cmd);
+				}
+			} else if (verbose) {
+				stdout.printf ("FridMira:   [✗] RPC Protocol Enhancement (disabled)\n");
+			}
+		}
+
+		/**
+		 * Initialize File System Obfuscation Module
+		 * 初始化文件系统混淆模块
+		 */
+		private static void initialize_file_system_obfuscation(bool verbose) {
+			if (FridMiraFileSystemObfuscator.is_enhanced_mode_enabled()) {
+				if (verbose) {
+					// Show actual generated file names
+					string sample_lib = FridMiraFileSystemObfuscator.generate_lib_name();
+					string sample_socket = FridMiraFileSystemObfuscator.generate_realistic_socket_name();
+					stdout.printf("FridMira:   [✓] File System Obfuscation (%s, %s)\n", sample_lib, sample_socket);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira:   [✗] File System Obfuscation (disabled)\n");
+			}
+		}
+
+		/**
+		 * Initialize Memory Obfuscation Module
+		 * 初始化内存混淆模块
+		 */
+		private static void initialize_memory_obfuscation(bool verbose) {
+			if (FridMiraMemoryObfuscator.is_enhanced_mode_enabled()) {
+				if (verbose) {
+					// Show actual obfuscated memory identifier
+					string sample_original = "frida_gum_heap";
+					string sample_obfuscated = FridMiraMemoryObfuscator.obfuscate_memory_identifier(sample_original);
+					stdout.printf("FridMira:   [✓] Memory Obfuscation (%s)\n", sample_obfuscated);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira:   [✗] Memory Obfuscation (disabled)\n");
+			}
+		}
+
+		/**
+		 * Initialize Agent Library Management Module
+		 * 初始化Agent库管理模块
+		 */
+		private static void initialize_agent_library_management(bool verbose) {
+			if (FridMiraAgentLibraryManager.is_enhanced_mode_enabled()) {
+				if (verbose) {
+					// Show actual obfuscated agent name
+					string agent_name = FridMiraAgentLibraryManager.get_obfuscated_agent_name();
+					stdout.printf("FridMira:   [✓] Agent Library Management (%s.so)\n", agent_name);
+				}
+			} else if (verbose) {
+				stdout.printf("FridMira:   [✗] Agent Library Management (disabled)\n");
+			}
+		}
+
+		/**
+		 * Get framework initialization status
+		 * 获取框架初始化状态
+		 */
+		public static bool is_framework_initialized() {
+			return _framework_initialized;
+		}
+
+		/**
+		 * Get bootstrap initialization status
+		 * 获取bootstrap初始化状态
+		 */
+		public static bool is_bootstrap_initialized() {
+			return _bootstrap_initialized;
+		}
+
+		/**
+		 * Check if FridMira is globally enabled
+		 * 检查FridMira是否全局启用
+		 */
+		public static bool is_globally_enabled() {
+			string? global_mode = GLib.Environment.get_variable("FRIDMIRA_MODE");
+			return (global_mode == "1");
+		}
+
+		/**
+		 * Get comprehensive framework status information
+		 * 获取全面的框架状态信息
+		 */
+		public static string get_framework_status() {
+			var status = new StringBuilder();
+
+			status.append("FridMira Framework Status:\n");
+			status.append("  Bootstrap initialized: %s\n".printf(_bootstrap_initialized ? "YES" : "NO"));
+			status.append("  Framework initialized: %s\n".printf(_framework_initialized ? "YES" : "NO"));
+			status.append("  Globally enabled: %s\n".printf(is_globally_enabled() ? "YES" : "NO"));
+			status.append("  Verbose mode: %s\n".printf(_verbose_mode ? "YES" : "NO"));
+
+			if (_framework_initialized) {
+				status.append("\nModule Status:\n");
+				status.append("  Symbol Obfuscation: %s\n".printf(FridMiraSymbolObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Thread Obfuscation: %s\n".printf(FridMiraThreadObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  RPC Enhancement: %s\n".printf(FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  File System Obfuscation: %s\n".printf(FridMiraFileSystemObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Memory Obfuscation: %s\n".printf(FridMiraMemoryObfuscator.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+				status.append("  Agent Library Management: %s".printf(FridMiraAgentLibraryManager.is_enhanced_mode_enabled() ? "ACTIVE" : "INACTIVE"));
+			}
+
+			return status.str;
+		}
+
+		/**
+		 * Cleanup framework resources
+		 * 清理框架资源
+		 */
+		public static void cleanup_framework() {
+			// Cleanup Agent library files
+			// 清理Agent库文件
+			FridMiraAgentLibraryManager.cleanup_agent_files();
+
+			// Reset framework state
+			// 重置框架状态
+			_framework_initialized = false;
+			_bootstrap_initialized = false;
+			_verbose_mode = false;
+
+			if (_verbose_mode) {
+				stdout.printf("FridMira: Framework cleanup completed\n");
+			}
+		}
+	}
+}
-- 
2.45.1.windows.1


From 57e30c8ac17e047b939d9c4b33c8ead59cd1da06 Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Thu, 12 Jun 2025 17:38:39 +0800
Subject: [PATCH 4/6] FridMira: Add RPC protocol enhancement with adaptive dual
 protocol support - Fix protocol detection logic

---
 lib/base/rpc.vala | 222 ++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 217 insertions(+), 5 deletions(-)

diff --git a/lib/base/rpc.vala b/lib/base/rpc.vala
index c465452..2ec85bf 100644
--- a/lib/base/rpc.vala
+++ b/lib/base/rpc.vala
@@ -1,4 +1,195 @@
 namespace Frida {
+	// FridMira Protocol Enhancement - Independent Implementation
+	// 独立的协议增强实现，避免与其他模块冲突
+	
+	public enum FridMiraProtocolMode {
+		STANDARD,    // 标准Frida协议
+		DYNAMIC,     // 动态随机协议  
+		CUSTOM       // 自定义协议
+	}
+	
+	public class FridMiraProtocolManager {
+		private static FridMiraProtocolMode _mode = FridMiraProtocolMode.DYNAMIC;
+		private static string _protocol_id = "frida:rpc";
+		private static string _dynamic_protocol_id = "";
+		private static string _call_command = "call";
+		private static string _ok_response = "ok";
+		private static string _dynamic_call_command = "";
+		private static string _dynamic_ok_response = "";
+		private static bool _initialized = false;
+		
+		// 会话协议记忆 - 记住每个连接使用的协议类型
+		private static Gee.HashMap<string, string> _session_protocols = new Gee.HashMap<string, string>();
+		private static Gee.HashMap<string, string> _session_call_commands = new Gee.HashMap<string, string>();
+		private static Gee.HashMap<string, string> _session_ok_responses = new Gee.HashMap<string, string>();
+		
+		// 预定义协议词库 - 伪装成性能相关术语
+		private static string[] PROTOCOL_WORDS = {
+			"perf", "opt", "boost", "turbo", "fast", "speed", "cache", "mem"
+		};
+		
+		private static string[] COMMAND_WORDS = {
+			"exec", "run", "proc", "task", "job", "work", "op", "act"
+		};
+		
+		private static string[] RESPONSE_WORDS = {
+			"done", "ready", "good", "pass", "yes", "ack", "fin", "end"
+		};
+		
+		public static void initialize() {
+			if (_initialized) return;
+			
+			// 读取环境变量配置 - 与FridMira变量统一命名
+			string? mode_env = Environment.get_variable("FRIDMIRA_PRC");
+			string? custom_protocol = Environment.get_variable("FRIDMIRA_PRC_ID");
+			string? custom_call = Environment.get_variable("FRIDMIRA_PRC_CALL");
+			string? custom_ok = Environment.get_variable("FRIDMIRA_PRC_OK");
+			
+			// 解析协议模式
+			if (mode_env != null) {
+				switch (mode_env.down()) {
+					case "standard":
+						_mode = FridMiraProtocolMode.STANDARD;
+						break;
+					case "dynamic":
+						_mode = FridMiraProtocolMode.DYNAMIC;
+						break;
+					case "custom":
+						_mode = FridMiraProtocolMode.CUSTOM;
+						break;
+					default:
+						_mode = FridMiraProtocolMode.DYNAMIC;
+						break;
+				}
+			}
+			
+			// 生成动态协议标识符
+			if (_mode == FridMiraProtocolMode.DYNAMIC) {
+				generate_dynamic_protocols();
+			} else if (_mode == FridMiraProtocolMode.CUSTOM) {
+				_dynamic_protocol_id = custom_protocol ?? "custom:rpc";
+				_dynamic_call_command = custom_call ?? "invoke";
+				_dynamic_ok_response = custom_ok ?? "success";
+			}
+			
+			_initialized = true;
+		}
+		
+		private static void generate_dynamic_protocols() {
+			// 基于时间戳和进程ID生成动态协议
+			int64 timestamp = get_real_time() / 1000000; // 秒级时间戳
+			int pid = (int)Posix.getpid();
+			
+			// 生成伪随机种子
+			uint32 seed = (uint32)(timestamp ^ pid);
+			Random.set_seed(seed);
+			
+			// 选择随机协议词
+			string protocol_word = PROTOCOL_WORDS[Random.int_range(0, PROTOCOL_WORDS.length)];
+			string call_word = COMMAND_WORDS[Random.int_range(0, COMMAND_WORDS.length)];
+			string ok_word = RESPONSE_WORDS[Random.int_range(0, RESPONSE_WORDS.length)];
+			
+			// 添加动态后缀
+			string suffix = "%04x".printf(Random.int_range(0x1000, 0xFFFF));
+			
+			_dynamic_protocol_id = "%s%s:rpc".printf(protocol_word, suffix);
+			_dynamic_call_command = "%s%s".printf(call_word, suffix[0:2]);
+			_dynamic_ok_response = "%s%s".printf(ok_word, suffix[2:4]);
+		}
+		
+		// 自适应协议选择 - 根据会话记忆或默认策略
+		public static string get_protocol_id(string? session_id = null) {
+			if (!_initialized) initialize();
+			
+			if (session_id != null && _session_protocols.has_key(session_id)) {
+				return _session_protocols[session_id];
+			}
+			
+			// 默认使用动态协议发送（增强客户端优先）
+			return (_mode == FridMiraProtocolMode.STANDARD) ? _protocol_id : _dynamic_protocol_id;
+		}
+		
+		public static string get_call_command(string? session_id = null) {
+			if (!_initialized) initialize();
+			
+			if (session_id != null && _session_call_commands.has_key(session_id)) {
+				return _session_call_commands[session_id];
+			}
+			
+			return (_mode == FridMiraProtocolMode.STANDARD) ? _call_command : _dynamic_call_command;
+		}
+		
+		public static string get_ok_response(string? session_id = null) {
+			if (!_initialized) initialize();
+			
+			if (session_id != null && _session_ok_responses.has_key(session_id)) {
+				return _session_ok_responses[session_id];
+			}
+			
+			return (_mode == FridMiraProtocolMode.STANDARD) ? _ok_response : _dynamic_ok_response;
+		}
+		
+		// 记录会话协议类型 - 实现协议自适应
+		public static void remember_session_protocol(string session_id, string protocol) {
+			if (!_initialized) initialize();
+			
+			if (protocol == _protocol_id) {
+				// 标准客户端 - 记住使用标准协议
+				_session_protocols[session_id] = _protocol_id;
+				_session_call_commands[session_id] = _call_command;
+				_session_ok_responses[session_id] = _ok_response;
+			} else if (protocol == _dynamic_protocol_id) {
+				// 增强客户端 - 记住使用动态协议
+				_session_protocols[session_id] = _dynamic_protocol_id;
+				_session_call_commands[session_id] = _dynamic_call_command;
+				_session_ok_responses[session_id] = _dynamic_ok_response;
+			}
+		}
+		
+		// 清理会话记忆
+		public static void forget_session(string session_id) {
+			_session_protocols.unset(session_id);
+			_session_call_commands.unset(session_id);
+			_session_ok_responses.unset(session_id);
+		}
+		
+		// 获取当前可用的动态协议ID（用于协议检测）
+		public static string get_dynamic_protocol_id() {
+			if (!_initialized) initialize();
+			return _dynamic_protocol_id;
+		}
+		
+		// 双协议支持：检查是否为有效协议标识符
+		public static bool is_valid_protocol(string protocol) {
+			if (!_initialized) initialize();
+			
+			// 始终支持标准协议（向后兼容）
+			if (protocol == _protocol_id) return true;
+			
+			// 支持动态协议（如果启用）
+			if (_mode != FridMiraProtocolMode.STANDARD && protocol == _dynamic_protocol_id) {
+				return true;
+			}
+			
+			return false;
+		}
+		
+		// 双协议支持：检查是否为有效响应状态
+		public static bool is_valid_ok_response(string status) {
+			if (!_initialized) initialize();
+			
+			// 始终支持标准响应
+			if (status == _ok_response) return true;
+			
+			// 支持动态响应（如果启用）
+			if (_mode != FridMiraProtocolMode.STANDARD && status == _dynamic_ok_response) {
+				return true;
+			}
+			
+			return false;
+		}
+	}
+
 	public sealed class RpcClient : Object {
 		public weak RpcPeer peer {
 			get;
@@ -6,9 +197,17 @@ namespace Frida {
 		}
 
 		private Gee.HashMap<string, PendingResponse> pending_responses = new Gee.HashMap<string, PendingResponse> ();
+		private string _session_id;
 
 		public RpcClient (RpcPeer peer) {
 			Object (peer: peer);
+			// 生成唯一会话ID用于协议记忆
+			_session_id = Uuid.string_random();
+		}
+		
+		~RpcClient() {
+			// 清理会话协议记忆
+			FridMiraProtocolManager.forget_session(_session_id);
 		}
 
 		public async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable) throws Error, IOError {
@@ -17,9 +216,9 @@ namespace Frida {
 			var request = new Json.Builder ();
 			request
 				.begin_array ()
-				.add_string_value ("frida:rpc")
+				.add_string_value (FridMiraProtocolManager.get_protocol_id(_session_id))
 				.add_string_value (request_id)
-				.add_string_value ("call")
+				.add_string_value (FridMiraProtocolManager.get_call_command(_session_id))
 				.add_string_value (method)
 				.begin_array ();
 			foreach (var arg in args)
@@ -70,7 +269,17 @@ namespace Frida {
 		}
 
 		public bool try_handle_message (string json) {
-			if (json.index_of ("\"frida:rpc\"") == -1)
+			// 双协议支持：检查标准协议或动态协议
+			bool has_standard = json.index_of ("\"frida:rpc\"") != -1;
+			bool has_dynamic = false;
+			
+			// 检查是否包含动态协议
+			string dynamic_protocol = FridMiraProtocolManager.get_dynamic_protocol_id();
+			if (dynamic_protocol != "" && dynamic_protocol != "frida:rpc") {
+				has_dynamic = json.index_of ("\"" + dynamic_protocol + "\"") != -1;
+			}
+			
+			if (!has_standard && !has_dynamic)
 				return false;
 
 			var parser = new Json.Parser ();
@@ -99,9 +308,12 @@ namespace Frida {
 				return false;
 
 			string? type = rpc_message.get_element (0).get_string ();
-			if (type == null || type != "frida:rpc")
+			if (type == null || !FridMiraProtocolManager.is_valid_protocol(type))
 				return false;
 
+			// 协议自适应：记住客户端使用的协议类型
+			FridMiraProtocolManager.remember_session_protocol(_session_id, type);
+
 			var request_id_value = rpc_message.get_element (1);
 			if (request_id_value.get_value_type () != typeof (string))
 				return false;
@@ -112,7 +324,7 @@ namespace Frida {
 				return false;
 
 			var status = rpc_message.get_string_element (2);
-			if (status == "ok")
+			if (FridMiraProtocolManager.is_valid_ok_response(status))
 				response.complete_with_result (rpc_message.get_element (3));
 			else
 				response.complete_with_error (new Error.NOT_SUPPORTED (rpc_message.get_string_element (3)));
-- 
2.45.1.windows.1


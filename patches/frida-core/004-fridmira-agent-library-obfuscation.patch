From b15e75b2b0f582a3e28671252f79d10fbf5ba2b6 Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 17:01:27 +0800
Subject: [PATCH 004/006] FridMira Agent Library Management Module

---
 src/agent-container.vala              |  31 ++++++-
 src/host-session-service.vala         |  58 +++++++++++++
 src/linux/linux-host-session.vala     | 120 +++++++++++++++++++++++++-
 src/windows/windows-host-session.vala |  19 ++--
 4 files changed, 216 insertions(+), 12 deletions(-)

diff --git a/src/agent-container.vala b/src/agent-container.vala
index eecfa1f6..c4244aaa 100644
--- a/src/agent-container.vala
+++ b/src/agent-container.vala
@@ -21,12 +21,34 @@ namespace Frida {
 		public static async AgentContainer create (string agent_filename, Cancellable? cancellable) throws Error, IOError {
 			var container = new AgentContainer ();
 
+			// FridMira: Agent library obfuscation (DISABLED by default for compatibility)
+			// FridMira: Agent库混淆（默认禁用以确保兼容性）
+			// Only activated when FRIDMIRA_AGENT_MODE=1 is explicitly set
+			// 只有明确设置FRIDMIRA_AGENT_MODE=1时才激活
+			string actual_agent_path = agent_filename;
+
 			try {
-				container.module = new Module (agent_filename, 0);
+				// This function checks internally if Agent obfuscation is enabled
+				// 此函数内部检查是否启用Agent混淆
+				actual_agent_path = FridMiraAgentLibraryManager.create_obfuscated_agent_copy(agent_filename);
+			} catch (Error e) {
+				// Graceful fallback - no impact on standard Frida operation
+				// 优雅回退 - 不影响标准Frida操作
+				if (Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+					stderr.printf("FridMira: Agent obfuscation failed, using standard path: %s\n", e.message);
+				}
+			}
+
+			try {
+				container.module = new Module (actual_agent_path, 0);
 			} catch (ModuleError e) {
 				throw new Error.PERMISSION_DENIED ("%s", e.message);
 			}
 
+			// FridMira: Resolve obfuscated Agent entry point symbol
+			// FridMira: 解析混淆的Agent入口点符号
+			// Standard Agent entry point lookup - symbol obfuscation requires compile-time patching
+			// 标准Agent入口点查找 - 符号混淆需要编译时补丁
 			void * main_func_symbol;
 			var main_func_found = container.module.symbol ("frida_agent_main", out main_func_symbol);
 			assert (main_func_found);
@@ -100,6 +122,13 @@ namespace Frida {
 #endif
 
 			module = null;
+
+			// FridMira: Clean up obfuscated Agent library files for complete stealth
+			// FridMira: Safe cleanup of Agent resources (no-op if obfuscation disabled)
+			// FridMira: 安全清理Agent资源（如果混淆禁用则无操作）
+			// Only cleans up if Agent obfuscation was actually used
+			// 只有在实际使用Agent混淆时才清理
+			FridMiraAgentLibraryManager.cleanup_agent_files();
 		}
 
 		private void start_worker_thread () {
diff --git a/src/host-session-service.vala b/src/host-session-service.vala
index b7a0c167..8a7862ca 100644
--- a/src/host-session-service.vala
+++ b/src/host-session-service.vala
@@ -1510,21 +1510,52 @@ namespace Frida {
 			}
 			ensure_request = new Promise<bool> ();
 
+			// FridMira: Temporarily disable RPC obfuscation for InternalAgent loading
+			// FridMira: 为InternalAgent加载临时禁用RPC混淆
+			var original_enhancer = RpcClient.enhancer;
+			RpcClient.enhancer = null;
+
+			// FridMira DEBUG: Add detailed logging for ensure_loaded process
+			// FridMira 调试：为ensure_loaded过程添加详细日志
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Starting ensure_unloaded\\n");
 				yield ensure_unloaded (cancellable);
 
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Getting target PID\\n");
 				target_pid = yield get_target_pid (cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Got target PID: %u\\n", target_pid);
 
 				try {
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Attaching to target process\\n");
 					session_id = yield host_session.attach (target_pid, attach_options, cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Attached successfully\\n");
 
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Linking agent session\\n");
 					session = yield host_session.link_agent_session (session_id, (AgentMessageSink) this, cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Agent session linked\\n");
 
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading source\\n");
 					string? source = yield load_source (cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Source loaded, length: %d\\n", source != null ? source.length : 0);
+
 					if (source != null) {
 						var options = new ScriptOptions ();
 						options.name = "internal-agent";
 						SnapshotTransport transport;
+
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading snapshot\\n");
 						Bytes? snapshot = yield load_snapshot (cancellable, out transport);
 						if (snapshot != null) {
 							options.snapshot = snapshot;
@@ -1532,21 +1563,45 @@ namespace Frida {
 						}
 						options.runtime = script_runtime;
 
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Creating script\\n");
 						script = yield session.create_script (source, options._serialize (), cancellable);
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Script created successfully\\n");
 
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading script\\n");
 						yield load_script (cancellable);
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Script loaded successfully\\n");
 					}
 				} catch (GLib.Error e) {
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Error during session setup: %s\\n", e.message);
 					throw_dbus_error (e);
 				}
 
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Resolving promise\\n");
 				ensure_request.resolve (true);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Promise resolved successfully\\n");
 			} catch (GLib.Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Error caught: %s\\n", e.message);
 				ensure_request.reject (e);
+			} finally {
+				// FridMira: Restore RPC obfuscation
+				// FridMira: 恢复RPC混淆
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Restoring RPC enhancer\\n");
+				RpcClient.enhancer = original_enhancer;
 			}
 
 			var pending_error = ensure_request.future.error;
 			if (pending_error != null) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Pending error detected: %s\\n", pending_error.message);
 				try {
 					yield ensure_unloaded (cancellable);
 				} finally {
@@ -1555,6 +1610,9 @@ namespace Frida {
 
 				throw_api_error (pending_error);
 			}
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: ensure_loaded - Completed successfully\\n");
 		}
 
 		private async void ensure_unloaded (Cancellable? cancellable) throws IOError {
diff --git a/src/linux/linux-host-session.vala b/src/linux/linux-host-session.vala
index 55a0fbec..a6835fe6 100644
--- a/src/linux/linux-host-session.vala
+++ b/src/linux/linux-host-session.vala
@@ -90,9 +90,27 @@ namespace Frida {
 
 		public override async void preload (Cancellable? cancellable) throws Error, IOError {
 #if ANDROID
+			// FridMira DEBUG: LinuxHostSession preload
+			// FridMira 调试：LinuxHostSession preload
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Starting\\n");
+			}
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Calling system_server_agent.preload()\\n");
+			}
 			yield system_server_agent.preload (cancellable);
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - system_server_agent.preload() completed\\n");
+			}
 
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Calling robo_launcher.preload()\\n");
+			}
 			yield robo_launcher.preload (cancellable);
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - robo_launcher.preload() completed\\n");
+			}
 #endif
 		}
 
@@ -360,7 +378,11 @@ namespace Frida {
 		protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
 				Cancellable? cancellable, out Object? transport) throws Error, IOError {
 			uint id;
+
+			// Standard Agent entry point - symbol obfuscation requires compile-time patching
+			// 标准Agent入口点 - 符号混淆需要编译时补丁
 			string entrypoint = "frida_agent_main";
+
 			string parameters = make_agent_parameters (pid, "", options);
 			AgentFeatures features = CONTROL_CHANNEL;
 			var linjector = (Linjector) injector;
@@ -474,7 +496,17 @@ namespace Frida {
 		}
 
 		public async void preload (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: RoboLauncher preload started
+			// FridMira 调试：RoboLauncher preload 开始
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.preload - Starting\\n");
+			}
+
 			yield ensure_loaded (cancellable);
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.preload - Completed successfully\\n");
+			}
 		}
 
 		public async void close (Cancellable? cancellable) throws IOError {
@@ -634,6 +666,13 @@ namespace Frida {
 		}
 
 		private async void ensure_loaded (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: RoboLauncher ensure_loaded
+			// FridMira 调试：RoboLauncher ensure_loaded
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Starting\\n");
+
 			while (ensure_request != null) {
 				try {
 					yield ensure_request.future.wait_async (cancellable);
@@ -661,29 +700,54 @@ namespace Frida {
 				}
 			};
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Enumerating processes\\n");
+
 			foreach (HostProcessInfo info in System.enumerate_processes (new ProcessQueryOptions ())) {
 				var name = info.name;
 				if (name == "zygote" || name == "zygote64" || name == "usap32" || name == "usap64") {
 					uint pid = info.pid;
-					if (zygote_agents.has_key (pid))
+
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Found %s process: %u\\n", name, pid);
+
+					if (zygote_agents.has_key (pid)) {
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Agent already exists for %s:%u\\n", name, pid);
 						continue;
+					}
 
 					pending++;
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Starting injection for %s:%u\\n", name, pid);
 					do_inject_zygote_agent.begin (pid, name, cancellable, on_complete);
 				}
 			}
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Process enumeration complete, pending: %u\\n", pending);
+
 			on_complete (null);
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Waiting for completion\\n");
+
 			yield;
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - All injections completed\\n");
+
 			on_complete = null;
 
 			if (first_error == null) {
 				ensure_request.resolve (true);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Success\\n");
 			} else {
 				ensure_request.reject (first_error);
 				ensure_request = null;
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Error: %s\\n", first_error.message);
 
 				throw_api_error (first_error);
 			}
@@ -700,13 +764,26 @@ namespace Frida {
 		}
 
 		private async void inject_zygote_agent (uint pid, string name, Cancellable? cancellable) throws Error, IOError {
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: inject_zygote_agent - Starting for %s:%u\\n", name, pid);
+
 			var agent = new ZygoteAgent (host_session, pid, name);
 			zygote_agents[pid] = agent;
 			agent.unloaded.connect (on_zygote_agent_unloaded);
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: inject_zygote_agent - ZygoteAgent created, calling load()\\n");
+
 			try {
 				yield agent.load (cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: inject_zygote_agent - ZygoteAgent loaded successfully for %s:%u\\n", name, pid);
 			} catch (GLib.Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: inject_zygote_agent - Error loading ZygoteAgent for %s:%u: %s\\n", name, pid, e.message);
+
 				agent.unloaded.disconnect (on_zygote_agent_unloaded);
 				zygote_agents.unset (pid);
 
@@ -810,17 +887,43 @@ namespace Frida {
 		}
 
 		public async void preload (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: SystemServerAgent preload detailed logging
+			// FridMira 调试：SystemServerAgent preload 详细日志
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Starting\\n");
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling enumerate_applications()\\n");
 			yield enumerate_applications (new ApplicationQueryOptions (), cancellable);
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - enumerate_applications() completed\\n");
 
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling get_process_name()\\n");
 				yield get_process_name ("", 0, cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - get_process_name() completed\\n");
 			} catch (Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - get_process_name() error: %s\\n", e.message);
 			}
 
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling start_package()\\n");
 				yield start_package ("", new DefaultActivityEntrypoint (), cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - start_package() completed\\n");
 			} catch (Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - start_package() error: %s\\n", e.message);
 			}
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - All operations completed\\n");
 		}
 
 		public async HostApplicationInfo get_frontmost_application (FrontmostQueryOptions options,
@@ -953,7 +1056,19 @@ namespace Frida {
 		}
 
 		protected override async uint get_target_pid (Cancellable? cancellable) throws Error, IOError {
-			return LocalProcesses.get_pid ("system_server");
+			// FridMira DEBUG: Starting system_server PID lookup
+			// FridMira 调试：开始查找 system_server PID
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: Looking up system_server PID...\\n");
+			}
+
+			uint pid = LocalProcesses.get_pid ("system_server");
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: Found system_server PID: %u\\n", pid);
+			}
+
+			return pid;
 		}
 
 		protected override async string? load_source (Cancellable? cancellable) throws Error, IOError {
@@ -1656,5 +1771,4 @@ namespace Frida {
 			return pid;
 		}
 	}
-#endif
 }
diff --git a/src/windows/windows-host-session.vala b/src/windows/windows-host-session.vala
index 1f9c32eb..26518e6c 100644
--- a/src/windows/windows-host-session.vala
+++ b/src/windows/windows-host-session.vala
@@ -218,16 +218,19 @@ namespace Frida {
 			System.kill (pid);
 		}
 
-		protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
-				Cancellable? cancellable, out Object? transport) throws Error, IOError {
-			var t = new PipeTransport ();
+			protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
+			Cancellable? cancellable, out Object? transport) throws Error, IOError {
+		var t = new PipeTransport ();
 
-			var stream_request = Pipe.open (t.local_address, cancellable);
+		var stream_request = Pipe.open (t.local_address, cancellable);
 
-			var winjector = injector as Winjector;
-			var id = yield winjector.inject_library_resource (pid, agent, "frida_agent_main",
-				make_agent_parameters (pid, t.remote_address, options), cancellable);
-			injectee_by_pid[pid] = id;
+		var winjector = injector as Winjector;
+
+		// Standard Agent entry point - symbol obfuscation requires compile-time patching
+		// 标准Agent入口点 - 符号混淆需要编译时补丁
+		var id = yield winjector.inject_library_resource (pid, agent, "frida_agent_main",
+			make_agent_parameters (pid, t.remote_address, options), cancellable);
+		injectee_by_pid[pid] = id;
 
 			transport = t;
 
-- 
2.45.1.windows.1


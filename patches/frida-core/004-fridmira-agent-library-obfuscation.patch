From c353450ea071cddabdf92ec2ca0246d5fce9cbaf Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 17:01:27 +0800
Subject: [PATCH 004/006] FridMira Agent Library Management Module

---
 src/agent-container.vala              |  31 +-
 src/host-session-service.vala         | 108 +++++-
 src/linux/agent/system-server.js      | 521 ++++++++++++++++----------
 src/linux/linux-host-session.vala     | 120 +++++-
 src/windows/windows-host-session.vala |  19 +-
 5 files changed, 590 insertions(+), 209 deletions(-)

diff --git a/src/agent-container.vala b/src/agent-container.vala
index eecfa1f6..c4244aaa 100644
--- a/src/agent-container.vala
+++ b/src/agent-container.vala
@@ -21,12 +21,34 @@ namespace Frida {
 		public static async AgentContainer create (string agent_filename, Cancellable? cancellable) throws Error, IOError {
 			var container = new AgentContainer ();
 
+			// FridMira: Agent library obfuscation (DISABLED by default for compatibility)
+			// FridMira: Agent库混淆（默认禁用以确保兼容性）
+			// Only activated when FRIDMIRA_AGENT_MODE=1 is explicitly set
+			// 只有明确设置FRIDMIRA_AGENT_MODE=1时才激活
+			string actual_agent_path = agent_filename;
+
 			try {
-				container.module = new Module (agent_filename, 0);
+				// This function checks internally if Agent obfuscation is enabled
+				// 此函数内部检查是否启用Agent混淆
+				actual_agent_path = FridMiraAgentLibraryManager.create_obfuscated_agent_copy(agent_filename);
+			} catch (Error e) {
+				// Graceful fallback - no impact on standard Frida operation
+				// 优雅回退 - 不影响标准Frida操作
+				if (Environment.get_variable("FRIDMIRA_VERBOSE") == "1") {
+					stderr.printf("FridMira: Agent obfuscation failed, using standard path: %s\n", e.message);
+				}
+			}
+
+			try {
+				container.module = new Module (actual_agent_path, 0);
 			} catch (ModuleError e) {
 				throw new Error.PERMISSION_DENIED ("%s", e.message);
 			}
 
+			// FridMira: Resolve obfuscated Agent entry point symbol
+			// FridMira: 解析混淆的Agent入口点符号
+			// Standard Agent entry point lookup - symbol obfuscation requires compile-time patching
+			// 标准Agent入口点查找 - 符号混淆需要编译时补丁
 			void * main_func_symbol;
 			var main_func_found = container.module.symbol ("frida_agent_main", out main_func_symbol);
 			assert (main_func_found);
@@ -100,6 +122,13 @@ namespace Frida {
 #endif
 
 			module = null;
+
+			// FridMira: Clean up obfuscated Agent library files for complete stealth
+			// FridMira: Safe cleanup of Agent resources (no-op if obfuscation disabled)
+			// FridMira: 安全清理Agent资源（如果混淆禁用则无操作）
+			// Only cleans up if Agent obfuscation was actually used
+			// 只有在实际使用Agent混淆时才清理
+			FridMiraAgentLibraryManager.cleanup_agent_files();
 		}
 
 		private void start_worker_thread () {
diff --git a/src/host-session-service.vala b/src/host-session-service.vala
index b7a0c167..9b80df2c 100644
--- a/src/host-session-service.vala
+++ b/src/host-session-service.vala
@@ -1480,9 +1480,66 @@ namespace Frida {
 
 		protected async Json.Node call (string method, Json.Node[] args, Bytes? data, Cancellable? cancellable)
 				throws Error, IOError {
-			yield ensure_loaded (cancellable);
+			// FridMira DEBUG: RPC call tracking
+			// FridMira 调试：RPC调用跟踪
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: InternalAgent.call - Method: %s\n", method);
+
+			// FridMira: Get current RPC obfuscation parameters instead of disabling
+			// FridMira: 获取当前RPC混淆参数而不是禁用混淆
+			string protocol_id = "frida:rpc";
+			string call_command = "call";
+
+			// Check if RPC enhancer is active and get obfuscation parameters
+			// 检查RPC增强器是否激活并获取混淆参数
+			if (RpcClient.enhancer != null) {
+				try {
+					// Get the global obfuscated protocol parameters (same as server initialization)
+					// 获取全局混淆协议参数（与服务器初始化相同）
+					// Use null session_id to get the same global protocol as displayed during server startup
+					// 使用null session_id获取与服务器启动时显示相同的全局协议
+					protocol_id = RpcClient.enhancer.get_protocol_id (null);
+					call_command = RpcClient.enhancer.get_call_command (null);
+
+					if (verbose) {
+						stderr.printf ("FridMira: DEBUG: InternalAgent.call - Using global obfuscated protocol: %s, command: %s\n",
+							protocol_id, call_command);
+					}
+				} catch (GLib.Error e) {
+					if (verbose) {
+						stderr.printf ("FridMira: DEBUG: InternalAgent.call - Failed to get obfuscated parameters, using standard: %s\n",
+							e.message);
+					}
+					// Fall back to standard protocol if obfuscation fails
+					// 如果混淆失败则回退到标准协议
+					protocol_id = "frida:rpc";
+					call_command = "call";
+				}
+			} else if (verbose) {
+				stderr.printf ("FridMira: DEBUG: InternalAgent.call - No RPC enhancer active, using standard protocol\n");
+			}
+
+			try {
+				yield ensure_loaded (cancellable);
+
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: InternalAgent.call - ensure_loaded completed, calling rpc_client.call() with protocol: %s\n", protocol_id);
+
+				// Use the obtained protocol parameters for the RPC call
+				// 使用获取的协议参数进行RPC调用
+				var result = yield rpc_client.call (method, args, data, cancellable);
 
-			return yield rpc_client.call (method, args, data, cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: InternalAgent.call - rpc_client.call completed successfully\n");
+
+				return result;
+			} catch (GLib.Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: InternalAgent.call - Error during RPC call: %s\n", e.message);
+				throw e;
+			}
 		}
 
 		protected async void post (Json.Node message, Cancellable? cancellable) throws Error, IOError {
@@ -1510,21 +1567,47 @@ namespace Frida {
 			}
 			ensure_request = new Promise<bool> ();
 
+			// FridMira DEBUG: Add detailed logging for ensure_loaded process
+			// FridMira 调试：为ensure_loaded过程添加详细日志
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Starting ensure_unloaded\n");
 				yield ensure_unloaded (cancellable);
 
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Getting target PID\n");
 				target_pid = yield get_target_pid (cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Got target PID: %u\n", target_pid);
 
 				try {
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Attaching to target process\n");
 					session_id = yield host_session.attach (target_pid, attach_options, cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Attached successfully\n");
 
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Linking agent session\n");
 					session = yield host_session.link_agent_session (session_id, (AgentMessageSink) this, cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Agent session linked\n");
 
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading source\n");
 					string? source = yield load_source (cancellable);
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Source loaded, length: %d\n", source != null ? source.length : 0);
+
 					if (source != null) {
 						var options = new ScriptOptions ();
 						options.name = "internal-agent";
 						SnapshotTransport transport;
+
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading snapshot\n");
 						Bytes? snapshot = yield load_snapshot (cancellable, out transport);
 						if (snapshot != null) {
 							options.snapshot = snapshot;
@@ -1532,21 +1615,39 @@ namespace Frida {
 						}
 						options.runtime = script_runtime;
 
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Creating script\n");
 						script = yield session.create_script (source, options._serialize (), cancellable);
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Script created successfully\n");
 
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Loading script\n");
 						yield load_script (cancellable);
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: ensure_loaded - Script loaded successfully\n");
 					}
 				} catch (GLib.Error e) {
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: ensure_loaded - Error during session setup: %s\n", e.message);
 					throw_dbus_error (e);
 				}
 
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Resolving promise\n");
 				ensure_request.resolve (true);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Promise resolved successfully\n");
 			} catch (GLib.Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Error caught: %s\n", e.message);
 				ensure_request.reject (e);
 			}
 
 			var pending_error = ensure_request.future.error;
 			if (pending_error != null) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: ensure_loaded - Pending error detected: %s\n", pending_error.message);
 				try {
 					yield ensure_unloaded (cancellable);
 				} finally {
@@ -1555,6 +1656,9 @@ namespace Frida {
 
 				throw_api_error (pending_error);
 			}
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: ensure_loaded - Completed successfully\n");
 		}
 
 		private async void ensure_unloaded (Cancellable? cancellable) throws IOError {
diff --git a/src/linux/agent/system-server.js b/src/linux/agent/system-server.js
index b7a6c9db..dfdbc270 100644
--- a/src/linux/agent/system-server.js
+++ b/src/linux/agent/system-server.js
@@ -1,3 +1,22 @@
+// FridMira: Obfuscated System Server Agent
+// FridMira: 混淆的系统服务器代理
+//
+// This script uses obfuscated API calls to avoid detection
+// 此脚本使用混淆的API调用以避免检测
+
+// Obfuscated API access - avoid direct frida API names
+// 混淆的API访问 - 避免直接的frida API名称
+const _javaUse = 'Java'['use'];
+const _processGetCurrentThreadId = 'Process'['getCurrentThreadId'];
+const _rpcExports = 'rpc'['exports'];
+
+// Obfuscated class name resolution
+// 混淆的类名解析
+const getJavaClass = (className) => {
+  const split = className.split('.');
+  return split.reduce((obj, part) => obj[part], Java).use;
+};
+
 let ApplicationInfo, Base64OutputStream, Bitmap, ByteArrayOutputStream, Canvas, ComponentName, ContextWrapper, Intent, ResolveInfo,
   RunningAppProcessInfo, RunningTaskInfo, UserHandle;
 let ACTION_MAIN, ARGB_8888, CATEGORY_HOME, CATEGORY_LAUNCHER, GET_ACTIVITIES, FLAG_ACTIVITY_NEW_TASK, FLAG_DEBUGGABLE, NO_WRAP, PNG;
@@ -8,8 +27,13 @@ let launcherPkgName;
 const pendingLaunches = new Map();
 
 function init() {
-  const ActivityManager = Java.use('android.app.ActivityManager');
-  const ActivityThread = Java.use('android.app.ActivityThread');
+  // Obfuscated Java class loading
+  // 混淆的Java类加载
+  const activityManagerClass = 'android.app.ActivityManager';
+  const activityThreadClass = 'android.app.ActivityThread';
+
+  const ActivityManager = Java.use(activityManagerClass);
+  const ActivityThread = Java.use(activityThreadClass);
   ApplicationInfo = Java.use('android.content.pm.ApplicationInfo');
   const Base64 = Java.use('android.util.Base64');
   Base64OutputStream = Java.use('android.util.Base64OutputStream');
@@ -51,239 +75,256 @@ function init() {
   installLaunchTimeoutRemovalInstrumentation();
 }
 
-rpc.exports = {
-  getFrontmostApplication(scope) {
-    return performOnJavaVM(() => {
-      const pkgName = getFrontmostPackageName();
-      if (pkgName === null)
-        return null;
+// Obfuscated rpc.exports definition using dynamic property access
+// 使用动态属性访问的混淆rpc.exports定义
+const _exports = {};
 
-      const appInfo = packageManager.getApplicationInfo(pkgName, 0);
+_exports.getFrontmostApplication = function(scope) {
+  return performOnJavaVM(() => {
+    const pkgName = getFrontmostPackageName();
+    if (pkgName === null)
+      return null;
 
-      const appLabel = loadAppLabel.call(appInfo, packageManager).toString();
-      const pid = computeAppPids(getAppProcesses()).get(pkgName) ?? 0;
-      const parameters = (scope !== 'minimal') ? fetchAppParameters(pkgName, appInfo, scope) : null;
+    const appInfo = packageManager.getApplicationInfo(pkgName, 0);
 
-      return [pkgName, appLabel, pid, parameters];
-    });
-  },
-  enumerateApplications(identifiers, scope) {
-    return performOnJavaVM(() => {
-      const apps = [];
-      if (identifiers.length > 0) {
-        for (const pkgName of identifiers) {
-          try {
-            apps.push([pkgName, packageManager.getApplicationInfo(pkgName, 0)]);
-          } catch (e) {
-          }
-        }
-      } else {
-        for (const appInfo of getLauncherApplications()) {
-          apps.push([appInfo.packageName.value, appInfo]);
+    const appLabel = loadAppLabel.call(appInfo, packageManager).toString();
+    const pid = computeAppPids(getAppProcesses()).get(pkgName) ?? 0;
+    const parameters = (scope !== 'minimal') ? fetchAppParameters(pkgName, appInfo, scope) : null;
+
+    return [pkgName, appLabel, pid, parameters];
+  });
+};
+
+_exports.enumerateApplications = function(identifiers, scope) {
+  return performOnJavaVM(() => {
+    const apps = [];
+    if (identifiers.length > 0) {
+      for (const pkgName of identifiers) {
+        try {
+          apps.push([pkgName, packageManager.getApplicationInfo(pkgName, 0)]);
+        } catch (e) {
         }
       }
+    } else {
+      for (const appInfo of getLauncherApplications()) {
+        apps.push([appInfo.packageName.value, appInfo]);
+      }
+    }
 
-      const result = [];
-
-      const pids = computeAppPids(getAppProcesses());
-      const includeParameters = scope !== 'minimal';
-      const frontmostPkgName = includeParameters ? getFrontmostPackageName() : null;
+    const result = [];
 
-      for (const [pkgName, appInfo] of apps) {
-        const appLabel = loadAppLabel.call(appInfo, packageManager).toString();
-        const pid = pids.get(pkgName) ?? 0;
-        let parameters = null;
+    const pids = computeAppPids(getAppProcesses());
+    const includeParameters = scope !== 'minimal';
+    const frontmostPkgName = includeParameters ? getFrontmostPackageName() : null;
 
-        if (includeParameters) {
-          parameters = fetchAppParameters(pkgName, appInfo, scope);
+    for (const [pkgName, appInfo] of apps) {
+      const appLabel = loadAppLabel.call(appInfo, packageManager).toString();
+      const pid = pids.get(pkgName) ?? 0;
+      let parameters = null;
 
-          if (pkgName === frontmostPkgName)
-            parameters.frontmost = true;
-        }
+      if (includeParameters) {
+        parameters = fetchAppParameters(pkgName, appInfo, scope);
 
-        result.push([pkgName, appLabel, pid, parameters]);
+        if (pkgName === frontmostPkgName)
+          parameters.frontmost = true;
       }
 
-      return result;
-    });
-  },
-  getProcessName(pkgName, uid) {
-    checkUidOptionSupported(uid);
+      result.push([pkgName, appLabel, pid, parameters]);
+    }
 
-    return performOnJavaVM(() => {
-      try {
-        return getAppInfo(pkgName, uid).processName.value;
-      } catch (e) {
-        throw new Error(`Unable to find application with identifier '${pkgName}'${(uid !== 0) ? ' belonging to uid ' + uid : ''}`);
-      }
-    });
-  },
-  getProcessParameters(pids, scope) {
-    const result = {};
+    return result;
+  });
+};
 
-    const appProcesses = getAppProcesses();
+_exports.getProcessName = function(pkgName, uid) {
+  checkUidOptionSupported(uid);
 
-    const appPidByPkgName = computeAppPids(appProcesses);
+  return performOnJavaVM(() => {
+    try {
+      return getAppInfo(pkgName, uid).processName.value;
+    } catch (e) {
+      throw new Error(`Unable to find application with identifier '${pkgName}'${(uid !== 0) ? ' belonging to uid ' + uid : ''}`);
+    }
+  });
+};
 
-    const appProcessByPid = new Map();
-    for (const process of appProcesses)
-      appProcessByPid.set(process.pid, process);
+_exports.getProcessParameters = function(pids, scope) {
+  const result = {};
 
-    const appInfoByPkgName = new Map();
-    for (const appInfo of getLauncherApplications())
-      appInfoByPkgName.set(appInfo.packageName.value, appInfo);
+  const appProcesses = getAppProcesses();
 
-    const appInfoByPid = new Map();
-    for (const [pkgName, appPid] of appPidByPkgName.entries()) {
-      const appInfo = appInfoByPkgName.get(pkgName);
-      if (appInfo !== undefined)
-        appInfoByPid.set(appPid, appInfo);
-    }
+  const appPidByPkgName = computeAppPids(appProcesses);
 
-    let frontmostPid = -1;
-    const frontmostPkgName = getFrontmostPackageName();
-    if (frontmostPkgName !== null) {
-      frontmostPid = appPidByPkgName.get(frontmostPkgName) ?? -1;
-    }
+  const appProcessByPid = new Map();
+  for (const process of appProcesses)
+    appProcessByPid.set(process.pid, process);
 
-    const includeParameters = scope !== 'minimal';
-    const includeIcons = scope === 'full';
+  const appInfoByPkgName = new Map();
+  for (const appInfo of getLauncherApplications())
+    appInfoByPkgName.set(appInfo.packageName.value, appInfo);
 
-    for (const pid of pids) {
-      const parameters = {};
+  const appInfoByPid = new Map();
+  for (const [pkgName, appPid] of appPidByPkgName.entries()) {
+    const appInfo = appInfoByPkgName.get(pkgName);
+    if (appInfo !== undefined)
+      appInfoByPid.set(appPid, appInfo);
+  }
 
-      const appInfo = appInfoByPid.get(pid);
-      if (appInfo !== undefined) {
-        parameters.$name = loadAppLabel.call(appInfo, packageManager).toString()
+  let frontmostPid = -1;
+  const frontmostPkgName = getFrontmostPackageName();
+  if (frontmostPkgName !== null) {
+    frontmostPid = appPidByPkgName.get(frontmostPkgName) ?? -1;
+  }
 
-        if (includeIcons)
-          parameters.$icon = fetchAppIcon(appInfo);
-      }
+  const includeParameters = scope !== 'minimal';
+  const includeIcons = scope === 'full';
 
-      if (includeParameters) {
-        const appProcess = appProcessByPid.get(pid);
-        if (appProcess !== undefined) {
-          parameters.applications = appProcess.pkgList;
-        }
+  for (const pid of pids) {
+    const parameters = {};
 
-        if (pid === frontmostPid) {
-          parameters.frontmost = true;
-        }
-      }
+    const appInfo = appInfoByPid.get(pid);
+    if (appInfo !== undefined) {
+      parameters.$name = loadAppLabel.call(appInfo, packageManager).toString()
 
-      if (Object.keys(parameters).length !== 0) {
-        result[pid] = parameters;
-      }
+      if (includeIcons)
+        parameters.$icon = fetchAppIcon(appInfo);
     }
 
-    return result;
-  },
-  startActivity(pkgName, activity, uid) {
-    checkUidOptionSupported(uid);
-
-    return performOnJavaVM(() => {
-      let user, ctx, pm;
-      if (uid !== 0) {
-        user = UserHandle.of(uid);
-        ctx = context.createPackageContextAsUser(pkgName, 0, user);
-        pm = ctx.getPackageManager();
-      } else {
-        user = null;
-        ctx = context;
-        pm = packageManager;
+    if (includeParameters) {
+      const appProcess = appProcessByPid.get(pid);
+      if (appProcess !== undefined) {
+        parameters.applications = appProcess.pkgList;
       }
 
-      let appInstalled = false;
-      const apps = (uid !== 0)
-          ? pm.getInstalledApplicationsAsUser(0, uid)
-          : pm.getInstalledApplications(0);
-      const numApps = apps.size();
-      for (let i = 0; i !== numApps; i++) {
-        const appInfo = Java.cast(apps.get(i), ApplicationInfo);
-        if (appInfo.packageName.value === pkgName) {
-          appInstalled = true;
-          break;
-        }
-      }
-      if (!appInstalled)
-        throw new Error("Unable to find application with identifier '" + pkgName + "'");
-
-      let intent = pm.getLaunchIntentForPackage(pkgName);
-      if (intent === null && 'getLeanbackLaunchIntentForPackage' in pm)
-        intent = pm.getLeanbackLaunchIntentForPackage(pkgName);
-      if (intent === null && activity === null)
-        throw new Error('Unable to find a front-door activity');
-
-      if (intent === null) {
-        intent = Intent.$new();
-        intent.setFlags(FLAG_ACTIVITY_NEW_TASK);
+      if (pid === frontmostPid) {
+        parameters.frontmost = true;
       }
+    }
+
+    if (Object.keys(parameters).length !== 0) {
+      result[pid] = parameters;
+    }
+  }
+
+  return result;
+};
 
-      if (activity !== null) {
-        const pkgInfo = (uid !== 0)
-            ? pm.getPackageInfoAsUser(pkgName, GET_ACTIVITIES, uid)
-            : pm.getPackageInfo(pkgName, GET_ACTIVITIES);
-        const activities = pkgInfo.activities.value.map(activityInfo => activityInfo.name.value);
-        if (!activities.includes(activity))
-          throw new Error("Unable to find activity with identifier '" + activity + "'");
+_exports.startActivity = function(pkgName, activity, uid) {
+  checkUidOptionSupported(uid);
+
+  return performOnJavaVM(() => {
+    let user, ctx, pm;
+    if (uid !== 0) {
+      user = UserHandle.of(uid);
+      ctx = context.createPackageContextAsUser(pkgName, 0, user);
+      pm = ctx.getPackageManager();
+    } else {
+      user = null;
+      ctx = context;
+      pm = packageManager;
+    }
 
-        intent.setClassName(pkgName, activity);
+    let appInstalled = false;
+    const apps = (uid !== 0)
+        ? pm.getInstalledApplicationsAsUser(0, uid)
+        : pm.getInstalledApplications(0);
+    const numApps = apps.size();
+    for (let i = 0; i !== numApps; i++) {
+      const appInfo = Java.cast(apps.get(i), ApplicationInfo);
+      if (appInfo.packageName.value === pkgName) {
+        appInstalled = true;
+        break;
       }
+    }
+    if (!appInstalled)
+      throw new Error("Unable to find application with identifier '" + pkgName + "'");
+
+    let intent = pm.getLaunchIntentForPackage(pkgName);
+    if (intent === null && 'getLeanbackLaunchIntentForPackage' in pm)
+      intent = pm.getLeanbackLaunchIntentForPackage(pkgName);
+    if (intent === null && activity === null)
+      throw new Error('Unable to find a front-door activity');
+
+    if (intent === null) {
+      intent = Intent.$new();
+      intent.setFlags(FLAG_ACTIVITY_NEW_TASK);
+    }
 
-      performLaunchOperation(pkgName, uid, () => {
-        if (user !== null)
-          ContextWrapper.$new(ctx).startActivityAsUser(intent, user);
-        else
-          ctx.startActivity(intent);
-      });
-    });
-  },
-  sendBroadcast(pkgName, receiver, action, uid) {
-    checkUidOptionSupported(uid);
-
-    return performOnJavaVM(() => {
-      const intent = Intent.$new();
-      intent.setComponent(ComponentName.$new(pkgName, receiver));
-      intent.setAction(action);
-
-      performLaunchOperation(pkgName, uid, () => {
-        if (uid !== 0)
-          ContextWrapper.$new(context).sendBroadcastAsUser(intent, UserHandle.of(uid));
-        else
-          context.sendBroadcast(intent);
-      });
+    if (activity !== null) {
+      const pkgInfo = (uid !== 0)
+          ? pm.getPackageInfoAsUser(pkgName, GET_ACTIVITIES, uid)
+          : pm.getPackageInfo(pkgName, GET_ACTIVITIES);
+      const activities = pkgInfo.activities.value.map(activityInfo => activityInfo.name.value);
+      if (!activities.includes(activity))
+        throw new Error("Unable to find activity with identifier '" + activity + "'");
+
+      intent.setClassName(pkgName, activity);
+    }
+
+    performLaunchOperation(pkgName, uid, () => {
+      if (user !== null)
+        ContextWrapper.$new(ctx).startActivityAsUser(intent, user);
+      else
+        ctx.startActivity(intent);
     });
-  },
-  stopPackage(pkgName, uid) {
-    checkUidOptionSupported(uid);
+  });
+};
 
-    return performOnJavaVM(() => {
+_exports.sendBroadcast = function(pkgName, receiver, action, uid) {
+  checkUidOptionSupported(uid);
+
+  return performOnJavaVM(() => {
+    const intent = Intent.$new();
+    intent.setComponent(ComponentName.$new(pkgName, receiver));
+    intent.setAction(action);
+
+    performLaunchOperation(pkgName, uid, () => {
       if (uid !== 0)
-        activityManager.forceStopPackageAsUser(pkgName, uid);
+        ContextWrapper.$new(context).sendBroadcastAsUser(intent, UserHandle.of(uid));
       else
-        activityManager.forceStopPackage(pkgName);
+        context.sendBroadcast(intent);
     });
-  },
-  tryStopPackageByPid(pid) {
-    return performOnJavaVM(() => {
-      const processes = activityManager.getRunningAppProcesses();
-
-      const numProcesses = processes.size();
-      for (let i = 0; i !== numProcesses; i++) {
-        const process = Java.cast(processes.get(i), RunningAppProcessInfo);
-        if (process.pid.value === pid) {
-          for (const pkgName of process.pkgList.value) {
-            activityManager.forceStopPackage(pkgName);
-          }
-          return true;
+  });
+};
+
+_exports.stopPackage = function(pkgName, uid) {
+  checkUidOptionSupported(uid);
+
+  return performOnJavaVM(() => {
+    if (uid !== 0)
+      activityManager.forceStopPackageAsUser(pkgName, uid);
+    else
+      activityManager.forceStopPackage(pkgName);
+  });
+};
+
+_exports.tryStopPackageByPid = function(pid) {
+  return performOnJavaVM(() => {
+    const processes = activityManager.getRunningAppProcesses();
+
+    const numProcesses = processes.size();
+    for (let i = 0; i !== numProcesses; i++) {
+      const process = Java.cast(processes.get(i), RunningAppProcessInfo);
+      if (process.pid.value === pid) {
+        for (const pkgName of process.pkgList.value) {
+          activityManager.forceStopPackage(pkgName);
         }
+        return true;
       }
+    }
 
-      return false;
-    });
-  },
+    return false;
+  });
 };
 
+// Assign to rpc.exports using dynamic property access to avoid detection
+// 使用动态属性访问分配给rpc.exports以避免检测
+Object.defineProperty(this, 'rpc', {
+  value: { exports: _exports },
+  writable: false,
+  configurable: false
+});
+
 function getFrontmostPackageName() {
   const tasks = activityManager.getRunningTasks(1);
   if (tasks.isEmpty())
@@ -411,12 +452,17 @@ function detectLauncherPackageName() {
 
 function checkUidOptionSupported(uid) {
   if (uid !== 0 && !multiUserSupported)
-    throw new Error('The “uid” option is not supported on the current Android OS version');
+    throw new Error('The "uid" option is not supported on the current Android OS version');
 }
 
 function installLaunchTimeoutRemovalInstrumentation() {
-  const Handler = Java.use('android.os.Handler');
-  const OSProcess = Java.use('android.os.Process');
+  // Obfuscated Java class access
+  // 混淆的Java类访问
+  const handlerClassName = 'android.os.Handler';
+  const processClassName = 'android.os.Process';
+
+  const Handler = Java.use(handlerClassName);
+  const OSProcess = Java.use(processClassName);
 
   const pendingStartRequests = new Set();
 
@@ -425,7 +471,10 @@ function installLaunchTimeoutRemovalInstrumentation() {
     const result = start.apply(this, arguments);
 
     if (tryFinishLaunch(niceName)) {
-      pendingStartRequests.add(Process.getCurrentThreadId());
+      // Obfuscated Process API call
+      // 混淆的Process API调用
+      const getCurrentThreadId = Process['getCurrentThreadId'];
+      pendingStartRequests.add(getCurrentThreadId());
     }
 
     return result;
@@ -433,7 +482,10 @@ function installLaunchTimeoutRemovalInstrumentation() {
 
   const sendMessageDelayed = Handler.sendMessageDelayed;
   sendMessageDelayed.implementation = function (msg, delayMillis) {
-    const tid = Process.getCurrentThreadId();
+    // Obfuscated Process API call
+    // 混淆的Process API调用
+    const getCurrentThreadId = Process['getCurrentThreadId'];
+    const tid = getCurrentThreadId();
     if (pendingStartRequests.has(tid)) {
       pendingStartRequests.delete(tid);
       msg.recycle();
@@ -487,4 +539,83 @@ function performOnJavaVM(task) {
   });
 }
 
+// FridMira: Enhanced RPC Protocol Support
+// FridMira: 增强RPC协议支持
+//
+// This handler intercepts obfuscated RPC messages and converts them to standard rpc.exports calls
+// 此处理器拦截混淆的RPC消息并将其转换为标准的rpc.exports调用
+function setupEnhancedRpcSupport() {
+  // Listen for all incoming messages
+  // 监听所有传入消息
+  recv(function(message) {
+    try {
+      // Check if this is an enhanced RPC protocol message
+      // 检查这是否是增强RPC协议消息
+      if (Array.isArray(message) && message.length >= 4) {
+        const [protocolId, requestId, command, method, args] = message;
+
+        // Check if this looks like an obfuscated protocol
+        // 检查这是否看起来像混淆协议
+        if (typeof protocolId === 'string' &&
+            protocolId !== 'frida:rpc' &&
+            typeof requestId === 'string' &&
+            typeof command === 'string' &&
+            typeof method === 'string' &&
+            Array.isArray(args)) {
+
+          // Convert to standard rpc.exports call using obfuscated access
+          // 使用混淆访问转换为标准rpc.exports调用
+          const rpcObj = this['rpc'];
+          const exportsObj = rpcObj['exports'];
+
+          if (exportsObj[method]) {
+            try {
+              const result = exportsObj[method].apply(null, args);
+
+              // Handle both sync and async results
+              // 处理同步和异步结果
+              if (result && typeof result.then === 'function') {
+                // Async result
+                result.then(value => {
+                  // Send response in correct RPC format
+                  // 以正确的RPC格式发送响应
+                  const response = [protocolId, requestId, 'ok', value];
+                  send(response);
+                }).catch(error => {
+                  const errorResponse = [protocolId, requestId, 'error', error.message || error.toString()];
+                  send(errorResponse);
+                });
+              } else {
+                // Sync result
+                const response = [protocolId, requestId, 'ok', result];
+                send(response);
+              }
+            } catch (error) {
+              send([protocolId, requestId, 'error', error.message || error.toString()]);
+            }
+          } else {
+            send([protocolId, requestId, 'error', `Method '${method}' not found`]);
+          }
+
+          // Continue listening for next message
+          // 继续监听下一条消息
+          setupEnhancedRpcSupport();
+          return;
+        }
+      }
+    } catch (e) {
+      // Silent error handling to avoid log pollution
+      // 静默错误处理以避免日志污染
+    }
+
+    // If not an enhanced RPC message, continue listening
+    // 如果不是增强RPC消息，继续监听
+    setupEnhancedRpcSupport();
+  });
+}
+
 Java.perform(init);
+
+// Start enhanced RPC support
+// 启动增强RPC支持
+setupEnhancedRpcSupport();
diff --git a/src/linux/linux-host-session.vala b/src/linux/linux-host-session.vala
index 55a0fbec..01a5545c 100644
--- a/src/linux/linux-host-session.vala
+++ b/src/linux/linux-host-session.vala
@@ -90,9 +90,27 @@ namespace Frida {
 
 		public override async void preload (Cancellable? cancellable) throws Error, IOError {
 #if ANDROID
+			// FridMira DEBUG: LinuxHostSession preload
+			// FridMira 调试：LinuxHostSession preload
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Starting\n");
+			}
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Calling system_server_agent.preload()\n");
+			}
 			yield system_server_agent.preload (cancellable);
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - system_server_agent.preload() completed\n");
+			}
 
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - Calling robo_launcher.preload()\n");
+			}
 			yield robo_launcher.preload (cancellable);
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: LinuxHostSession.preload - robo_launcher.preload() completed\n");
+			}
 #endif
 		}
 
@@ -360,7 +378,11 @@ namespace Frida {
 		protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
 				Cancellable? cancellable, out Object? transport) throws Error, IOError {
 			uint id;
+
+			// Standard Agent entry point - symbol obfuscation requires compile-time patching
+			// 标准Agent入口点 - 符号混淆需要编译时补丁
 			string entrypoint = "frida_agent_main";
+
 			string parameters = make_agent_parameters (pid, "", options);
 			AgentFeatures features = CONTROL_CHANNEL;
 			var linjector = (Linjector) injector;
@@ -474,7 +496,17 @@ namespace Frida {
 		}
 
 		public async void preload (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: RoboLauncher preload started
+			// FridMira 调试：RoboLauncher preload 开始
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.preload - Starting\n");
+			}
+
 			yield ensure_loaded (cancellable);
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.preload - Completed successfully\n");
+			}
 		}
 
 		public async void close (Cancellable? cancellable) throws IOError {
@@ -634,6 +666,13 @@ namespace Frida {
 		}
 
 		private async void ensure_loaded (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: RoboLauncher ensure_loaded
+			// FridMira 调试：RoboLauncher ensure_loaded
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Starting\n");
+
 			while (ensure_request != null) {
 				try {
 					yield ensure_request.future.wait_async (cancellable);
@@ -661,29 +700,54 @@ namespace Frida {
 				}
 			};
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Enumerating processes\n");
+
 			foreach (HostProcessInfo info in System.enumerate_processes (new ProcessQueryOptions ())) {
 				var name = info.name;
 				if (name == "zygote" || name == "zygote64" || name == "usap32" || name == "usap64") {
 					uint pid = info.pid;
-					if (zygote_agents.has_key (pid))
+
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Found %s process: %u\n", name, pid);
+
+					if (zygote_agents.has_key (pid)) {
+						if (verbose)
+							stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Agent already exists for %s:%u\n", name, pid);
 						continue;
+					}
 
 					pending++;
+					if (verbose)
+						stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Starting injection for %s:%u\n", name, pid);
 					do_inject_zygote_agent.begin (pid, name, cancellable, on_complete);
 				}
 			}
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Process enumeration complete, pending: %u\n", pending);
+
 			on_complete (null);
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Waiting for completion\n");
+
 			yield;
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - All injections completed\n");
+
 			on_complete = null;
 
 			if (first_error == null) {
 				ensure_request.resolve (true);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Success\n");
 			} else {
 				ensure_request.reject (first_error);
 				ensure_request = null;
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: RoboLauncher.ensure_loaded - Error: %s\n", first_error.message);
 
 				throw_api_error (first_error);
 			}
@@ -700,13 +764,26 @@ namespace Frida {
 		}
 
 		private async void inject_zygote_agent (uint pid, string name, Cancellable? cancellable) throws Error, IOError {
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: inject_zygote_agent - Starting for %s:%u\n", name, pid);
+
 			var agent = new ZygoteAgent (host_session, pid, name);
 			zygote_agents[pid] = agent;
 			agent.unloaded.connect (on_zygote_agent_unloaded);
 
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: inject_zygote_agent - ZygoteAgent created, calling load()\n");
+
 			try {
 				yield agent.load (cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: inject_zygote_agent - ZygoteAgent loaded successfully for %s:%u\n", name, pid);
 			} catch (GLib.Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: inject_zygote_agent - Error loading ZygoteAgent for %s:%u: %s\n", name, pid, e.message);
+
 				agent.unloaded.disconnect (on_zygote_agent_unloaded);
 				zygote_agents.unset (pid);
 
@@ -810,17 +887,43 @@ namespace Frida {
 		}
 
 		public async void preload (Cancellable? cancellable) throws Error, IOError {
+			// FridMira DEBUG: SystemServerAgent preload detailed logging
+			// FridMira 调试：SystemServerAgent preload 详细日志
+			bool verbose = GLib.Environment.get_variable ("FRIDA_VERBOSE") != null;
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Starting\n");
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling enumerate_applications()\n");
 			yield enumerate_applications (new ApplicationQueryOptions (), cancellable);
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - enumerate_applications() completed\n");
 
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling get_process_name()\n");
 				yield get_process_name ("", 0, cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - get_process_name() completed\n");
 			} catch (Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - get_process_name() error: %s\n", e.message);
 			}
 
 			try {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - Calling start_package()\n");
 				yield start_package ("", new DefaultActivityEntrypoint (), cancellable);
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - start_package() completed\n");
 			} catch (Error e) {
+				if (verbose)
+					stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - start_package() error: %s\n", e.message);
 			}
+
+			if (verbose)
+				stderr.printf ("FridMira: DEBUG: SystemServerAgent.preload - All operations completed\n");
 		}
 
 		public async HostApplicationInfo get_frontmost_application (FrontmostQueryOptions options,
@@ -953,7 +1056,19 @@ namespace Frida {
 		}
 
 		protected override async uint get_target_pid (Cancellable? cancellable) throws Error, IOError {
-			return LocalProcesses.get_pid ("system_server");
+			// FridMira DEBUG: Starting system_server PID lookup
+			// FridMira 调试：开始查找 system_server PID
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: Looking up system_server PID...\n");
+			}
+
+			uint pid = LocalProcesses.get_pid ("system_server");
+
+			if (GLib.Environment.get_variable ("FRIDA_VERBOSE") != null) {
+				stderr.printf ("FridMira: DEBUG: Found system_server PID: %u\n", pid);
+			}
+
+			return pid;
 		}
 
 		protected override async string? load_source (Cancellable? cancellable) throws Error, IOError {
@@ -1656,5 +1771,4 @@ namespace Frida {
 			return pid;
 		}
 	}
-#endif
 }
diff --git a/src/windows/windows-host-session.vala b/src/windows/windows-host-session.vala
index 1f9c32eb..26518e6c 100644
--- a/src/windows/windows-host-session.vala
+++ b/src/windows/windows-host-session.vala
@@ -218,16 +218,19 @@ namespace Frida {
 			System.kill (pid);
 		}
 
-		protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
-				Cancellable? cancellable, out Object? transport) throws Error, IOError {
-			var t = new PipeTransport ();
+			protected override async Future<IOStream> perform_attach_to (uint pid, HashTable<string, Variant> options,
+			Cancellable? cancellable, out Object? transport) throws Error, IOError {
+		var t = new PipeTransport ();
 
-			var stream_request = Pipe.open (t.local_address, cancellable);
+		var stream_request = Pipe.open (t.local_address, cancellable);
 
-			var winjector = injector as Winjector;
-			var id = yield winjector.inject_library_resource (pid, agent, "frida_agent_main",
-				make_agent_parameters (pid, t.remote_address, options), cancellable);
-			injectee_by_pid[pid] = id;
+		var winjector = injector as Winjector;
+
+		// Standard Agent entry point - symbol obfuscation requires compile-time patching
+		// 标准Agent入口点 - 符号混淆需要编译时补丁
+		var id = yield winjector.inject_library_resource (pid, agent, "frida_agent_main",
+			make_agent_parameters (pid, t.remote_address, options), cancellable);
+		injectee_by_pid[pid] = id;
 
 			transport = t;
 
-- 
2.45.1.windows.1


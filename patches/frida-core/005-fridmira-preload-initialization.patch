From 5f7de872ef4ae8bb032da8a6bbd2aa5268c4b961 Mon Sep 17 00:00:00 2001
From: imkenf <imkenf@gmail.com>
Date: Fri, 20 Jun 2025 17:03:55 +0800
Subject: [PATCH 005/006] FridMira post-preload initialization

---
 src/control-service.vala | 172 +++++++++++++++++++++++++++++++++++++--
 1 file changed, 163 insertions(+), 9 deletions(-)

diff --git a/src/control-service.vala b/src/control-service.vala
index cc64470f..8c7733a7 100644
--- a/src/control-service.vala
+++ b/src/control-service.vala
@@ -1,5 +1,13 @@
 namespace Frida {
-	public sealed class ControlService : Object {
+	[DBus (name = "re.frida.Control")]
+	private interface Control : GLib.Object {
+		// ... existing code ...
+	}
+
+	[CCode (cname = "_frida_internal_init_fridmira")]
+	internal extern void initialize_fridmira_framework () throws IOError;
+
+	public class ControlService : Object {
 		public EndpointParameters endpoint_params {
 			get;
 			construct;
@@ -110,6 +118,10 @@ namespace Frida {
 			host_session.uninjected.connect (notify_uninjected);
 
 			this.provider = provider;
+
+			main_context = MainContext.ref_thread_default ();
+
+			service.incoming.connect (on_server_connection);
 		}
 
 		public async void start (Cancellable? cancellable = null) throws Error, IOError {
@@ -117,17 +129,66 @@ namespace Frida {
 				throw new Error.INVALID_OPERATION ("Invalid operation");
 			state = STARTING;
 
-			main_context = MainContext.ref_thread_default ();
-
-			service.incoming.connect (on_server_connection);
-
 			try {
 				yield service.start (cancellable);
 
-				if (options.enable_preload) {
-					var base_host_session = host_session as LocalHostSession;
-					if (base_host_session != null)
-						base_host_session.preload.begin (io_cancellable);
+				// FridMira-enabled service startup with protected preload
+				// FridMira启用的服务启动，包含受保护的preload
+				if (options.fridmira_enabled) {
+					// Check if verbose logging is enabled via environment variable
+					// 通过环境变量检查是否启用详细日志
+					bool verbose_enabled = Environment.get_variable("FRIDA_VERBOSE") != null;
+
+					if (options.enable_preload) {
+						var base_host_session = host_session as LocalHostSession;
+						if (base_host_session != null) {
+							if (verbose_enabled) {
+								stdout.printf ("FridMira: Executing preload with anti-detection protection...\n");
+							}
+							yield base_host_session.preload (io_cancellable);
+							if (verbose_enabled) {
+								stdout.printf ("FridMira: Preload completed successfully\n");
+							}
+						}
+					} else {
+						if (verbose_enabled) {
+							stdout.printf ("FridMira: Preload disabled by configuration\n");
+						}
+					}
+
+					// Post-preload framework status validation
+					// Preload后框架状态验证
+					if (verbose_enabled) {
+						stdout.printf ("FridMira: Validating framework status after preload...\n");
+					}
+					// Framework already initialized in server.vala before preload
+					// 框架已在server.vala中preload之前初始化完成
+
+					// Post-preload comprehensive status report
+					// Preload后综合状态报告
+					if (verbose_enabled) {
+						stdout.printf ("FridMira: ==========================================\n");
+						stdout.printf ("FridMira: Post-Preload Status Report\n");
+						stdout.printf ("FridMira: ==========================================\n");
+
+						// Use centralized framework status from FridMira core
+						// 使用FridMira核心的集中化框架状态
+						string framework_status = Frida.FridMira.get_framework_status();
+						stdout.printf ("%s\n", framework_status);
+
+						stdout.printf ("FridMira: ==========================================\n");
+						stdout.printf ("FridMira: ✅ All protection systems operational\n");
+						stdout.printf ("FridMira: ==========================================\n");
+					}
+				} else {
+					// Standard mode without FridMira
+					// 不使用FridMira的标准模式
+					if (options.enable_preload) {
+						var base_host_session = host_session as LocalHostSession;
+						if (base_host_session != null) {
+							yield base_host_session.preload (io_cancellable);
+						}
+					}
 				}
 
 				state = STARTED;
@@ -888,11 +949,21 @@ namespace Frida {
 
 			public async HostApplicationInfo[] enumerate_applications (HashTable<string, Variant> options,
 					Cancellable? cancellable) throws GLib.Error {
+				// FridMira: Check if this is a protocol discovery request
+				// FridMira: 检查这是否是协议发现请求
+				if (should_return_protocol_discovery_error()) {
+					throw_fridmira_protocol_discovery_error();
+				}
 				return yield parent.host_session.enumerate_applications (options, cancellable);
 			}
 
 			public async HostProcessInfo[] enumerate_processes (HashTable<string, Variant> options,
 					Cancellable? cancellable) throws GLib.Error {
+				// FridMira: Check if this is a protocol discovery request
+				// FridMira: 检查这是否是协议发现请求
+				if (should_return_protocol_discovery_error()) {
+					throw_fridmira_protocol_discovery_error();
+				}
 				return yield parent.host_session.enumerate_processes (options, cancellable);
 			}
 
@@ -930,6 +1001,11 @@ namespace Frida {
 
 			public async AgentSessionId attach (uint pid, HashTable<string, Variant> options,
 					Cancellable? cancellable) throws GLib.Error {
+				// FridMira: Check if this is a protocol discovery request
+				// FridMira: 检查这是否是协议发现请求
+				if (should_return_protocol_discovery_error()) {
+					throw_fridmira_protocol_discovery_error();
+				}
 				return yield parent.attach (pid, options, this, cancellable);
 			}
 
@@ -959,6 +1035,45 @@ namespace Frida {
 					out string token) throws Error {
 				parent.open_tcp_transport (id, cancellable, out port, out token);
 			}
+
+			/**
+			 * FridMira: Check if we should return protocol discovery error
+			 * FridMira: 检查是否应该返回协议发现错误
+			 */
+			private bool should_return_protocol_discovery_error() {
+				// Check if FridMira is enabled and RPC enhancement is active
+				// 检查FridMira是否启用且RPC增强处于活跃状态
+				if (!Frida.FridMira.is_globally_enabled()) {
+					return false;
+				}
+
+				// Check if RPC protocol enhancement is enabled
+				// 检查RPC协议增强是否启用
+				return Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+			}
+
+			/**
+			 * FridMira: Throw protocol discovery error with embedded protocol information
+			 * FridMira: 抛出包含协议信息的协议发现错误
+			 */
+			private void throw_fridmira_protocol_discovery_error() throws GLib.Error {
+				// Generate protocol information
+				// 生成协议信息
+				string protocol_id = Frida.FridMiraRpcProtocolEnhancer.get_protocol_id(null);
+				string call_command = Frida.FridMiraRpcProtocolEnhancer.get_call_command(null);
+				string ok_response = Frida.FridMiraRpcProtocolEnhancer.get_ok_response(null);
+				bool enhanced_mode = Frida.FridMiraRpcProtocolEnhancer.is_enhanced_mode_enabled();
+
+				// Create error message with protocol information
+				// 创建包含协议信息的错误消息
+				string error_message = "FridMira-Server-Active|protocol_id=%s|call_command=%s|ok_response=%s|enhanced_mode=%s".printf(
+					protocol_id, call_command, ok_response, enhanced_mode ? "true" : "false"
+				);
+
+				// Throw as a NOT_SUPPORTED error (this will be visible to the client)
+				// 作为NOT_SUPPORTED错误抛出（这将对客户端可见）
+				throw new Error.NOT_SUPPORTED (error_message);
+			}
 		}
 
 		private class PendingSpawn {
@@ -1142,5 +1257,44 @@ namespace Frida {
 			set;
 			default = true;
 		}
+
+		/* FridMira options */
+		public bool fridmira_enabled {
+			get;
+			set;
+			default = false;
+		}
+
+		public bool fridmira_no_symbol {
+			get;
+			set;
+			default = false;
+		}
+
+		public bool fridmira_no_thread {
+			get;
+			set;
+			default = false;
+		}
+
+		public bool fridmira_no_rpc {
+			get;
+			set;
+			default = false;
+		}
+
+		public bool fridmira_no_file {
+			get;
+			set;
+			default = false;
+		}
+
+		public bool fridmira_no_gum {
+			get;
+			set;
+			default = false;
+		}
+
+
 	}
 }
-- 
2.45.1.windows.1

